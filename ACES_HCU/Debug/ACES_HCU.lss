
ACES_HCU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000de8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000e5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000022  00800060  00800060  00000e5c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e5c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000e8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000ec8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000120e  00000000  00000000  00000f50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000764  00000000  00000000  0000215e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000859  00000000  00000000  000028c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001a4  00000000  00000000  0000311c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000047e  00000000  00000000  000032c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000451  00000000  00000000  0000373e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  00003b8f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 29 04 	jmp	0x852	; 0x852 <__vector_3>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3a 04 	jmp	0x874	; 0x874 <__vector_5>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__vector_9>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a2 38       	cpi	r26, 0x82	; 130
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 a9 04 	call	0x952	; 0x952 <main>
  74:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <__vector_9>:
 *
 *  @param TIMER1_OVF_vect    The interrupt vector for the overflow of timer 1 
 *  @return Void
 */
ISR(TIMER1_OVF_vect)
{
  7c:	1f 92       	push	r1
  7e:	0f 92       	push	r0
  80:	0f b6       	in	r0, 0x3f	; 63
  82:	0f 92       	push	r0
  84:	11 24       	eor	r1, r1
  86:	8f 93       	push	r24
  88:	9f 93       	push	r25
	// The LED is on PD5
	alive_counter++;
  8a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <alive_counter>
  8e:	8f 5f       	subi	r24, 0xFF	; 255
  90:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <alive_counter>
	if (alive_counter % 2 == 1)
  94:	80 ff       	sbrs	r24, 0
  96:	04 c0       	rjmp	.+8      	; 0xa0 <__vector_9+0x24>
		PORTD ^= (1 << Alive_LED);
  98:	92 b3       	in	r25, 0x12	; 18
  9a:	80 e2       	ldi	r24, 0x20	; 32
  9c:	89 27       	eor	r24, r25
  9e:	82 bb       	out	0x12, r24	; 18
		
	PORTB ^= (1 << Warm_LED);   // This will have the warming LED blink 0.5 sec on 0.5 sec off and the alive LED blinking twice as slow
  a0:	98 b3       	in	r25, 0x18	; 24
  a2:	82 e0       	ldi	r24, 0x02	; 2
  a4:	89 27       	eor	r24, r25
  a6:	88 bb       	out	0x18, r24	; 24
	
	// Now reset the register
	TCNT1 = 3036;  // The interrupt will clear automatically when this function is called
  a8:	8c ed       	ldi	r24, 0xDC	; 220
  aa:	9b e0       	ldi	r25, 0x0B	; 11
  ac:	9d bd       	out	0x2d, r25	; 45
  ae:	8c bd       	out	0x2c, r24	; 44
}
  b0:	9f 91       	pop	r25
  b2:	8f 91       	pop	r24
  b4:	0f 90       	pop	r0
  b6:	0f be       	out	0x3f, r0	; 63
  b8:	0f 90       	pop	r0
  ba:	1f 90       	pop	r1
  bc:	18 95       	reti

000000be <assign_bit>:
 *  @param[in] val The value, either 1 or 0, that the user would like the bit to be after the function call.
 *  @return void
 */
void assign_bit(volatile uint8_t *sfr,uint8_t bit, uint8_t val)
{
	if (val)      // This is for if I want the value to be a 1
  be:	44 23       	and	r20, r20
  c0:	59 f0       	breq	.+22     	; 0xd8 <assign_bit+0x1a>
	{
		val = (val << bit);
  c2:	50 e0       	ldi	r21, 0x00	; 0
  c4:	02 c0       	rjmp	.+4      	; 0xca <assign_bit+0xc>
  c6:	44 0f       	add	r20, r20
  c8:	55 1f       	adc	r21, r21
  ca:	6a 95       	dec	r22
  cc:	e2 f7       	brpl	.-8      	; 0xc6 <assign_bit+0x8>
		*sfr |= val;
  ce:	fc 01       	movw	r30, r24
  d0:	20 81       	ld	r18, Z
  d2:	42 2b       	or	r20, r18
  d4:	40 83       	st	Z, r20
  d6:	08 95       	ret
	}
	else             // This is for if I want the value to be a 0
	{
		val = ~(1 << bit);
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	02 c0       	rjmp	.+4      	; 0xe2 <assign_bit+0x24>
  de:	22 0f       	add	r18, r18
  e0:	33 1f       	adc	r19, r19
  e2:	6a 95       	dec	r22
  e4:	e2 f7       	brpl	.-8      	; 0xde <assign_bit+0x20>
  e6:	20 95       	com	r18
		*sfr &= val;
  e8:	fc 01       	movw	r30, r24
  ea:	30 81       	ld	r19, Z
  ec:	23 23       	and	r18, r19
  ee:	20 83       	st	Z, r18
  f0:	08 95       	ret

000000f2 <Initial>:
 */
void Initial(void)
{
	// First setup the port directions for the PWM lines and the
	// 0 are inputs 1 are outputs
	DDRA = 0b10000000;          // Only PA7 is an output
  f2:	80 e8       	ldi	r24, 0x80	; 128
  f4:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0b11011010;         
  f6:	8a ed       	ldi	r24, 0xDA	; 218
  f8:	87 bb       	out	0x17, r24	; 23
	DDRC = 0xFF;                // Make all outputs
  fa:	8f ef       	ldi	r24, 0xFF	; 255
  fc:	84 bb       	out	0x14, r24	; 20
	DDRD = 0xFF;                // Make all outputs
  fe:	81 bb       	out	0x11, r24	; 17
	
	opMode = 0;     // This sets the function mode to heating mode
 100:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <opMode>
	desired_temp = 0;
 104:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <desired_temp>
	duty_cycle = (pump_m*fuelFlow + pump_b) / pump_tot_V;    // This is the initial guess for the fuel pump
 108:	89 e1       	ldi	r24, 0x19	; 25
 10a:	9a e6       	ldi	r25, 0x6A	; 106
 10c:	ad ea       	ldi	r26, 0xAD	; 173
 10e:	be e3       	ldi	r27, 0x3E	; 62
 110:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <duty_cycle>
 114:	90 93 67 00 	sts	0x0067, r25	; 0x800067 <duty_cycle+0x1>
 118:	a0 93 68 00 	sts	0x0068, r26	; 0x800068 <duty_cycle+0x2>
 11c:	b0 93 69 00 	sts	0x0069, r27	; 0x800069 <duty_cycle+0x3>
	
	// Now calculate the number of pulses I expect per 0.262144 seconds (max time for an 8 bit timer with prescalar of 1024)
	float pulse_flow = (fuelFlow / density) * K_factor * max_time / 1000;
	desired_pulses = (uint8_t) pulse_flow;                                    // round down and convert to an 8 bit number.  I expect it to be 170 so it will fit.
 120:	8a ea       	ldi	r24, 0xAA	; 170
 122:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <desired_pulses>
	pulse_error_allow = (uint8_t)(desired_pulses * (fuelError / fuelFlow));   // This is the amount of pulses I can be off for it to still be considered a successes
 126:	84 e0       	ldi	r24, 0x04	; 4
 128:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	assign_bit(&MCUCSR,ISC2,1);                                               // This will cause interrupts for INT2 to be caused on the rising edge
 12c:	41 e0       	ldi	r20, 0x01	; 1
 12e:	66 e0       	ldi	r22, 0x06	; 6
 130:	84 e5       	ldi	r24, 0x54	; 84
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&GIFR, INTF2, 1);                                              // Make sure the interrupt flag is cleared
 138:	41 e0       	ldi	r20, 0x01	; 1
 13a:	65 e0       	ldi	r22, 0x05	; 5
 13c:	8a e5       	ldi	r24, 0x5A	; 90
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	
	// Configure the ADC
	ADCSRA |= 1 << ADPS2;   // This is so there is a prescalar of 16.  ADC needs frequency between 50-200kHz so 1,000,000/16 puts it in this range.
 144:	86 b1       	in	r24, 0x06	; 6
 146:	84 60       	ori	r24, 0x04	; 4
 148:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 1 << ADEN;    // Enable the ADC
 14a:	86 b1       	in	r24, 0x06	; 6
 14c:	80 68       	ori	r24, 0x80	; 128
 14e:	86 b9       	out	0x06, r24	; 6
	ADMUX |= 1 << REFS0;    // Make AVCC (5V) the reference voltage
 150:	87 b1       	in	r24, 0x07	; 7
 152:	80 64       	ori	r24, 0x40	; 64
 154:	87 b9       	out	0x07, r24	; 7

	sei();       // This sets the global interrupt flag to allow for hardware interrupts
 156:	78 94       	sei
	
	// Now enable the timer1 for 0.5 sec
	TIMSK |= 1 << TOIE1;                 // turn on overflow interrupts
 158:	89 b7       	in	r24, 0x39	; 57
 15a:	84 60       	ori	r24, 0x04	; 4
 15c:	89 bf       	out	0x39, r24	; 57
	TCCR1B |= (1<<CS11);                 // This has a prescalar of 8
 15e:	8e b5       	in	r24, 0x2e	; 46
 160:	82 60       	ori	r24, 0x02	; 2
 162:	8e bd       	out	0x2e, r24	; 46
	TCNT1 = 3036;                        // This will load the value so that when using a prescalar of 8, it will overflow after 500ms
 164:	8c ed       	ldi	r24, 0xDC	; 220
 166:	9b e0       	ldi	r25, 0x0B	; 11
 168:	9d bd       	out	0x2d, r25	; 45
 16a:	8c bd       	out	0x2c, r24	; 44
	
	saveTemps[0] = -100.0;        // Assign initial temperature values that for sure will be colder than the specified temps 
 16c:	ea e6       	ldi	r30, 0x6A	; 106
 16e:	f0 e0       	ldi	r31, 0x00	; 0
 170:	80 e0       	ldi	r24, 0x00	; 0
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	a8 ec       	ldi	r26, 0xC8	; 200
 176:	b2 ec       	ldi	r27, 0xC2	; 194
 178:	80 83       	st	Z, r24
 17a:	91 83       	std	Z+1, r25	; 0x01
 17c:	a2 83       	std	Z+2, r26	; 0x02
 17e:	b3 83       	std	Z+3, r27	; 0x03
	saveTemps[1] = -100.0;
 180:	84 83       	std	Z+4, r24	; 0x04
 182:	95 83       	std	Z+5, r25	; 0x05
 184:	a6 83       	std	Z+6, r26	; 0x06
 186:	b7 83       	std	Z+7, r27	; 0x07
	saveTemps[2] = -100.0;
 188:	80 87       	std	Z+8, r24	; 0x08
 18a:	91 87       	std	Z+9, r25	; 0x09
 18c:	a2 87       	std	Z+10, r26	; 0x0a
 18e:	b3 87       	std	Z+11, r27	; 0x0b
	saveTemps[3] = -100.0;
 190:	84 87       	std	Z+12, r24	; 0x0c
 192:	95 87       	std	Z+13, r25	; 0x0d
 194:	a6 87       	std	Z+14, r26	; 0x0e
 196:	b7 87       	std	Z+15, r27	; 0x0f
	saveTemps[4] = -100.0;
 198:	80 8b       	std	Z+16, r24	; 0x10
 19a:	91 8b       	std	Z+17, r25	; 0x11
 19c:	a2 8b       	std	Z+18, r26	; 0x12
 19e:	b3 8b       	std	Z+19, r27	; 0x13
	saveTemps[5] = -100.0;
 1a0:	84 8b       	std	Z+20, r24	; 0x14
 1a2:	95 8b       	std	Z+21, r25	; 0x15
 1a4:	a6 8b       	std	Z+22, r26	; 0x16
 1a6:	b7 8b       	std	Z+23, r27	; 0x17
	saveTemps[6] = -100.0; 
 1a8:	80 8f       	std	Z+24, r24	; 0x18
 1aa:	91 8f       	std	Z+25, r25	; 0x19
 1ac:	a2 8f       	std	Z+26, r26	; 0x1a
 1ae:	b3 8f       	std	Z+27, r27	; 0x1b
	
	// Now I need to turn on all of the heaters as well as set the duty cycles for the PWMs which will be on timers 0 and 2
	// Start with the PWM for the ECU, this will be on timer0
	TCNT0 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
 1b0:	12 be       	out	0x32, r1	; 50
	assign_bit(&TCCR0, WGM01, 1);
 1b2:	41 e0       	ldi	r20, 0x01	; 1
 1b4:	63 e0       	ldi	r22, 0x03	; 3
 1b6:	83 e5       	ldi	r24, 0x53	; 83
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, WGM00, 1);      // These two set the PWM Mode to "Fast PWM"
 1be:	41 e0       	ldi	r20, 0x01	; 1
 1c0:	66 e0       	ldi	r22, 0x06	; 6
 1c2:	83 e5       	ldi	r24, 0x53	; 83
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM01, 1); 
 1ca:	41 e0       	ldi	r20, 0x01	; 1
 1cc:	65 e0       	ldi	r22, 0x05	; 5
 1ce:	83 e5       	ldi	r24, 0x53	; 83
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM00, 1);      // These two set the PWM type to inverting PWM
 1d6:	41 e0       	ldi	r20, 0x01	; 1
 1d8:	64 e0       	ldi	r22, 0x04	; 4
 1da:	83 e5       	ldi	r24, 0x53	; 83
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	OCR0 = 255 - (255*ECU_duty);       // This will set it to the specified duty by the #define
 1e2:	8f e7       	ldi	r24, 0x7F	; 127
 1e4:	8c bf       	out	0x3c, r24	; 60
	
	TCCR0 |= (1 << CS02);              // This will start the PWM with a duty cycle of 65.536 ms
 1e6:	83 b7       	in	r24, 0x33	; 51
 1e8:	84 60       	ori	r24, 0x04	; 4
 1ea:	83 bf       	out	0x33, r24	; 51
	
	// Now do the PWM for the second fuel line which will use Timer 2,  this will look very similar to the last few lines of code
	TCNT2 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
 1ec:	14 bc       	out	0x24, r1	; 36
	assign_bit(&TCCR2, WGM21, 1);
 1ee:	41 e0       	ldi	r20, 0x01	; 1
 1f0:	63 e0       	ldi	r22, 0x03	; 3
 1f2:	85 e4       	ldi	r24, 0x45	; 69
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, WGM20, 1);      // These two set the PWM Mode to "Fast PWM"
 1fa:	41 e0       	ldi	r20, 0x01	; 1
 1fc:	66 e0       	ldi	r22, 0x06	; 6
 1fe:	85 e4       	ldi	r24, 0x45	; 69
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM21, 1);
 206:	41 e0       	ldi	r20, 0x01	; 1
 208:	65 e0       	ldi	r22, 0x05	; 5
 20a:	85 e4       	ldi	r24, 0x45	; 69
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM20, 1);      // These two set the PWM type to inverting PWM
 212:	41 e0       	ldi	r20, 0x01	; 1
 214:	64 e0       	ldi	r22, 0x04	; 4
 216:	85 e4       	ldi	r24, 0x45	; 69
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
	OCR2 = 255 - (255*F_line_duty);    // This will set it to the specified duty by the #define
 21e:	89 ec       	ldi	r24, 0xC9	; 201
 220:	83 bd       	out	0x23, r24	; 35
		
	TCCR2 |= (1 << CS22);              // This will start the PWM with a duty cycle of 65.536 ms, just like before
 222:	85 b5       	in	r24, 0x25	; 37
 224:	84 60       	ori	r24, 0x04	; 4
 226:	85 bd       	out	0x25, r24	; 37
	
	// Now turn on all the other heaters
	assign_bit(&PORTD, BatPin, 1);
 228:	41 e0       	ldi	r20, 0x01	; 1
 22a:	60 e0       	ldi	r22, 0x00	; 0
 22c:	82 e3       	ldi	r24, 0x32	; 50
 22e:	90 e0       	ldi	r25, 0x00	; 0
 230:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, HopperPin, 1);
 234:	41 e0       	ldi	r20, 0x01	; 1
 236:	61 e0       	ldi	r22, 0x01	; 1
 238:	82 e3       	ldi	r24, 0x32	; 50
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, FLine1Pin, 1);
 240:	41 e0       	ldi	r20, 0x01	; 1
 242:	62 e0       	ldi	r22, 0x02	; 2
 244:	82 e3       	ldi	r24, 0x32	; 50
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, ESB_Pin, 1);     // I can omit doing this for the ECU and FuelLine1
 24c:	41 e0       	ldi	r20, 0x01	; 1
 24e:	63 e0       	ldi	r22, 0x03	; 3
 250:	82 e3       	ldi	r24, 0x32	; 50
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 258:	08 95       	ret

0000025a <flowMeter>:
 *  @param void
 *  @return void
 *  @note Need to do a pump test to ensure that the voltage to flow rate function is actually correct.
 */
void flowMeter(void)
{
 25a:	cf 92       	push	r12
 25c:	df 92       	push	r13
 25e:	ef 92       	push	r14
 260:	ff 92       	push	r15
 262:	0f 93       	push	r16
 264:	1f 93       	push	r17
 266:	cf 93       	push	r28
 268:	df 93       	push	r29
	// First I need to enable interrupt on INT2
	pulse_count = 0;
 26a:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <pulse_count>
	GICR |= (1 << INT2);     // enable INT2 external interrupts
 26e:	8b b7       	in	r24, 0x3b	; 59
 270:	80 62       	ori	r24, 0x20	; 32
 272:	8b bf       	out	0x3b, r24	; 59
	
	// Second I need to begin timer0
	TCNT0 = 0;                                 // Make sure the timer/counter register is cleared so the full range can be used
 274:	12 be       	out	0x32, r1	; 50
	assign_bit(&TIFR,TOV1,1);                  // Make sure the overflow flag is set
 276:	41 e0       	ldi	r20, 0x01	; 1
 278:	62 e0       	ldi	r22, 0x02	; 2
 27a:	88 e5       	ldi	r24, 0x58	; 88
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS02,1);
 282:	41 e0       	ldi	r20, 0x01	; 1
 284:	62 e0       	ldi	r22, 0x02	; 2
 286:	83 e5       	ldi	r24, 0x53	; 83
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS01,0);
 28e:	40 e0       	ldi	r20, 0x00	; 0
 290:	61 e0       	ldi	r22, 0x01	; 1
 292:	83 e5       	ldi	r24, 0x53	; 83
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS00,1);                 // TThis will start the timer with a prescalar of 1024
 29a:	41 e0       	ldi	r20, 0x01	; 1
 29c:	60 e0       	ldi	r22, 0x00	; 0
 29e:	83 e5       	ldi	r24, 0x53	; 83
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	while (!(TIFR & 0x01));                    // Hog the execution until the overflow flag is set
 2a6:	08 b6       	in	r0, 0x38	; 56
 2a8:	00 fe       	sbrs	r0, 0
 2aa:	fd cf       	rjmp	.-6      	; 0x2a6 <flowMeter+0x4c>
	
	assign_bit(&GICR, INT2, 0);                // disable external interrupts for INT2
 2ac:	40 e0       	ldi	r20, 0x00	; 0
 2ae:	65 e0       	ldi	r22, 0x05	; 5
 2b0:	8b e5       	ldi	r24, 0x5B	; 91
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
	if (!pulse_count)                          // There is either no more fuel or there is a stoppage.  This if statement might be the end of me...
 2b8:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <pulse_count>
 2bc:	81 11       	cpse	r24, r1
 2be:	1c c0       	rjmp	.+56     	; 0x2f8 <flowMeter+0x9e>
	{
		opMode = 2;                            //  This means that the pumping has concluded
 2c0:	82 e0       	ldi	r24, 0x02	; 2
 2c2:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
		assign_bit(&TCCR1B, CS10, 0);          // This should stop the PWM for the pump
 2c6:	40 e0       	ldi	r20, 0x00	; 0
 2c8:	60 e0       	ldi	r22, 0x00	; 0
 2ca:	8e e4       	ldi	r24, 0x4E	; 78
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD, Fuel_LED, 1);
 2d2:	41 e0       	ldi	r20, 0x01	; 1
 2d4:	66 e0       	ldi	r22, 0x06	; 6
 2d6:	82 e3       	ldi	r24, 0x32	; 50
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCNT2 = 60;                               // Value needed for the timer to run for 0.05 second
 2de:	8c e3       	ldi	r24, 0x3C	; 60
 2e0:	84 bd       	out	0x24, r24	; 36
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
 2e2:	41 e0       	ldi	r20, 0x01	; 1
 2e4:	65 e0       	ldi	r22, 0x05	; 5
 2e6:	82 e3       	ldi	r24, 0x32	; 50
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		alive_counter = 0;                        // reset the hand made prescalar
 2ee:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <alive_counter>
		TCCR2 = 0x06;                             // This will start the Timer with a prescalar of 256 and stop the PWM stuff
 2f2:	86 e0       	ldi	r24, 0x06	; 6
 2f4:	85 bd       	out	0x25, r24	; 37
 2f6:	42 c0       	rjmp	.+132    	; 0x37c <flowMeter+0x122>
		
	}
	else
	{
		// Now I need to compare the number of pulses I got with what I should have received
		int8_t pulse_error = desired_pulses - pulse_count;   // This will be able to handle negative numbers
 2f8:	c0 91 65 00 	lds	r28, 0x0065	; 0x800065 <desired_pulses>
 2fc:	c8 1b       	sub	r28, r24
 2fe:	dc 2f       	mov	r29, r28
		float change = (float) pulse_error * V_per_pulse * ((float) ICR1) / pump_tot_V;   // Check page 94 in notebook for correct derivation.
 300:	6c 2f       	mov	r22, r28
 302:	0c 2e       	mov	r0, r28
 304:	00 0c       	add	r0, r0
 306:	77 0b       	sbc	r23, r23
 308:	88 0b       	sbc	r24, r24
 30a:	99 0b       	sbc	r25, r25
 30c:	0e 94 d0 05 	call	0xba0	; 0xba0 <__floatsisf>
 310:	24 ee       	ldi	r18, 0xE4	; 228
 312:	33 ef       	ldi	r19, 0xF3	; 243
 314:	4f e2       	ldi	r20, 0x2F	; 47
 316:	5c e3       	ldi	r21, 0x3C	; 60
 318:	0e 94 85 06 	call	0xd0a	; 0xd0a <__mulsf3>
 31c:	6b 01       	movw	r12, r22
 31e:	7c 01       	movw	r14, r24
 320:	66 b5       	in	r22, 0x26	; 38
 322:	77 b5       	in	r23, 0x27	; 39
 324:	80 e0       	ldi	r24, 0x00	; 0
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
 32c:	9b 01       	movw	r18, r22
 32e:	ac 01       	movw	r20, r24
 330:	c7 01       	movw	r24, r14
 332:	b6 01       	movw	r22, r12
 334:	0e 94 85 06 	call	0xd0a	; 0xd0a <__mulsf3>
 338:	20 e0       	ldi	r18, 0x00	; 0
 33a:	30 e0       	ldi	r19, 0x00	; 0
 33c:	40 ec       	ldi	r20, 0xC0	; 192
 33e:	50 e4       	ldi	r21, 0x40	; 64
 340:	0e 94 26 05 	call	0xa4c	; 0xa4c <__divsf3>
		OCR1B -= (uint16_t) change;   
 344:	08 b5       	in	r16, 0x28	; 40
 346:	19 b5       	in	r17, 0x29	; 41
 348:	0e 94 9f 05 	call	0xb3e	; 0xb3e <__fixunssfsi>
 34c:	06 1b       	sub	r16, r22
 34e:	17 0b       	sbc	r17, r23
 350:	19 bd       	out	0x29, r17	; 41
 352:	08 bd       	out	0x28, r16	; 40
		// The above line should immediately change the PWM as well
		
		if (pulse_error < 0)
 354:	cc 23       	and	r28, r28
 356:	0c f4       	brge	.+2      	; 0x35a <flowMeter+0x100>
			pulse_error = -pulse_error;          // Make it the absolute value 
 358:	d1 95       	neg	r29
		if (pulse_error <= pulse_error_allow)    // mission is a success
 35a:	8d 2f       	mov	r24, r29
 35c:	dd 0f       	add	r29, r29
 35e:	99 0b       	sbc	r25, r25
 360:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <_edata>
 364:	30 e0       	ldi	r19, 0x00	; 0
 366:	28 17       	cp	r18, r24
 368:	39 07       	cpc	r19, r25
 36a:	24 f0       	brlt	.+8      	; 0x374 <flowMeter+0x11a>
			PORTD |= (1 << Fuel_LED);            // Make the fuel LED just stay on
 36c:	82 b3       	in	r24, 0x12	; 18
 36e:	80 64       	ori	r24, 0x40	; 64
 370:	82 bb       	out	0x12, r24	; 18
 372:	04 c0       	rjmp	.+8      	; 0x37c <flowMeter+0x122>
		else
			PORTD ^= (1 << Fuel_LED);            // Make the fuel LED blink saying that it is not done yet.
 374:	92 b3       	in	r25, 0x12	; 18
 376:	80 e4       	ldi	r24, 0x40	; 64
 378:	89 27       	eor	r24, r25
 37a:	82 bb       	out	0x12, r24	; 18
	
	}
}
 37c:	df 91       	pop	r29
 37e:	cf 91       	pop	r28
 380:	1f 91       	pop	r17
 382:	0f 91       	pop	r16
 384:	ff 90       	pop	r15
 386:	ef 90       	pop	r14
 388:	df 90       	pop	r13
 38a:	cf 90       	pop	r12
 38c:	08 95       	ret

0000038e <ECU_toggle>:
 *  @param[in] ECU_mode This variable denote which mode the system is configured in. 0 for dummy ECU, 1 for operational ECU
 *  @return void
 */
void ECU_toggle(uint8_t ECU_mode)
{
	assign_bit(&PORTA, ECUon_Pin, ECU_mode);   // make sure the ECU has its power circuit closed if it is an operational ECU
 38e:	48 2f       	mov	r20, r24
 390:	67 e0       	ldi	r22, 0x07	; 7
 392:	8b e3       	ldi	r24, 0x3B	; 59
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 39a:	08 95       	ret

0000039c <change_timers>:
 *  @param void
 *  @return void
 *  @see flowMeter
 */
void change_timers(void)
{
 39c:	cf 93       	push	r28
 39e:	df 93       	push	r29
	opMode = 1;                          // Change the operational mode
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
	assign_bit(&PORTB,Warm_LED,1);    // Turn on the LED to signal the heating sequence is complete
 3a6:	41 e0       	ldi	r20, 0x01	; 1
 3a8:	61 e0       	ldi	r22, 0x01	; 1
 3aa:	88 e3       	ldi	r24, 0x38	; 56
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	ECU_toggle(ECU_present);
 3b2:	80 e0       	ldi	r24, 0x00	; 0
 3b4:	0e 94 c7 01 	call	0x38e	; 0x38e <ECU_toggle>
	// Now need to assign timer 2 to the alive LED
	
	if (!ECU_present)
	{
		// First change Timer 1 to serve as the PWM output port for the pump
		assign_bit(&TIMSK,TOIE1,0);    // remove overflow interrupts for timer 1
 3b8:	40 e0       	ldi	r20, 0x00	; 0
 3ba:	62 e0       	ldi	r22, 0x02	; 2
 3bc:	89 e5       	ldi	r24, 0x59	; 89
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCCR1A |= (1 << WGM11);     // The sets one of the bits for the mode 14 waveform
 3c4:	8f b5       	in	r24, 0x2f	; 47
 3c6:	82 60       	ori	r24, 0x02	; 2
 3c8:	8f bd       	out	0x2f, r24	; 47
		TCCR1B |= (1 << WGM12) | (1 << WGM13);   // This sets the other two bits for the waveform generation
 3ca:	8e b5       	in	r24, 0x2e	; 46
 3cc:	88 61       	ori	r24, 0x18	; 24
 3ce:	8e bd       	out	0x2e, r24	; 46
		TCCR1A |= (1 << COM1B1) | (1 << COM1B0);   // These set the output mode
 3d0:	8f b5       	in	r24, 0x2f	; 47
 3d2:	80 63       	ori	r24, 0x30	; 48
 3d4:	8f bd       	out	0x2f, r24	; 47
		ICR1 = 20000;     // this will set the period of oscillation to 20ms
 3d6:	80 e2       	ldi	r24, 0x20	; 32
 3d8:	9e e4       	ldi	r25, 0x4E	; 78
 3da:	97 bd       	out	0x27, r25	; 39
 3dc:	86 bd       	out	0x26, r24	; 38
			
		OCR1B = ICR1 - (int)(ICR1*duty_cycle);     // This will set the count at which the PWM will change to on. Also make sure to round down to int
 3de:	c6 b5       	in	r28, 0x26	; 38
 3e0:	d7 b5       	in	r29, 0x27	; 39
 3e2:	66 b5       	in	r22, 0x26	; 38
 3e4:	77 b5       	in	r23, 0x27	; 39
 3e6:	80 e0       	ldi	r24, 0x00	; 0
 3e8:	90 e0       	ldi	r25, 0x00	; 0
 3ea:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
 3ee:	20 91 66 00 	lds	r18, 0x0066	; 0x800066 <duty_cycle>
 3f2:	30 91 67 00 	lds	r19, 0x0067	; 0x800067 <duty_cycle+0x1>
 3f6:	40 91 68 00 	lds	r20, 0x0068	; 0x800068 <duty_cycle+0x2>
 3fa:	50 91 69 00 	lds	r21, 0x0069	; 0x800069 <duty_cycle+0x3>
 3fe:	0e 94 85 06 	call	0xd0a	; 0xd0a <__mulsf3>
 402:	0e 94 98 05 	call	0xb30	; 0xb30 <__fixsfsi>
 406:	c6 1b       	sub	r28, r22
 408:	d7 0b       	sbc	r29, r23
 40a:	d9 bd       	out	0x29, r29	; 41
 40c:	c8 bd       	out	0x28, r28	; 40
		assign_bit(&TCCR1B, CS10, 1);              // This should start the PWM with a prescalar of 1
 40e:	41 e0       	ldi	r20, 0x01	; 1
 410:	60 e0       	ldi	r22, 0x00	; 0
 412:	8e e4       	ldi	r24, 0x4E	; 78
 414:	90 e0       	ldi	r25, 0x00	; 0
 416:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		// Now the PWM should be running
			
		// Second change Timer0 to serve as the counter for the pulse train from the flow meter
		TCCR0 = 0;                                 // Turn off the PWM so the ECU stops being warmed
 41a:	13 be       	out	0x33, r1	; 51
		assign_bit(&TCCR0,CS02,0);
 41c:	40 e0       	ldi	r20, 0x00	; 0
 41e:	62 e0       	ldi	r22, 0x02	; 2
 420:	83 e5       	ldi	r24, 0x53	; 83
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS01,0);
 428:	40 e0       	ldi	r20, 0x00	; 0
 42a:	61 e0       	ldi	r22, 0x01	; 1
 42c:	83 e5       	ldi	r24, 0x53	; 83
 42e:	90 e0       	ldi	r25, 0x00	; 0
 430:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS00,0);                 // TThis will make sure that the timer is stopped for now	
 434:	40 e0       	ldi	r20, 0x00	; 0
 436:	60 e0       	ldi	r22, 0x00	; 0
 438:	83 e5       	ldi	r24, 0x53	; 83
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		// Third set the MCU Control and Status Register for the Interrupt Sense Control 2
		MCUCSR |= (1 << ISC2);                    // This will make interrupts occur on the rising edge, so the beginning of the pulse
 440:	84 b7       	in	r24, 0x34	; 52
 442:	80 64       	ori	r24, 0x40	; 64
 444:	84 bf       	out	0x34, r24	; 52
		
		// Fourth set Timer2 for the 0.75/0.25 second blink of the Alive LED
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
 446:	41 e0       	ldi	r20, 0x01	; 1
 448:	65 e0       	ldi	r22, 0x05	; 5
 44a:	82 e3       	ldi	r24, 0x32	; 50
 44c:	90 e0       	ldi	r25, 0x00	; 0
 44e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TIMSK |= (1 << TOIE2);                    // Enable overflow interrupts on the timer
 452:	89 b7       	in	r24, 0x39	; 57
 454:	80 64       	ori	r24, 0x40	; 64
 456:	89 bf       	out	0x39, r24	; 57
		TCNT2 = 11;                               // This is the value needed for the timer to run for 0.25 seconds
 458:	8b e0       	ldi	r24, 0x0B	; 11
 45a:	84 bd       	out	0x24, r24	; 36
		alive_counter = 0;                        // Reset the hand made prescalar
 45c:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <alive_counter>
		TCCR2 = 0x07;                             // Start the timer with a prescalar of 1024
 460:	87 e0       	ldi	r24, 0x07	; 7
 462:	85 bd       	out	0x25, r24	; 37
		TCCR1B = 0;         // This set is to prevent any unexpected triggering of the heating circuits
		TCCR1A = 0;
		
		
	}
}
 464:	df 91       	pop	r29
 466:	cf 91       	pop	r28
 468:	08 95       	ret

0000046a <tempHeaterHelper>:
 *  @return void
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
 46a:	cf 92       	push	r12
 46c:	df 92       	push	r13
 46e:	ef 92       	push	r14
 470:	ff 92       	push	r15
 472:	cf 93       	push	r28
	for (uint8_t i = 0; i < 6; i++)
 474:	c0 e0       	ldi	r28, 0x00	; 0
 476:	5d c1       	rjmp	.+698    	; 0x732 <tempHeaterHelper+0x2c8>
	{
		switch(i){
 478:	c2 30       	cpi	r28, 0x02	; 2
 47a:	09 f4       	brne	.+2      	; 0x47e <tempHeaterHelper+0x14>
 47c:	6f c0       	rjmp	.+222    	; 0x55c <tempHeaterHelper+0xf2>
 47e:	28 f4       	brcc	.+10     	; 0x48a <tempHeaterHelper+0x20>
 480:	cc 23       	and	r28, r28
 482:	61 f0       	breq	.+24     	; 0x49c <tempHeaterHelper+0x32>
 484:	c1 30       	cpi	r28, 0x01	; 1
 486:	d1 f1       	breq	.+116    	; 0x4fc <tempHeaterHelper+0x92>
 488:	53 c1       	rjmp	.+678    	; 0x730 <tempHeaterHelper+0x2c6>
 48a:	c4 30       	cpi	r28, 0x04	; 4
 48c:	09 f4       	brne	.+2      	; 0x490 <tempHeaterHelper+0x26>
 48e:	dc c0       	rjmp	.+440    	; 0x648 <tempHeaterHelper+0x1de>
 490:	08 f4       	brcc	.+2      	; 0x494 <tempHeaterHelper+0x2a>
 492:	aa c0       	rjmp	.+340    	; 0x5e8 <tempHeaterHelper+0x17e>
 494:	c5 30       	cpi	r28, 0x05	; 5
 496:	09 f4       	brne	.+2      	; 0x49a <tempHeaterHelper+0x30>
 498:	1d c1       	rjmp	.+570    	; 0x6d4 <tempHeaterHelper+0x26a>
 49a:	4a c1       	rjmp	.+660    	; 0x730 <tempHeaterHelper+0x2c6>
			case 0:                             // This is the case for the Lipo batteries   //////////////////////////////////////////////
				if (saveTemps[0] > TempBat )    // safety first so make sure that the temperature always turns off if one of the batteries is getting too hot
 49c:	c0 90 6a 00 	lds	r12, 0x006A	; 0x80006a <saveTemps>
 4a0:	d0 90 6b 00 	lds	r13, 0x006B	; 0x80006b <saveTemps+0x1>
 4a4:	e0 90 6c 00 	lds	r14, 0x006C	; 0x80006c <saveTemps+0x2>
 4a8:	f0 90 6d 00 	lds	r15, 0x006D	; 0x80006d <saveTemps+0x3>
 4ac:	20 e0       	ldi	r18, 0x00	; 0
 4ae:	30 e0       	ldi	r19, 0x00	; 0
 4b0:	40 e2       	ldi	r20, 0x20	; 32
 4b2:	51 e4       	ldi	r21, 0x41	; 65
 4b4:	c7 01       	movw	r24, r14
 4b6:	b6 01       	movw	r22, r12
 4b8:	0e 94 80 06 	call	0xd00	; 0xd00 <__gesf2>
 4bc:	18 16       	cp	r1, r24
 4be:	64 f4       	brge	.+24     	; 0x4d8 <tempHeaterHelper+0x6e>
				{
					desired_temp |= 0x01;
 4c0:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 4c4:	81 60       	ori	r24, 0x01	; 1
 4c6:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <desired_temp>
					assign_bit(&PORTD, BatPin, 0);       // Turn the heater off if either of these get too high
 4ca:	40 e0       	ldi	r20, 0x00	; 0
 4cc:	60 e0       	ldi	r22, 0x00	; 0
 4ce:	82 e3       	ldi	r24, 0x32	; 50
 4d0:	90 e0       	ldi	r25, 0x00	; 0
 4d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 4d6:	2c c1       	rjmp	.+600    	; 0x730 <tempHeaterHelper+0x2c6>
				}
				else if(saveTemps[0] < TempBat)
 4d8:	20 e0       	ldi	r18, 0x00	; 0
 4da:	30 e0       	ldi	r19, 0x00	; 0
 4dc:	40 e2       	ldi	r20, 0x20	; 32
 4de:	51 e4       	ldi	r21, 0x41	; 65
 4e0:	c7 01       	movw	r24, r14
 4e2:	b6 01       	movw	r22, r12
 4e4:	0e 94 21 05 	call	0xa42	; 0xa42 <__cmpsf2>
 4e8:	88 23       	and	r24, r24
 4ea:	0c f0       	brlt	.+2      	; 0x4ee <tempHeaterHelper+0x84>
 4ec:	21 c1       	rjmp	.+578    	; 0x730 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, BatPin, 1);    // Turn the heater back on to warm them up
 4ee:	41 e0       	ldi	r20, 0x01	; 1
 4f0:	60 e0       	ldi	r22, 0x00	; 0
 4f2:	82 e3       	ldi	r24, 0x32	; 50
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 4fa:	1a c1       	rjmp	.+564    	; 0x730 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 1:       // This is the case for the Hopper    /////////////////////////////////////////////////
				if (saveTemps[2] < TempHopper)           // Temp is too low so turn on the heater
 4fc:	c0 90 72 00 	lds	r12, 0x0072	; 0x800072 <saveTemps+0x8>
 500:	d0 90 73 00 	lds	r13, 0x0073	; 0x800073 <saveTemps+0x9>
 504:	e0 90 74 00 	lds	r14, 0x0074	; 0x800074 <saveTemps+0xa>
 508:	f0 90 75 00 	lds	r15, 0x0075	; 0x800075 <saveTemps+0xb>
 50c:	20 e0       	ldi	r18, 0x00	; 0
 50e:	30 e0       	ldi	r19, 0x00	; 0
 510:	40 e2       	ldi	r20, 0x20	; 32
 512:	51 e4       	ldi	r21, 0x41	; 65
 514:	c7 01       	movw	r24, r14
 516:	b6 01       	movw	r22, r12
 518:	0e 94 21 05 	call	0xa42	; 0xa42 <__cmpsf2>
 51c:	88 23       	and	r24, r24
 51e:	3c f4       	brge	.+14     	; 0x52e <tempHeaterHelper+0xc4>
					assign_bit(&PORTD, HopperPin, 1);
 520:	41 e0       	ldi	r20, 0x01	; 1
 522:	61 e0       	ldi	r22, 0x01	; 1
 524:	82 e3       	ldi	r24, 0x32	; 50
 526:	90 e0       	ldi	r25, 0x00	; 0
 528:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 52c:	01 c1       	rjmp	.+514    	; 0x730 <tempHeaterHelper+0x2c6>
				else if(saveTemps[2] > TempHopper)
 52e:	20 e0       	ldi	r18, 0x00	; 0
 530:	30 e0       	ldi	r19, 0x00	; 0
 532:	40 e2       	ldi	r20, 0x20	; 32
 534:	51 e4       	ldi	r21, 0x41	; 65
 536:	c7 01       	movw	r24, r14
 538:	b6 01       	movw	r22, r12
 53a:	0e 94 80 06 	call	0xd00	; 0xd00 <__gesf2>
 53e:	18 16       	cp	r1, r24
 540:	0c f0       	brlt	.+2      	; 0x544 <tempHeaterHelper+0xda>
 542:	f6 c0       	rjmp	.+492    	; 0x730 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, HopperPin, 0);    // Too hot so turn off
 544:	40 e0       	ldi	r20, 0x00	; 0
 546:	61 e0       	ldi	r22, 0x01	; 1
 548:	82 e3       	ldi	r24, 0x32	; 50
 54a:	90 e0       	ldi	r25, 0x00	; 0
 54c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x02;				
 550:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 554:	82 60       	ori	r24, 0x02	; 2
 556:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <desired_temp>
 55a:	ea c0       	rjmp	.+468    	; 0x730 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 2:       // This is the case for the ECU  /////////////////////////////////////////////////
				if (saveTemps[3] < TempECU)
 55c:	c0 90 76 00 	lds	r12, 0x0076	; 0x800076 <saveTemps+0xc>
 560:	d0 90 77 00 	lds	r13, 0x0077	; 0x800077 <saveTemps+0xd>
 564:	e0 90 78 00 	lds	r14, 0x0078	; 0x800078 <saveTemps+0xe>
 568:	f0 90 79 00 	lds	r15, 0x0079	; 0x800079 <saveTemps+0xf>
 56c:	20 e0       	ldi	r18, 0x00	; 0
 56e:	30 e0       	ldi	r19, 0x00	; 0
 570:	40 e2       	ldi	r20, 0x20	; 32
 572:	51 e4       	ldi	r21, 0x41	; 65
 574:	c7 01       	movw	r24, r14
 576:	b6 01       	movw	r22, r12
 578:	0e 94 21 05 	call	0xa42	; 0xa42 <__cmpsf2>
 57c:	88 23       	and	r24, r24
 57e:	94 f4       	brge	.+36     	; 0x5a4 <tempHeaterHelper+0x13a>
					if (!opMode)
 580:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 584:	81 11       	cpse	r24, r1
 586:	07 c0       	rjmp	.+14     	; 0x596 <tempHeaterHelper+0x12c>
						assign_bit(&TCCR0, CS02, 1);      // This will turn the PWM back on
 588:	41 e0       	ldi	r20, 0x01	; 1
 58a:	62 e0       	ldi	r22, 0x02	; 2
 58c:	83 e5       	ldi	r24, 0x53	; 83
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 594:	cd c0       	rjmp	.+410    	; 0x730 <tempHeaterHelper+0x2c6>
					else
						assign_bit(&PORTB, ECU_pin, 1);   // Turn the heater on manually
 596:	41 e0       	ldi	r20, 0x01	; 1
 598:	63 e0       	ldi	r22, 0x03	; 3
 59a:	88 e3       	ldi	r24, 0x38	; 56
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 5a2:	c6 c0       	rjmp	.+396    	; 0x730 <tempHeaterHelper+0x2c6>
				else if (saveTemps[3] > TempECU)
 5a4:	20 e0       	ldi	r18, 0x00	; 0
 5a6:	30 e0       	ldi	r19, 0x00	; 0
 5a8:	40 e2       	ldi	r20, 0x20	; 32
 5aa:	51 e4       	ldi	r21, 0x41	; 65
 5ac:	c7 01       	movw	r24, r14
 5ae:	b6 01       	movw	r22, r12
 5b0:	0e 94 80 06 	call	0xd00	; 0xd00 <__gesf2>
 5b4:	18 16       	cp	r1, r24
 5b6:	0c f0       	brlt	.+2      	; 0x5ba <tempHeaterHelper+0x150>
 5b8:	bb c0       	rjmp	.+374    	; 0x730 <tempHeaterHelper+0x2c6>
				{
					if (!opMode)
 5ba:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 5be:	81 11       	cpse	r24, r1
 5c0:	0c c0       	rjmp	.+24     	; 0x5da <tempHeaterHelper+0x170>
					{
						assign_bit(&TCCR0, CS02, 0);      // This will turn the PWM off
 5c2:	40 e0       	ldi	r20, 0x00	; 0
 5c4:	62 e0       	ldi	r22, 0x02	; 2
 5c6:	83 e5       	ldi	r24, 0x53	; 83
 5c8:	90 e0       	ldi	r25, 0x00	; 0
 5ca:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x04;
 5ce:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 5d2:	84 60       	ori	r24, 0x04	; 4
 5d4:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <desired_temp>
 5d8:	ab c0       	rjmp	.+342    	; 0x730 <tempHeaterHelper+0x2c6>
					}
					else
						assign_bit(&PORTB, ECU_pin, 0);   // Turn the heater off manually.  Don't do the same thing with desired_temp for the manual mode
 5da:	40 e0       	ldi	r20, 0x00	; 0
 5dc:	63 e0       	ldi	r22, 0x03	; 3
 5de:	88 e3       	ldi	r24, 0x38	; 56
 5e0:	90 e0       	ldi	r25, 0x00	; 0
 5e2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 5e6:	a4 c0       	rjmp	.+328    	; 0x730 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 3:       // This is the case for Fuel Line 1  /////////////////////////////////////////////////
				if (saveTemps[4] < TempFLine1)
 5e8:	c0 90 7a 00 	lds	r12, 0x007A	; 0x80007a <saveTemps+0x10>
 5ec:	d0 90 7b 00 	lds	r13, 0x007B	; 0x80007b <saveTemps+0x11>
 5f0:	e0 90 7c 00 	lds	r14, 0x007C	; 0x80007c <saveTemps+0x12>
 5f4:	f0 90 7d 00 	lds	r15, 0x007D	; 0x80007d <saveTemps+0x13>
 5f8:	20 e0       	ldi	r18, 0x00	; 0
 5fa:	30 e0       	ldi	r19, 0x00	; 0
 5fc:	40 e2       	ldi	r20, 0x20	; 32
 5fe:	51 e4       	ldi	r21, 0x41	; 65
 600:	c7 01       	movw	r24, r14
 602:	b6 01       	movw	r22, r12
 604:	0e 94 21 05 	call	0xa42	; 0xa42 <__cmpsf2>
 608:	88 23       	and	r24, r24
 60a:	3c f4       	brge	.+14     	; 0x61a <tempHeaterHelper+0x1b0>
					assign_bit(&PORTD, FLine1Pin, 1);
 60c:	41 e0       	ldi	r20, 0x01	; 1
 60e:	62 e0       	ldi	r22, 0x02	; 2
 610:	82 e3       	ldi	r24, 0x32	; 50
 612:	90 e0       	ldi	r25, 0x00	; 0
 614:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 618:	8b c0       	rjmp	.+278    	; 0x730 <tempHeaterHelper+0x2c6>
				else if(saveTemps[4] > TempFLine1)
 61a:	20 e0       	ldi	r18, 0x00	; 0
 61c:	30 e0       	ldi	r19, 0x00	; 0
 61e:	40 e2       	ldi	r20, 0x20	; 32
 620:	51 e4       	ldi	r21, 0x41	; 65
 622:	c7 01       	movw	r24, r14
 624:	b6 01       	movw	r22, r12
 626:	0e 94 80 06 	call	0xd00	; 0xd00 <__gesf2>
 62a:	18 16       	cp	r1, r24
 62c:	0c f0       	brlt	.+2      	; 0x630 <tempHeaterHelper+0x1c6>
 62e:	80 c0       	rjmp	.+256    	; 0x730 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, FLine1Pin, 0);
 630:	40 e0       	ldi	r20, 0x00	; 0
 632:	62 e0       	ldi	r22, 0x02	; 2
 634:	82 e3       	ldi	r24, 0x32	; 50
 636:	90 e0       	ldi	r25, 0x00	; 0
 638:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x08;
 63c:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 640:	88 60       	ori	r24, 0x08	; 8
 642:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <desired_temp>
 646:	74 c0       	rjmp	.+232    	; 0x730 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 4:       // This is the case for Fuel Line 2 /////////////////////////////////////////////////
				if (saveTemps[5] < TempFLine2){
 648:	c0 90 7e 00 	lds	r12, 0x007E	; 0x80007e <saveTemps+0x14>
 64c:	d0 90 7f 00 	lds	r13, 0x007F	; 0x80007f <saveTemps+0x15>
 650:	e0 90 80 00 	lds	r14, 0x0080	; 0x800080 <saveTemps+0x16>
 654:	f0 90 81 00 	lds	r15, 0x0081	; 0x800081 <saveTemps+0x17>
 658:	20 e0       	ldi	r18, 0x00	; 0
 65a:	30 e0       	ldi	r19, 0x00	; 0
 65c:	40 e2       	ldi	r20, 0x20	; 32
 65e:	51 e4       	ldi	r21, 0x41	; 65
 660:	c7 01       	movw	r24, r14
 662:	b6 01       	movw	r22, r12
 664:	0e 94 21 05 	call	0xa42	; 0xa42 <__cmpsf2>
 668:	88 23       	and	r24, r24
 66a:	94 f4       	brge	.+36     	; 0x690 <tempHeaterHelper+0x226>
					if (!opMode)      // We are in the warming mode so this can use the PWM
 66c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 670:	81 11       	cpse	r24, r1
 672:	07 c0       	rjmp	.+14     	; 0x682 <tempHeaterHelper+0x218>
						assign_bit(&TCCR2, CS22, 1);          // Turn the PWM back on 
 674:	41 e0       	ldi	r20, 0x01	; 1
 676:	62 e0       	ldi	r22, 0x02	; 2
 678:	85 e4       	ldi	r24, 0x45	; 69
 67a:	90 e0       	ldi	r25, 0x00	; 0
 67c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 680:	57 c0       	rjmp	.+174    	; 0x730 <tempHeaterHelper+0x2c6>
					else
						assign_bit(&PORTD,Fline2Pin,1);       // Turn the heater on manually
 682:	41 e0       	ldi	r20, 0x01	; 1
 684:	67 e0       	ldi	r22, 0x07	; 7
 686:	82 e3       	ldi	r24, 0x32	; 50
 688:	90 e0       	ldi	r25, 0x00	; 0
 68a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 68e:	50 c0       	rjmp	.+160    	; 0x730 <tempHeaterHelper+0x2c6>
				}
				else if (saveTemps[5] > TempFLine2)
 690:	20 e0       	ldi	r18, 0x00	; 0
 692:	30 e0       	ldi	r19, 0x00	; 0
 694:	40 e2       	ldi	r20, 0x20	; 32
 696:	51 e4       	ldi	r21, 0x41	; 65
 698:	c7 01       	movw	r24, r14
 69a:	b6 01       	movw	r22, r12
 69c:	0e 94 80 06 	call	0xd00	; 0xd00 <__gesf2>
 6a0:	18 16       	cp	r1, r24
 6a2:	0c f0       	brlt	.+2      	; 0x6a6 <tempHeaterHelper+0x23c>
 6a4:	45 c0       	rjmp	.+138    	; 0x730 <tempHeaterHelper+0x2c6>
				{
					if (!opMode)           // We are in warming mode so this can use the PWM
 6a6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 6aa:	81 11       	cpse	r24, r1
 6ac:	0c c0       	rjmp	.+24     	; 0x6c6 <tempHeaterHelper+0x25c>
					{
						assign_bit(&TCCR2, CS22, 0);       // Turn the PWM off
 6ae:	40 e0       	ldi	r20, 0x00	; 0
 6b0:	62 e0       	ldi	r22, 0x02	; 2
 6b2:	85 e4       	ldi	r24, 0x45	; 69
 6b4:	90 e0       	ldi	r25, 0x00	; 0
 6b6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x10;
 6ba:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 6be:	80 61       	ori	r24, 0x10	; 16
 6c0:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <desired_temp>
 6c4:	35 c0       	rjmp	.+106    	; 0x730 <tempHeaterHelper+0x2c6>
					}
					else
						assign_bit(&PORTD, Fline2Pin, 0);    // Turn the heater off manually
 6c6:	40 e0       	ldi	r20, 0x00	; 0
 6c8:	67 e0       	ldi	r22, 0x07	; 7
 6ca:	82 e3       	ldi	r24, 0x32	; 50
 6cc:	90 e0       	ldi	r25, 0x00	; 0
 6ce:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 6d2:	2e c0       	rjmp	.+92     	; 0x730 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 5:       // This is the case for the ESB    /////////////////////////////////////////////////
				if (saveTemps[5] < TempESB)
 6d4:	c0 90 7e 00 	lds	r12, 0x007E	; 0x80007e <saveTemps+0x14>
 6d8:	d0 90 7f 00 	lds	r13, 0x007F	; 0x80007f <saveTemps+0x15>
 6dc:	e0 90 80 00 	lds	r14, 0x0080	; 0x800080 <saveTemps+0x16>
 6e0:	f0 90 81 00 	lds	r15, 0x0081	; 0x800081 <saveTemps+0x17>
 6e4:	20 e0       	ldi	r18, 0x00	; 0
 6e6:	30 e0       	ldi	r19, 0x00	; 0
 6e8:	40 e2       	ldi	r20, 0x20	; 32
 6ea:	51 e4       	ldi	r21, 0x41	; 65
 6ec:	c7 01       	movw	r24, r14
 6ee:	b6 01       	movw	r22, r12
 6f0:	0e 94 21 05 	call	0xa42	; 0xa42 <__cmpsf2>
 6f4:	88 23       	and	r24, r24
 6f6:	3c f4       	brge	.+14     	; 0x706 <tempHeaterHelper+0x29c>
					assign_bit(&PORTD, ESB_Pin, 1);
 6f8:	41 e0       	ldi	r20, 0x01	; 1
 6fa:	63 e0       	ldi	r22, 0x03	; 3
 6fc:	82 e3       	ldi	r24, 0x32	; 50
 6fe:	90 e0       	ldi	r25, 0x00	; 0
 700:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 704:	15 c0       	rjmp	.+42     	; 0x730 <tempHeaterHelper+0x2c6>
				else if(saveTemps[5] > TempESB)
 706:	20 e0       	ldi	r18, 0x00	; 0
 708:	30 e0       	ldi	r19, 0x00	; 0
 70a:	40 e2       	ldi	r20, 0x20	; 32
 70c:	51 e4       	ldi	r21, 0x41	; 65
 70e:	c7 01       	movw	r24, r14
 710:	b6 01       	movw	r22, r12
 712:	0e 94 80 06 	call	0xd00	; 0xd00 <__gesf2>
 716:	18 16       	cp	r1, r24
 718:	5c f4       	brge	.+22     	; 0x730 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, ESB_Pin, 0);
 71a:	40 e0       	ldi	r20, 0x00	; 0
 71c:	63 e0       	ldi	r22, 0x03	; 3
 71e:	82 e3       	ldi	r24, 0x32	; 50
 720:	90 e0       	ldi	r25, 0x00	; 0
 722:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x20;
 726:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 72a:	80 62       	ori	r24, 0x20	; 32
 72c:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <desired_temp>
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
	for (uint8_t i = 0; i < 6; i++)
 730:	cf 5f       	subi	r28, 0xFF	; 255
 732:	c6 30       	cpi	r28, 0x06	; 6
 734:	08 f4       	brcc	.+2      	; 0x738 <tempHeaterHelper+0x2ce>
 736:	a0 ce       	rjmp	.-704    	; 0x478 <tempHeaterHelper+0xe>
				break;
		}
		
	}
	
	if (desired_temp == 0x3F)      // Will go in here every time after it stops being mode 0
 738:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <desired_temp>
 73c:	8f 33       	cpi	r24, 0x3F	; 63
 73e:	31 f4       	brne	.+12     	; 0x74c <tempHeaterHelper+0x2e2>
		/* If desired_temp was 0111 1111, it would go to 1111 1111 with the or.
		*   Then the bitwise not (~) would make it 0000 0000.  And finally,
		*   the logical not (!) would make it 0000 0001 and it would go into the if statement.
		*   If desired_temp is anything but this, it will not go in here 
		*/
		if (!opMode)    // only do this if it has never gone in here before
 740:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 744:	81 11       	cpse	r24, r1
 746:	02 c0       	rjmp	.+4      	; 0x74c <tempHeaterHelper+0x2e2>
			change_timers();                     // New initialization routine which will change the prescalars and such for the timers which will be serving different purposes
 748:	0e 94 ce 01 	call	0x39c	; 0x39c <change_timers>
	}
}
 74c:	cf 91       	pop	r28
 74e:	ff 90       	pop	r15
 750:	ef 90       	pop	r14
 752:	df 90       	pop	r13
 754:	cf 90       	pop	r12
 756:	08 95       	ret

00000758 <tempConversion>:
 *  @param void
 *  @return void
 *  @see tempHeaterHelper
 */
void tempConversion(void)
{
 758:	1f 93       	push	r17
 75a:	cf 93       	push	r28
 75c:	df 93       	push	r29
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
 75e:	40 e0       	ldi	r20, 0x00	; 0
 760:	60 e0       	ldi	r22, 0x00	; 0
 762:	87 e2       	ldi	r24, 0x27	; 39
 764:	90 e0       	ldi	r25, 0x00	; 0
 766:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX1,0);
 76a:	40 e0       	ldi	r20, 0x00	; 0
 76c:	61 e0       	ldi	r22, 0x01	; 1
 76e:	87 e2       	ldi	r24, 0x27	; 39
 770:	90 e0       	ldi	r25, 0x00	; 0
 772:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX2,0);
 776:	40 e0       	ldi	r20, 0x00	; 0
 778:	62 e0       	ldi	r22, 0x02	; 2
 77a:	87 e2       	ldi	r24, 0x27	; 39
 77c:	90 e0       	ldi	r25, 0x00	; 0
 77e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	for (unsigned char i = 0; i < 6; i++)
 782:	10 e0       	ldi	r17, 0x00	; 0
 784:	53 c0       	rjmp	.+166    	; 0x82c <tempConversion+0xd4>
	{
		ADCSRA |= 1 << ADSC;                             // Start the conversion
 786:	86 b1       	in	r24, 0x06	; 6
 788:	80 64       	ori	r24, 0x40	; 64
 78a:	86 b9       	out	0x06, r24	; 6
		while (!((1 << ADIF) & ADCSRA));
 78c:	34 9b       	sbis	0x06, 4	; 6
 78e:	fe cf       	rjmp	.-4      	; 0x78c <tempConversion+0x34>
		
		while (bit_is_clear(ADCSRA, ADIF));				 // Hog execution until the ADC is done converting
 790:	34 9b       	sbis	0x06, 4	; 6
 792:	fe cf       	rjmp	.-4      	; 0x790 <tempConversion+0x38>

		// Save this as a float for the respective variable
		uint8_t low_bits = ADCL;
 794:	84 b1       	in	r24, 0x04	; 4
		uint8_t high_bits = ADCH;						 // Do the shifting so that there is room made inside of the 16 bit register
 796:	65 b1       	in	r22, 0x05	; 5
		uint16_t result = (high_bits << 8) | low_bits;
 798:	70 e0       	ldi	r23, 0x00	; 0
 79a:	76 2f       	mov	r23, r22
 79c:	66 27       	eor	r22, r22
 79e:	68 2b       	or	r22, r24
		
		// Now I need to convert this 16 bit number into an actual temperature
		
		float act_temp = (float)(0.0048828125*result);   // This dumb thing converts it to a voltage
 7a0:	80 e0       	ldi	r24, 0x00	; 0
 7a2:	90 e0       	ldi	r25, 0x00	; 0
 7a4:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__floatunsisf>
 7a8:	20 e0       	ldi	r18, 0x00	; 0
 7aa:	30 e0       	ldi	r19, 0x00	; 0
 7ac:	40 ea       	ldi	r20, 0xA0	; 160
 7ae:	5b e3       	ldi	r21, 0x3B	; 59
 7b0:	0e 94 85 06 	call	0xd0a	; 0xd0a <__mulsf3>
		act_temp = act_temp*208.8 - 79.6;
 7b4:	2d ec       	ldi	r18, 0xCD	; 205
 7b6:	3c ec       	ldi	r19, 0xCC	; 204
 7b8:	40 e5       	ldi	r20, 0x50	; 80
 7ba:	53 e4       	ldi	r21, 0x43	; 67
 7bc:	0e 94 85 06 	call	0xd0a	; 0xd0a <__mulsf3>
 7c0:	23 e3       	ldi	r18, 0x33	; 51
 7c2:	33 e3       	ldi	r19, 0x33	; 51
 7c4:	4f e9       	ldi	r20, 0x9F	; 159
 7c6:	52 e4       	ldi	r21, 0x42	; 66
 7c8:	0e 94 b4 04 	call	0x968	; 0x968 <__subsf3>
		saveTemps[i] = act_temp;
 7cc:	c1 2f       	mov	r28, r17
 7ce:	d0 e0       	ldi	r29, 0x00	; 0
 7d0:	fe 01       	movw	r30, r28
 7d2:	ee 0f       	add	r30, r30
 7d4:	ff 1f       	adc	r31, r31
 7d6:	ee 0f       	add	r30, r30
 7d8:	ff 1f       	adc	r31, r31
 7da:	e6 59       	subi	r30, 0x96	; 150
 7dc:	ff 4f       	sbci	r31, 0xFF	; 255
 7de:	60 83       	st	Z, r22
 7e0:	71 83       	std	Z+1, r23	; 0x01
 7e2:	82 83       	std	Z+2, r24	; 0x02
 7e4:	93 83       	std	Z+3, r25	; 0x03
		
		// Now update the channel the ADC is using
		assign_bit(&ADMUX,MUX0,(i + 1) & 0x01);           // Assign bit 0
 7e6:	1f 5f       	subi	r17, 0xFF	; 255
 7e8:	41 2f       	mov	r20, r17
 7ea:	41 70       	andi	r20, 0x01	; 1
 7ec:	60 e0       	ldi	r22, 0x00	; 0
 7ee:	87 e2       	ldi	r24, 0x27	; 39
 7f0:	90 e0       	ldi	r25, 0x00	; 0
 7f2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX1,((i + 1) >> 1) & 0x01);    // Assign bit 1
 7f6:	21 96       	adiw	r28, 0x01	; 1
 7f8:	ae 01       	movw	r20, r28
 7fa:	55 95       	asr	r21
 7fc:	47 95       	ror	r20
 7fe:	41 70       	andi	r20, 0x01	; 1
 800:	61 e0       	ldi	r22, 0x01	; 1
 802:	87 e2       	ldi	r24, 0x27	; 39
 804:	90 e0       	ldi	r25, 0x00	; 0
 806:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
 80a:	d5 95       	asr	r29
 80c:	c7 95       	ror	r28
 80e:	d5 95       	asr	r29
 810:	c7 95       	ror	r28
 812:	4c 2f       	mov	r20, r28
 814:	41 70       	andi	r20, 0x01	; 1
 816:	62 e0       	ldi	r22, 0x02	; 2
 818:	87 e2       	ldi	r24, 0x27	; 39
 81a:	90 e0       	ldi	r25, 0x00	; 0
 81c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet
 820:	41 e0       	ldi	r20, 0x01	; 1
 822:	64 e0       	ldi	r22, 0x04	; 4
 824:	86 e2       	ldi	r24, 0x26	; 38
 826:	90 e0       	ldi	r25, 0x00	; 0
 828:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
	assign_bit(&ADMUX,MUX1,0);
	assign_bit(&ADMUX,MUX2,0);
	
	for (unsigned char i = 0; i < 6; i++)
 82c:	16 30       	cpi	r17, 0x06	; 6
 82e:	08 f4       	brcc	.+2      	; 0x832 <tempConversion+0xda>
 830:	aa cf       	rjmp	.-172    	; 0x786 <tempConversion+0x2e>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet

	}
	tempHeaterHelper();             // Call the helper function.  This will serve the added bonus of killing some time so that if capacitors need to charge for the next conversion, it has the time here.  Data sheet didn't say that it needed this though.
 832:	0e 94 35 02 	call	0x46a	; 0x46a <tempHeaterHelper>
	if (opMode != 1)
 836:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 83a:	81 30       	cpi	r24, 0x01	; 1
 83c:	31 f0       	breq	.+12     	; 0x84a <tempConversion+0xf2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 83e:	83 e2       	ldi	r24, 0x23	; 35
 840:	94 ef       	ldi	r25, 0xF4	; 244
 842:	01 97       	sbiw	r24, 0x01	; 1
 844:	f1 f7       	brne	.-4      	; 0x842 <tempConversion+0xea>
 846:	00 c0       	rjmp	.+0      	; 0x848 <tempConversion+0xf0>
 848:	00 00       	nop
		_delay_ms(250);                 // Delay for 1/4 of a second.   This will only impact modes 0 and 2
	
}
 84a:	df 91       	pop	r29
 84c:	cf 91       	pop	r28
 84e:	1f 91       	pop	r17
 850:	08 95       	ret

00000852 <__vector_3>:
 *  @param[in] pulse_count This is the number which describes how many pulses have been received for the sampling period.  It is an implicit argument as it is a global variable which is not explicitly passed in.
 *  @return void
 *  @see flowMeter
 */
ISR(INT2_vect)
{
 852:	1f 92       	push	r1
 854:	0f 92       	push	r0
 856:	0f b6       	in	r0, 0x3f	; 63
 858:	0f 92       	push	r0
 85a:	11 24       	eor	r1, r1
 85c:	8f 93       	push	r24
	pulse_count++;  // The interrupt flag will automatically be cleared by hardware
 85e:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <pulse_count>
 862:	8f 5f       	subi	r24, 0xFF	; 255
 864:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <pulse_count>
}
 868:	8f 91       	pop	r24
 86a:	0f 90       	pop	r0
 86c:	0f be       	out	0x3f, r0	; 63
 86e:	0f 90       	pop	r0
 870:	1f 90       	pop	r1
 872:	18 95       	reti

00000874 <__vector_5>:
 *
 *  @param[in] alive_counter Variable to act as a custom prescalar for the timer
 *  @return void
 */
ISR(TIMER2_OVF_vect)
{
 874:	1f 92       	push	r1
 876:	0f 92       	push	r0
 878:	0f b6       	in	r0, 0x3f	; 63
 87a:	0f 92       	push	r0
 87c:	11 24       	eor	r1, r1
 87e:	2f 93       	push	r18
 880:	3f 93       	push	r19
 882:	4f 93       	push	r20
 884:	5f 93       	push	r21
 886:	6f 93       	push	r22
 888:	7f 93       	push	r23
 88a:	8f 93       	push	r24
 88c:	9f 93       	push	r25
 88e:	af 93       	push	r26
 890:	bf 93       	push	r27
 892:	ef 93       	push	r30
 894:	ff 93       	push	r31
	if (opMode == 1)     // Operation mode 1 so do 0.75 sec on and 0.25 sec off
 896:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 89a:	81 30       	cpi	r24, 0x01	; 1
 89c:	29 f5       	brne	.+74     	; 0x8e8 <__vector_5+0x74>
	{
		if (alive_counter == 2)
 89e:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <alive_counter>
 8a2:	82 30       	cpi	r24, 0x02	; 2
 8a4:	71 f4       	brne	.+28     	; 0x8c2 <__vector_5+0x4e>
		{
			assign_bit(&PORTD, Alive_LED, 0);        // Turn the LED off since it is at the end of the 0.75 sec portion
 8a6:	40 e0       	ldi	r20, 0x00	; 0
 8a8:	65 e0       	ldi	r22, 0x05	; 5
 8aa:	82 e3       	ldi	r24, 0x32	; 50
 8ac:	90 e0       	ldi	r25, 0x00	; 0
 8ae:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
 8b2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <alive_counter>
 8b6:	8f 5f       	subi	r24, 0xFF	; 255
 8b8:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <alive_counter>
			TCNT2 = 11;
 8bc:	8b e0       	ldi	r24, 0x0B	; 11
 8be:	84 bd       	out	0x24, r24	; 36
 8c0:	37 c0       	rjmp	.+110    	; 0x930 <__vector_5+0xbc>
		}
		else if (alive_counter == 3)
 8c2:	83 30       	cpi	r24, 0x03	; 3
 8c4:	59 f4       	brne	.+22     	; 0x8dc <__vector_5+0x68>
		{
			assign_bit(&PORTD, Alive_LED, 1);        // Turn the LED back on since it is about to begin the 0.75 second portion
 8c6:	41 e0       	ldi	r20, 0x01	; 1
 8c8:	65 e0       	ldi	r22, 0x05	; 5
 8ca:	82 e3       	ldi	r24, 0x32	; 50
 8cc:	90 e0       	ldi	r25, 0x00	; 0
 8ce:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
 8d2:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <alive_counter>
			TCNT2 = 11;                              // Assign the correct value into the Timer register so that it goes for 0.25 sec
 8d6:	8b e0       	ldi	r24, 0x0B	; 11
 8d8:	84 bd       	out	0x24, r24	; 36
 8da:	2a c0       	rjmp	.+84     	; 0x930 <__vector_5+0xbc>
		}
		else                                         // This section is for if it is in the middle of the 0.75 sec portion
		{
			alive_counter++;
 8dc:	8f 5f       	subi	r24, 0xFF	; 255
 8de:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <alive_counter>
			TCNT2 = 11;
 8e2:	8b e0       	ldi	r24, 0x0B	; 11
 8e4:	84 bd       	out	0x24, r24	; 36
 8e6:	24 c0       	rjmp	.+72     	; 0x930 <__vector_5+0xbc>
		}
	}
	else   // I am in operation mode 2 so I need to do 0.1 sec on 0.9 sec off
	{
		if (alive_counter == 1)
 8e8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <alive_counter>
 8ec:	81 30       	cpi	r24, 0x01	; 1
 8ee:	71 f4       	brne	.+28     	; 0x90c <__vector_5+0x98>
		{
			assign_bit(&PORTD, Alive_LED, 0);            // Turn off the LED since we are at the end of the 0.1 sec period
 8f0:	40 e0       	ldi	r20, 0x00	; 0
 8f2:	65 e0       	ldi	r22, 0x05	; 5
 8f4:	82 e3       	ldi	r24, 0x32	; 50
 8f6:	90 e0       	ldi	r25, 0x00	; 0
 8f8:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
 8fc:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <alive_counter>
 900:	8f 5f       	subi	r24, 0xFF	; 255
 902:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <alive_counter>
			TCNT2 = 60;
 906:	8c e3       	ldi	r24, 0x3C	; 60
 908:	84 bd       	out	0x24, r24	; 36
 90a:	12 c0       	rjmp	.+36     	; 0x930 <__vector_5+0xbc>
		}
		else if (alive_counter == 19)
 90c:	83 31       	cpi	r24, 0x13	; 19
 90e:	59 f4       	brne	.+22     	; 0x926 <__vector_5+0xb2>
		{
			assign_bit(&PORTD, Alive_LED, 1);            // Turn on the LED since we are at the end of the 0.9 sec period
 910:	41 e0       	ldi	r20, 0x01	; 1
 912:	65 e0       	ldi	r22, 0x05	; 5
 914:	82 e3       	ldi	r24, 0x32	; 50
 916:	90 e0       	ldi	r25, 0x00	; 0
 918:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
 91c:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <alive_counter>
			TCNT2 = 60;
 920:	8c e3       	ldi	r24, 0x3C	; 60
 922:	84 bd       	out	0x24, r24	; 36
 924:	05 c0       	rjmp	.+10     	; 0x930 <__vector_5+0xbc>

		}
		else
		{
			alive_counter++;                             // At one of the intermediate points so just keep the LED how it is
 926:	8f 5f       	subi	r24, 0xFF	; 255
 928:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <alive_counter>
			TCNT2 = 60; 
 92c:	8c e3       	ldi	r24, 0x3C	; 60
 92e:	84 bd       	out	0x24, r24	; 36
		}
	}
}
 930:	ff 91       	pop	r31
 932:	ef 91       	pop	r30
 934:	bf 91       	pop	r27
 936:	af 91       	pop	r26
 938:	9f 91       	pop	r25
 93a:	8f 91       	pop	r24
 93c:	7f 91       	pop	r23
 93e:	6f 91       	pop	r22
 940:	5f 91       	pop	r21
 942:	4f 91       	pop	r20
 944:	3f 91       	pop	r19
 946:	2f 91       	pop	r18
 948:	0f 90       	pop	r0
 94a:	0f be       	out	0x3f, r0	; 63
 94c:	0f 90       	pop	r0
 94e:	1f 90       	pop	r1
 950:	18 95       	reti

00000952 <main>:
 */ 
#include "HCU_Funcs.h"

int main(void)
{
    Initial();
 952:	0e 94 79 00 	call	0xf2	; 0xf2 <Initial>
    while (1) 
    {
		tempConversion();
 956:	0e 94 ac 03 	call	0x758	; 0x758 <tempConversion>
		if (!ECU_present && (opMode == 1))    // Will only go in here if the ECU is not present and in pumping mode
 95a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 95e:	81 30       	cpi	r24, 0x01	; 1
 960:	d1 f7       	brne	.-12     	; 0x956 <main+0x4>
			flowMeter();
 962:	0e 94 2d 01 	call	0x25a	; 0x25a <flowMeter>
 966:	f7 cf       	rjmp	.-18     	; 0x956 <main+0x4>

00000968 <__subsf3>:
 968:	50 58       	subi	r21, 0x80	; 128

0000096a <__addsf3>:
 96a:	bb 27       	eor	r27, r27
 96c:	aa 27       	eor	r26, r26
 96e:	0e 94 cc 04 	call	0x998	; 0x998 <__addsf3x>
 972:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <__fp_round>
 976:	0e 94 38 06 	call	0xc70	; 0xc70 <__fp_pscA>
 97a:	38 f0       	brcs	.+14     	; 0x98a <__addsf3+0x20>
 97c:	0e 94 3f 06 	call	0xc7e	; 0xc7e <__fp_pscB>
 980:	20 f0       	brcs	.+8      	; 0x98a <__addsf3+0x20>
 982:	39 f4       	brne	.+14     	; 0x992 <__addsf3+0x28>
 984:	9f 3f       	cpi	r25, 0xFF	; 255
 986:	19 f4       	brne	.+6      	; 0x98e <__addsf3+0x24>
 988:	26 f4       	brtc	.+8      	; 0x992 <__addsf3+0x28>
 98a:	0c 94 35 06 	jmp	0xc6a	; 0xc6a <__fp_nan>
 98e:	0e f4       	brtc	.+2      	; 0x992 <__addsf3+0x28>
 990:	e0 95       	com	r30
 992:	e7 fb       	bst	r30, 7
 994:	0c 94 2f 06 	jmp	0xc5e	; 0xc5e <__fp_inf>

00000998 <__addsf3x>:
 998:	e9 2f       	mov	r30, r25
 99a:	0e 94 57 06 	call	0xcae	; 0xcae <__fp_split3>
 99e:	58 f3       	brcs	.-42     	; 0x976 <__addsf3+0xc>
 9a0:	ba 17       	cp	r27, r26
 9a2:	62 07       	cpc	r22, r18
 9a4:	73 07       	cpc	r23, r19
 9a6:	84 07       	cpc	r24, r20
 9a8:	95 07       	cpc	r25, r21
 9aa:	20 f0       	brcs	.+8      	; 0x9b4 <__addsf3x+0x1c>
 9ac:	79 f4       	brne	.+30     	; 0x9cc <__addsf3x+0x34>
 9ae:	a6 f5       	brtc	.+104    	; 0xa18 <__addsf3x+0x80>
 9b0:	0c 94 79 06 	jmp	0xcf2	; 0xcf2 <__fp_zero>
 9b4:	0e f4       	brtc	.+2      	; 0x9b8 <__addsf3x+0x20>
 9b6:	e0 95       	com	r30
 9b8:	0b 2e       	mov	r0, r27
 9ba:	ba 2f       	mov	r27, r26
 9bc:	a0 2d       	mov	r26, r0
 9be:	0b 01       	movw	r0, r22
 9c0:	b9 01       	movw	r22, r18
 9c2:	90 01       	movw	r18, r0
 9c4:	0c 01       	movw	r0, r24
 9c6:	ca 01       	movw	r24, r20
 9c8:	a0 01       	movw	r20, r0
 9ca:	11 24       	eor	r1, r1
 9cc:	ff 27       	eor	r31, r31
 9ce:	59 1b       	sub	r21, r25
 9d0:	99 f0       	breq	.+38     	; 0x9f8 <__addsf3x+0x60>
 9d2:	59 3f       	cpi	r21, 0xF9	; 249
 9d4:	50 f4       	brcc	.+20     	; 0x9ea <__addsf3x+0x52>
 9d6:	50 3e       	cpi	r21, 0xE0	; 224
 9d8:	68 f1       	brcs	.+90     	; 0xa34 <__addsf3x+0x9c>
 9da:	1a 16       	cp	r1, r26
 9dc:	f0 40       	sbci	r31, 0x00	; 0
 9de:	a2 2f       	mov	r26, r18
 9e0:	23 2f       	mov	r18, r19
 9e2:	34 2f       	mov	r19, r20
 9e4:	44 27       	eor	r20, r20
 9e6:	58 5f       	subi	r21, 0xF8	; 248
 9e8:	f3 cf       	rjmp	.-26     	; 0x9d0 <__addsf3x+0x38>
 9ea:	46 95       	lsr	r20
 9ec:	37 95       	ror	r19
 9ee:	27 95       	ror	r18
 9f0:	a7 95       	ror	r26
 9f2:	f0 40       	sbci	r31, 0x00	; 0
 9f4:	53 95       	inc	r21
 9f6:	c9 f7       	brne	.-14     	; 0x9ea <__addsf3x+0x52>
 9f8:	7e f4       	brtc	.+30     	; 0xa18 <__addsf3x+0x80>
 9fa:	1f 16       	cp	r1, r31
 9fc:	ba 0b       	sbc	r27, r26
 9fe:	62 0b       	sbc	r22, r18
 a00:	73 0b       	sbc	r23, r19
 a02:	84 0b       	sbc	r24, r20
 a04:	ba f0       	brmi	.+46     	; 0xa34 <__addsf3x+0x9c>
 a06:	91 50       	subi	r25, 0x01	; 1
 a08:	a1 f0       	breq	.+40     	; 0xa32 <__addsf3x+0x9a>
 a0a:	ff 0f       	add	r31, r31
 a0c:	bb 1f       	adc	r27, r27
 a0e:	66 1f       	adc	r22, r22
 a10:	77 1f       	adc	r23, r23
 a12:	88 1f       	adc	r24, r24
 a14:	c2 f7       	brpl	.-16     	; 0xa06 <__addsf3x+0x6e>
 a16:	0e c0       	rjmp	.+28     	; 0xa34 <__addsf3x+0x9c>
 a18:	ba 0f       	add	r27, r26
 a1a:	62 1f       	adc	r22, r18
 a1c:	73 1f       	adc	r23, r19
 a1e:	84 1f       	adc	r24, r20
 a20:	48 f4       	brcc	.+18     	; 0xa34 <__addsf3x+0x9c>
 a22:	87 95       	ror	r24
 a24:	77 95       	ror	r23
 a26:	67 95       	ror	r22
 a28:	b7 95       	ror	r27
 a2a:	f7 95       	ror	r31
 a2c:	9e 3f       	cpi	r25, 0xFE	; 254
 a2e:	08 f0       	brcs	.+2      	; 0xa32 <__addsf3x+0x9a>
 a30:	b0 cf       	rjmp	.-160    	; 0x992 <__addsf3+0x28>
 a32:	93 95       	inc	r25
 a34:	88 0f       	add	r24, r24
 a36:	08 f0       	brcs	.+2      	; 0xa3a <__addsf3x+0xa2>
 a38:	99 27       	eor	r25, r25
 a3a:	ee 0f       	add	r30, r30
 a3c:	97 95       	ror	r25
 a3e:	87 95       	ror	r24
 a40:	08 95       	ret

00000a42 <__cmpsf2>:
 a42:	0e 94 0b 06 	call	0xc16	; 0xc16 <__fp_cmp>
 a46:	08 f4       	brcc	.+2      	; 0xa4a <__cmpsf2+0x8>
 a48:	81 e0       	ldi	r24, 0x01	; 1
 a4a:	08 95       	ret

00000a4c <__divsf3>:
 a4c:	0e 94 3a 05 	call	0xa74	; 0xa74 <__divsf3x>
 a50:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <__fp_round>
 a54:	0e 94 3f 06 	call	0xc7e	; 0xc7e <__fp_pscB>
 a58:	58 f0       	brcs	.+22     	; 0xa70 <__divsf3+0x24>
 a5a:	0e 94 38 06 	call	0xc70	; 0xc70 <__fp_pscA>
 a5e:	40 f0       	brcs	.+16     	; 0xa70 <__divsf3+0x24>
 a60:	29 f4       	brne	.+10     	; 0xa6c <__divsf3+0x20>
 a62:	5f 3f       	cpi	r21, 0xFF	; 255
 a64:	29 f0       	breq	.+10     	; 0xa70 <__divsf3+0x24>
 a66:	0c 94 2f 06 	jmp	0xc5e	; 0xc5e <__fp_inf>
 a6a:	51 11       	cpse	r21, r1
 a6c:	0c 94 7a 06 	jmp	0xcf4	; 0xcf4 <__fp_szero>
 a70:	0c 94 35 06 	jmp	0xc6a	; 0xc6a <__fp_nan>

00000a74 <__divsf3x>:
 a74:	0e 94 57 06 	call	0xcae	; 0xcae <__fp_split3>
 a78:	68 f3       	brcs	.-38     	; 0xa54 <__divsf3+0x8>

00000a7a <__divsf3_pse>:
 a7a:	99 23       	and	r25, r25
 a7c:	b1 f3       	breq	.-20     	; 0xa6a <__divsf3+0x1e>
 a7e:	55 23       	and	r21, r21
 a80:	91 f3       	breq	.-28     	; 0xa66 <__divsf3+0x1a>
 a82:	95 1b       	sub	r25, r21
 a84:	55 0b       	sbc	r21, r21
 a86:	bb 27       	eor	r27, r27
 a88:	aa 27       	eor	r26, r26
 a8a:	62 17       	cp	r22, r18
 a8c:	73 07       	cpc	r23, r19
 a8e:	84 07       	cpc	r24, r20
 a90:	38 f0       	brcs	.+14     	; 0xaa0 <__divsf3_pse+0x26>
 a92:	9f 5f       	subi	r25, 0xFF	; 255
 a94:	5f 4f       	sbci	r21, 0xFF	; 255
 a96:	22 0f       	add	r18, r18
 a98:	33 1f       	adc	r19, r19
 a9a:	44 1f       	adc	r20, r20
 a9c:	aa 1f       	adc	r26, r26
 a9e:	a9 f3       	breq	.-22     	; 0xa8a <__divsf3_pse+0x10>
 aa0:	35 d0       	rcall	.+106    	; 0xb0c <__divsf3_pse+0x92>
 aa2:	0e 2e       	mov	r0, r30
 aa4:	3a f0       	brmi	.+14     	; 0xab4 <__divsf3_pse+0x3a>
 aa6:	e0 e8       	ldi	r30, 0x80	; 128
 aa8:	32 d0       	rcall	.+100    	; 0xb0e <__divsf3_pse+0x94>
 aaa:	91 50       	subi	r25, 0x01	; 1
 aac:	50 40       	sbci	r21, 0x00	; 0
 aae:	e6 95       	lsr	r30
 ab0:	00 1c       	adc	r0, r0
 ab2:	ca f7       	brpl	.-14     	; 0xaa6 <__divsf3_pse+0x2c>
 ab4:	2b d0       	rcall	.+86     	; 0xb0c <__divsf3_pse+0x92>
 ab6:	fe 2f       	mov	r31, r30
 ab8:	29 d0       	rcall	.+82     	; 0xb0c <__divsf3_pse+0x92>
 aba:	66 0f       	add	r22, r22
 abc:	77 1f       	adc	r23, r23
 abe:	88 1f       	adc	r24, r24
 ac0:	bb 1f       	adc	r27, r27
 ac2:	26 17       	cp	r18, r22
 ac4:	37 07       	cpc	r19, r23
 ac6:	48 07       	cpc	r20, r24
 ac8:	ab 07       	cpc	r26, r27
 aca:	b0 e8       	ldi	r27, 0x80	; 128
 acc:	09 f0       	breq	.+2      	; 0xad0 <__divsf3_pse+0x56>
 ace:	bb 0b       	sbc	r27, r27
 ad0:	80 2d       	mov	r24, r0
 ad2:	bf 01       	movw	r22, r30
 ad4:	ff 27       	eor	r31, r31
 ad6:	93 58       	subi	r25, 0x83	; 131
 ad8:	5f 4f       	sbci	r21, 0xFF	; 255
 ada:	3a f0       	brmi	.+14     	; 0xaea <__divsf3_pse+0x70>
 adc:	9e 3f       	cpi	r25, 0xFE	; 254
 ade:	51 05       	cpc	r21, r1
 ae0:	78 f0       	brcs	.+30     	; 0xb00 <__divsf3_pse+0x86>
 ae2:	0c 94 2f 06 	jmp	0xc5e	; 0xc5e <__fp_inf>
 ae6:	0c 94 7a 06 	jmp	0xcf4	; 0xcf4 <__fp_szero>
 aea:	5f 3f       	cpi	r21, 0xFF	; 255
 aec:	e4 f3       	brlt	.-8      	; 0xae6 <__divsf3_pse+0x6c>
 aee:	98 3e       	cpi	r25, 0xE8	; 232
 af0:	d4 f3       	brlt	.-12     	; 0xae6 <__divsf3_pse+0x6c>
 af2:	86 95       	lsr	r24
 af4:	77 95       	ror	r23
 af6:	67 95       	ror	r22
 af8:	b7 95       	ror	r27
 afa:	f7 95       	ror	r31
 afc:	9f 5f       	subi	r25, 0xFF	; 255
 afe:	c9 f7       	brne	.-14     	; 0xaf2 <__divsf3_pse+0x78>
 b00:	88 0f       	add	r24, r24
 b02:	91 1d       	adc	r25, r1
 b04:	96 95       	lsr	r25
 b06:	87 95       	ror	r24
 b08:	97 f9       	bld	r25, 7
 b0a:	08 95       	ret
 b0c:	e1 e0       	ldi	r30, 0x01	; 1
 b0e:	66 0f       	add	r22, r22
 b10:	77 1f       	adc	r23, r23
 b12:	88 1f       	adc	r24, r24
 b14:	bb 1f       	adc	r27, r27
 b16:	62 17       	cp	r22, r18
 b18:	73 07       	cpc	r23, r19
 b1a:	84 07       	cpc	r24, r20
 b1c:	ba 07       	cpc	r27, r26
 b1e:	20 f0       	brcs	.+8      	; 0xb28 <__divsf3_pse+0xae>
 b20:	62 1b       	sub	r22, r18
 b22:	73 0b       	sbc	r23, r19
 b24:	84 0b       	sbc	r24, r20
 b26:	ba 0b       	sbc	r27, r26
 b28:	ee 1f       	adc	r30, r30
 b2a:	88 f7       	brcc	.-30     	; 0xb0e <__divsf3_pse+0x94>
 b2c:	e0 95       	com	r30
 b2e:	08 95       	ret

00000b30 <__fixsfsi>:
 b30:	0e 94 9f 05 	call	0xb3e	; 0xb3e <__fixunssfsi>
 b34:	68 94       	set
 b36:	b1 11       	cpse	r27, r1
 b38:	0c 94 7a 06 	jmp	0xcf4	; 0xcf4 <__fp_szero>
 b3c:	08 95       	ret

00000b3e <__fixunssfsi>:
 b3e:	0e 94 5f 06 	call	0xcbe	; 0xcbe <__fp_splitA>
 b42:	88 f0       	brcs	.+34     	; 0xb66 <__fixunssfsi+0x28>
 b44:	9f 57       	subi	r25, 0x7F	; 127
 b46:	98 f0       	brcs	.+38     	; 0xb6e <__fixunssfsi+0x30>
 b48:	b9 2f       	mov	r27, r25
 b4a:	99 27       	eor	r25, r25
 b4c:	b7 51       	subi	r27, 0x17	; 23
 b4e:	b0 f0       	brcs	.+44     	; 0xb7c <__fixunssfsi+0x3e>
 b50:	e1 f0       	breq	.+56     	; 0xb8a <__fixunssfsi+0x4c>
 b52:	66 0f       	add	r22, r22
 b54:	77 1f       	adc	r23, r23
 b56:	88 1f       	adc	r24, r24
 b58:	99 1f       	adc	r25, r25
 b5a:	1a f0       	brmi	.+6      	; 0xb62 <__fixunssfsi+0x24>
 b5c:	ba 95       	dec	r27
 b5e:	c9 f7       	brne	.-14     	; 0xb52 <__fixunssfsi+0x14>
 b60:	14 c0       	rjmp	.+40     	; 0xb8a <__fixunssfsi+0x4c>
 b62:	b1 30       	cpi	r27, 0x01	; 1
 b64:	91 f0       	breq	.+36     	; 0xb8a <__fixunssfsi+0x4c>
 b66:	0e 94 79 06 	call	0xcf2	; 0xcf2 <__fp_zero>
 b6a:	b1 e0       	ldi	r27, 0x01	; 1
 b6c:	08 95       	ret
 b6e:	0c 94 79 06 	jmp	0xcf2	; 0xcf2 <__fp_zero>
 b72:	67 2f       	mov	r22, r23
 b74:	78 2f       	mov	r23, r24
 b76:	88 27       	eor	r24, r24
 b78:	b8 5f       	subi	r27, 0xF8	; 248
 b7a:	39 f0       	breq	.+14     	; 0xb8a <__fixunssfsi+0x4c>
 b7c:	b9 3f       	cpi	r27, 0xF9	; 249
 b7e:	cc f3       	brlt	.-14     	; 0xb72 <__fixunssfsi+0x34>
 b80:	86 95       	lsr	r24
 b82:	77 95       	ror	r23
 b84:	67 95       	ror	r22
 b86:	b3 95       	inc	r27
 b88:	d9 f7       	brne	.-10     	; 0xb80 <__fixunssfsi+0x42>
 b8a:	3e f4       	brtc	.+14     	; 0xb9a <__fixunssfsi+0x5c>
 b8c:	90 95       	com	r25
 b8e:	80 95       	com	r24
 b90:	70 95       	com	r23
 b92:	61 95       	neg	r22
 b94:	7f 4f       	sbci	r23, 0xFF	; 255
 b96:	8f 4f       	sbci	r24, 0xFF	; 255
 b98:	9f 4f       	sbci	r25, 0xFF	; 255
 b9a:	08 95       	ret

00000b9c <__floatunsisf>:
 b9c:	e8 94       	clt
 b9e:	09 c0       	rjmp	.+18     	; 0xbb2 <__floatsisf+0x12>

00000ba0 <__floatsisf>:
 ba0:	97 fb       	bst	r25, 7
 ba2:	3e f4       	brtc	.+14     	; 0xbb2 <__floatsisf+0x12>
 ba4:	90 95       	com	r25
 ba6:	80 95       	com	r24
 ba8:	70 95       	com	r23
 baa:	61 95       	neg	r22
 bac:	7f 4f       	sbci	r23, 0xFF	; 255
 bae:	8f 4f       	sbci	r24, 0xFF	; 255
 bb0:	9f 4f       	sbci	r25, 0xFF	; 255
 bb2:	99 23       	and	r25, r25
 bb4:	a9 f0       	breq	.+42     	; 0xbe0 <__floatsisf+0x40>
 bb6:	f9 2f       	mov	r31, r25
 bb8:	96 e9       	ldi	r25, 0x96	; 150
 bba:	bb 27       	eor	r27, r27
 bbc:	93 95       	inc	r25
 bbe:	f6 95       	lsr	r31
 bc0:	87 95       	ror	r24
 bc2:	77 95       	ror	r23
 bc4:	67 95       	ror	r22
 bc6:	b7 95       	ror	r27
 bc8:	f1 11       	cpse	r31, r1
 bca:	f8 cf       	rjmp	.-16     	; 0xbbc <__floatsisf+0x1c>
 bcc:	fa f4       	brpl	.+62     	; 0xc0c <__floatsisf+0x6c>
 bce:	bb 0f       	add	r27, r27
 bd0:	11 f4       	brne	.+4      	; 0xbd6 <__floatsisf+0x36>
 bd2:	60 ff       	sbrs	r22, 0
 bd4:	1b c0       	rjmp	.+54     	; 0xc0c <__floatsisf+0x6c>
 bd6:	6f 5f       	subi	r22, 0xFF	; 255
 bd8:	7f 4f       	sbci	r23, 0xFF	; 255
 bda:	8f 4f       	sbci	r24, 0xFF	; 255
 bdc:	9f 4f       	sbci	r25, 0xFF	; 255
 bde:	16 c0       	rjmp	.+44     	; 0xc0c <__floatsisf+0x6c>
 be0:	88 23       	and	r24, r24
 be2:	11 f0       	breq	.+4      	; 0xbe8 <__floatsisf+0x48>
 be4:	96 e9       	ldi	r25, 0x96	; 150
 be6:	11 c0       	rjmp	.+34     	; 0xc0a <__floatsisf+0x6a>
 be8:	77 23       	and	r23, r23
 bea:	21 f0       	breq	.+8      	; 0xbf4 <__floatsisf+0x54>
 bec:	9e e8       	ldi	r25, 0x8E	; 142
 bee:	87 2f       	mov	r24, r23
 bf0:	76 2f       	mov	r23, r22
 bf2:	05 c0       	rjmp	.+10     	; 0xbfe <__floatsisf+0x5e>
 bf4:	66 23       	and	r22, r22
 bf6:	71 f0       	breq	.+28     	; 0xc14 <__floatsisf+0x74>
 bf8:	96 e8       	ldi	r25, 0x86	; 134
 bfa:	86 2f       	mov	r24, r22
 bfc:	70 e0       	ldi	r23, 0x00	; 0
 bfe:	60 e0       	ldi	r22, 0x00	; 0
 c00:	2a f0       	brmi	.+10     	; 0xc0c <__floatsisf+0x6c>
 c02:	9a 95       	dec	r25
 c04:	66 0f       	add	r22, r22
 c06:	77 1f       	adc	r23, r23
 c08:	88 1f       	adc	r24, r24
 c0a:	da f7       	brpl	.-10     	; 0xc02 <__floatsisf+0x62>
 c0c:	88 0f       	add	r24, r24
 c0e:	96 95       	lsr	r25
 c10:	87 95       	ror	r24
 c12:	97 f9       	bld	r25, 7
 c14:	08 95       	ret

00000c16 <__fp_cmp>:
 c16:	99 0f       	add	r25, r25
 c18:	00 08       	sbc	r0, r0
 c1a:	55 0f       	add	r21, r21
 c1c:	aa 0b       	sbc	r26, r26
 c1e:	e0 e8       	ldi	r30, 0x80	; 128
 c20:	fe ef       	ldi	r31, 0xFE	; 254
 c22:	16 16       	cp	r1, r22
 c24:	17 06       	cpc	r1, r23
 c26:	e8 07       	cpc	r30, r24
 c28:	f9 07       	cpc	r31, r25
 c2a:	c0 f0       	brcs	.+48     	; 0xc5c <__fp_cmp+0x46>
 c2c:	12 16       	cp	r1, r18
 c2e:	13 06       	cpc	r1, r19
 c30:	e4 07       	cpc	r30, r20
 c32:	f5 07       	cpc	r31, r21
 c34:	98 f0       	brcs	.+38     	; 0xc5c <__fp_cmp+0x46>
 c36:	62 1b       	sub	r22, r18
 c38:	73 0b       	sbc	r23, r19
 c3a:	84 0b       	sbc	r24, r20
 c3c:	95 0b       	sbc	r25, r21
 c3e:	39 f4       	brne	.+14     	; 0xc4e <__fp_cmp+0x38>
 c40:	0a 26       	eor	r0, r26
 c42:	61 f0       	breq	.+24     	; 0xc5c <__fp_cmp+0x46>
 c44:	23 2b       	or	r18, r19
 c46:	24 2b       	or	r18, r20
 c48:	25 2b       	or	r18, r21
 c4a:	21 f4       	brne	.+8      	; 0xc54 <__fp_cmp+0x3e>
 c4c:	08 95       	ret
 c4e:	0a 26       	eor	r0, r26
 c50:	09 f4       	brne	.+2      	; 0xc54 <__fp_cmp+0x3e>
 c52:	a1 40       	sbci	r26, 0x01	; 1
 c54:	a6 95       	lsr	r26
 c56:	8f ef       	ldi	r24, 0xFF	; 255
 c58:	81 1d       	adc	r24, r1
 c5a:	81 1d       	adc	r24, r1
 c5c:	08 95       	ret

00000c5e <__fp_inf>:
 c5e:	97 f9       	bld	r25, 7
 c60:	9f 67       	ori	r25, 0x7F	; 127
 c62:	80 e8       	ldi	r24, 0x80	; 128
 c64:	70 e0       	ldi	r23, 0x00	; 0
 c66:	60 e0       	ldi	r22, 0x00	; 0
 c68:	08 95       	ret

00000c6a <__fp_nan>:
 c6a:	9f ef       	ldi	r25, 0xFF	; 255
 c6c:	80 ec       	ldi	r24, 0xC0	; 192
 c6e:	08 95       	ret

00000c70 <__fp_pscA>:
 c70:	00 24       	eor	r0, r0
 c72:	0a 94       	dec	r0
 c74:	16 16       	cp	r1, r22
 c76:	17 06       	cpc	r1, r23
 c78:	18 06       	cpc	r1, r24
 c7a:	09 06       	cpc	r0, r25
 c7c:	08 95       	ret

00000c7e <__fp_pscB>:
 c7e:	00 24       	eor	r0, r0
 c80:	0a 94       	dec	r0
 c82:	12 16       	cp	r1, r18
 c84:	13 06       	cpc	r1, r19
 c86:	14 06       	cpc	r1, r20
 c88:	05 06       	cpc	r0, r21
 c8a:	08 95       	ret

00000c8c <__fp_round>:
 c8c:	09 2e       	mov	r0, r25
 c8e:	03 94       	inc	r0
 c90:	00 0c       	add	r0, r0
 c92:	11 f4       	brne	.+4      	; 0xc98 <__fp_round+0xc>
 c94:	88 23       	and	r24, r24
 c96:	52 f0       	brmi	.+20     	; 0xcac <__fp_round+0x20>
 c98:	bb 0f       	add	r27, r27
 c9a:	40 f4       	brcc	.+16     	; 0xcac <__fp_round+0x20>
 c9c:	bf 2b       	or	r27, r31
 c9e:	11 f4       	brne	.+4      	; 0xca4 <__fp_round+0x18>
 ca0:	60 ff       	sbrs	r22, 0
 ca2:	04 c0       	rjmp	.+8      	; 0xcac <__fp_round+0x20>
 ca4:	6f 5f       	subi	r22, 0xFF	; 255
 ca6:	7f 4f       	sbci	r23, 0xFF	; 255
 ca8:	8f 4f       	sbci	r24, 0xFF	; 255
 caa:	9f 4f       	sbci	r25, 0xFF	; 255
 cac:	08 95       	ret

00000cae <__fp_split3>:
 cae:	57 fd       	sbrc	r21, 7
 cb0:	90 58       	subi	r25, 0x80	; 128
 cb2:	44 0f       	add	r20, r20
 cb4:	55 1f       	adc	r21, r21
 cb6:	59 f0       	breq	.+22     	; 0xcce <__fp_splitA+0x10>
 cb8:	5f 3f       	cpi	r21, 0xFF	; 255
 cba:	71 f0       	breq	.+28     	; 0xcd8 <__fp_splitA+0x1a>
 cbc:	47 95       	ror	r20

00000cbe <__fp_splitA>:
 cbe:	88 0f       	add	r24, r24
 cc0:	97 fb       	bst	r25, 7
 cc2:	99 1f       	adc	r25, r25
 cc4:	61 f0       	breq	.+24     	; 0xcde <__fp_splitA+0x20>
 cc6:	9f 3f       	cpi	r25, 0xFF	; 255
 cc8:	79 f0       	breq	.+30     	; 0xce8 <__fp_splitA+0x2a>
 cca:	87 95       	ror	r24
 ccc:	08 95       	ret
 cce:	12 16       	cp	r1, r18
 cd0:	13 06       	cpc	r1, r19
 cd2:	14 06       	cpc	r1, r20
 cd4:	55 1f       	adc	r21, r21
 cd6:	f2 cf       	rjmp	.-28     	; 0xcbc <__fp_split3+0xe>
 cd8:	46 95       	lsr	r20
 cda:	f1 df       	rcall	.-30     	; 0xcbe <__fp_splitA>
 cdc:	08 c0       	rjmp	.+16     	; 0xcee <__fp_splitA+0x30>
 cde:	16 16       	cp	r1, r22
 ce0:	17 06       	cpc	r1, r23
 ce2:	18 06       	cpc	r1, r24
 ce4:	99 1f       	adc	r25, r25
 ce6:	f1 cf       	rjmp	.-30     	; 0xcca <__fp_splitA+0xc>
 ce8:	86 95       	lsr	r24
 cea:	71 05       	cpc	r23, r1
 cec:	61 05       	cpc	r22, r1
 cee:	08 94       	sec
 cf0:	08 95       	ret

00000cf2 <__fp_zero>:
 cf2:	e8 94       	clt

00000cf4 <__fp_szero>:
 cf4:	bb 27       	eor	r27, r27
 cf6:	66 27       	eor	r22, r22
 cf8:	77 27       	eor	r23, r23
 cfa:	cb 01       	movw	r24, r22
 cfc:	97 f9       	bld	r25, 7
 cfe:	08 95       	ret

00000d00 <__gesf2>:
 d00:	0e 94 0b 06 	call	0xc16	; 0xc16 <__fp_cmp>
 d04:	08 f4       	brcc	.+2      	; 0xd08 <__gesf2+0x8>
 d06:	8f ef       	ldi	r24, 0xFF	; 255
 d08:	08 95       	ret

00000d0a <__mulsf3>:
 d0a:	0e 94 98 06 	call	0xd30	; 0xd30 <__mulsf3x>
 d0e:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <__fp_round>
 d12:	0e 94 38 06 	call	0xc70	; 0xc70 <__fp_pscA>
 d16:	38 f0       	brcs	.+14     	; 0xd26 <__mulsf3+0x1c>
 d18:	0e 94 3f 06 	call	0xc7e	; 0xc7e <__fp_pscB>
 d1c:	20 f0       	brcs	.+8      	; 0xd26 <__mulsf3+0x1c>
 d1e:	95 23       	and	r25, r21
 d20:	11 f0       	breq	.+4      	; 0xd26 <__mulsf3+0x1c>
 d22:	0c 94 2f 06 	jmp	0xc5e	; 0xc5e <__fp_inf>
 d26:	0c 94 35 06 	jmp	0xc6a	; 0xc6a <__fp_nan>
 d2a:	11 24       	eor	r1, r1
 d2c:	0c 94 7a 06 	jmp	0xcf4	; 0xcf4 <__fp_szero>

00000d30 <__mulsf3x>:
 d30:	0e 94 57 06 	call	0xcae	; 0xcae <__fp_split3>
 d34:	70 f3       	brcs	.-36     	; 0xd12 <__mulsf3+0x8>

00000d36 <__mulsf3_pse>:
 d36:	95 9f       	mul	r25, r21
 d38:	c1 f3       	breq	.-16     	; 0xd2a <__mulsf3+0x20>
 d3a:	95 0f       	add	r25, r21
 d3c:	50 e0       	ldi	r21, 0x00	; 0
 d3e:	55 1f       	adc	r21, r21
 d40:	62 9f       	mul	r22, r18
 d42:	f0 01       	movw	r30, r0
 d44:	72 9f       	mul	r23, r18
 d46:	bb 27       	eor	r27, r27
 d48:	f0 0d       	add	r31, r0
 d4a:	b1 1d       	adc	r27, r1
 d4c:	63 9f       	mul	r22, r19
 d4e:	aa 27       	eor	r26, r26
 d50:	f0 0d       	add	r31, r0
 d52:	b1 1d       	adc	r27, r1
 d54:	aa 1f       	adc	r26, r26
 d56:	64 9f       	mul	r22, r20
 d58:	66 27       	eor	r22, r22
 d5a:	b0 0d       	add	r27, r0
 d5c:	a1 1d       	adc	r26, r1
 d5e:	66 1f       	adc	r22, r22
 d60:	82 9f       	mul	r24, r18
 d62:	22 27       	eor	r18, r18
 d64:	b0 0d       	add	r27, r0
 d66:	a1 1d       	adc	r26, r1
 d68:	62 1f       	adc	r22, r18
 d6a:	73 9f       	mul	r23, r19
 d6c:	b0 0d       	add	r27, r0
 d6e:	a1 1d       	adc	r26, r1
 d70:	62 1f       	adc	r22, r18
 d72:	83 9f       	mul	r24, r19
 d74:	a0 0d       	add	r26, r0
 d76:	61 1d       	adc	r22, r1
 d78:	22 1f       	adc	r18, r18
 d7a:	74 9f       	mul	r23, r20
 d7c:	33 27       	eor	r19, r19
 d7e:	a0 0d       	add	r26, r0
 d80:	61 1d       	adc	r22, r1
 d82:	23 1f       	adc	r18, r19
 d84:	84 9f       	mul	r24, r20
 d86:	60 0d       	add	r22, r0
 d88:	21 1d       	adc	r18, r1
 d8a:	82 2f       	mov	r24, r18
 d8c:	76 2f       	mov	r23, r22
 d8e:	6a 2f       	mov	r22, r26
 d90:	11 24       	eor	r1, r1
 d92:	9f 57       	subi	r25, 0x7F	; 127
 d94:	50 40       	sbci	r21, 0x00	; 0
 d96:	9a f0       	brmi	.+38     	; 0xdbe <__mulsf3_pse+0x88>
 d98:	f1 f0       	breq	.+60     	; 0xdd6 <__mulsf3_pse+0xa0>
 d9a:	88 23       	and	r24, r24
 d9c:	4a f0       	brmi	.+18     	; 0xdb0 <__mulsf3_pse+0x7a>
 d9e:	ee 0f       	add	r30, r30
 da0:	ff 1f       	adc	r31, r31
 da2:	bb 1f       	adc	r27, r27
 da4:	66 1f       	adc	r22, r22
 da6:	77 1f       	adc	r23, r23
 da8:	88 1f       	adc	r24, r24
 daa:	91 50       	subi	r25, 0x01	; 1
 dac:	50 40       	sbci	r21, 0x00	; 0
 dae:	a9 f7       	brne	.-22     	; 0xd9a <__mulsf3_pse+0x64>
 db0:	9e 3f       	cpi	r25, 0xFE	; 254
 db2:	51 05       	cpc	r21, r1
 db4:	80 f0       	brcs	.+32     	; 0xdd6 <__mulsf3_pse+0xa0>
 db6:	0c 94 2f 06 	jmp	0xc5e	; 0xc5e <__fp_inf>
 dba:	0c 94 7a 06 	jmp	0xcf4	; 0xcf4 <__fp_szero>
 dbe:	5f 3f       	cpi	r21, 0xFF	; 255
 dc0:	e4 f3       	brlt	.-8      	; 0xdba <__mulsf3_pse+0x84>
 dc2:	98 3e       	cpi	r25, 0xE8	; 232
 dc4:	d4 f3       	brlt	.-12     	; 0xdba <__mulsf3_pse+0x84>
 dc6:	86 95       	lsr	r24
 dc8:	77 95       	ror	r23
 dca:	67 95       	ror	r22
 dcc:	b7 95       	ror	r27
 dce:	f7 95       	ror	r31
 dd0:	e7 95       	ror	r30
 dd2:	9f 5f       	subi	r25, 0xFF	; 255
 dd4:	c1 f7       	brne	.-16     	; 0xdc6 <__mulsf3_pse+0x90>
 dd6:	fe 2b       	or	r31, r30
 dd8:	88 0f       	add	r24, r24
 dda:	91 1d       	adc	r25, r1
 ddc:	96 95       	lsr	r25
 dde:	87 95       	ror	r24
 de0:	97 f9       	bld	r25, 7
 de2:	08 95       	ret

00000de4 <_exit>:
 de4:	f8 94       	cli

00000de6 <__stop_program>:
 de6:	ff cf       	rjmp	.-2      	; 0xde6 <__stop_program>
