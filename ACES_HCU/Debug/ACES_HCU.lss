
ACES_HCU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d9e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000e12  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002a  00800060  00800060  00000e12  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e12  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000e44  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000e80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000011cf  00000000  00000000  00000f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000764  00000000  00000000  000020d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000082f  00000000  00000000  0000283b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000188  00000000  00000000  0000306c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000491  00000000  00000000  000031f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003e5  00000000  00000000  00003685  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  00003a6a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 04 04 	jmp	0x808	; 0x808 <__vector_3>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 15 04 	jmp	0x82a	; 0x82a <__vector_5>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__vector_9>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	aa 38       	cpi	r26, 0x8A	; 138
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 84 04 	call	0x908	; 0x908 <main>
  74:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <__vector_9>:
 *
 *  @param TIMER1_OVF_vect    The interrupt vector for the overflow of timer 1 
 *  @return Void
 */
ISR(TIMER1_OVF_vect)
{
  7c:	1f 92       	push	r1
  7e:	0f 92       	push	r0
  80:	0f b6       	in	r0, 0x3f	; 63
  82:	0f 92       	push	r0
  84:	11 24       	eor	r1, r1
  86:	8f 93       	push	r24
  88:	9f 93       	push	r25
	// The LED is on PD5
	alive_counter++;
  8a:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
  8e:	8f 5f       	subi	r24, 0xFF	; 255
  90:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
	if (alive_counter % 2 == 1)
  94:	80 ff       	sbrs	r24, 0
  96:	04 c0       	rjmp	.+8      	; 0xa0 <__vector_9+0x24>
	PORTD ^= (1 << Alive_LED);
  98:	92 b3       	in	r25, 0x12	; 18
  9a:	80 e2       	ldi	r24, 0x20	; 32
  9c:	89 27       	eor	r24, r25
  9e:	82 bb       	out	0x12, r24	; 18
		
	PORTB ^= (1 << Warm_LED);   // This will have the warming LED blink 0.5 sec on 0.5 sec off and the alive LED blinking twice as slow
  a0:	98 b3       	in	r25, 0x18	; 24
  a2:	82 e0       	ldi	r24, 0x02	; 2
  a4:	89 27       	eor	r24, r25
  a6:	88 bb       	out	0x18, r24	; 24
		
	// Now reset the register
	TCNT1 = 3036;  // The interrupt will clear automatically when this function is called
  a8:	8c ed       	ldi	r24, 0xDC	; 220
  aa:	9b e0       	ldi	r25, 0x0B	; 11
  ac:	9d bd       	out	0x2d, r25	; 45
  ae:	8c bd       	out	0x2c, r24	; 44
}
  b0:	9f 91       	pop	r25
  b2:	8f 91       	pop	r24
  b4:	0f 90       	pop	r0
  b6:	0f be       	out	0x3f, r0	; 63
  b8:	0f 90       	pop	r0
  ba:	1f 90       	pop	r1
  bc:	18 95       	reti

000000be <assign_bit>:
 *  @param[in] val The value, either 1 or 0, that the user would like the bit to be after the function call.
 *  @return void
 */
void assign_bit(volatile uint8_t *sfr,uint8_t bit, uint8_t val)
{
	if (val)      // This is for if I want the value to be a 1
  be:	44 23       	and	r20, r20
  c0:	59 f0       	breq	.+22     	; 0xd8 <assign_bit+0x1a>
	{
		val = (val << bit);
  c2:	50 e0       	ldi	r21, 0x00	; 0
  c4:	02 c0       	rjmp	.+4      	; 0xca <assign_bit+0xc>
  c6:	44 0f       	add	r20, r20
  c8:	55 1f       	adc	r21, r21
  ca:	6a 95       	dec	r22
  cc:	e2 f7       	brpl	.-8      	; 0xc6 <assign_bit+0x8>
		*sfr |= val;
  ce:	fc 01       	movw	r30, r24
  d0:	20 81       	ld	r18, Z
  d2:	42 2b       	or	r20, r18
  d4:	40 83       	st	Z, r20
  d6:	08 95       	ret
	}
	else             // This is for if I want the value to be a 0
	{
		val = ~(1 << bit);
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	02 c0       	rjmp	.+4      	; 0xe2 <assign_bit+0x24>
  de:	22 0f       	add	r18, r18
  e0:	33 1f       	adc	r19, r19
  e2:	6a 95       	dec	r22
  e4:	e2 f7       	brpl	.-8      	; 0xde <assign_bit+0x20>
  e6:	20 95       	com	r18
		*sfr &= val;
  e8:	fc 01       	movw	r30, r24
  ea:	30 81       	ld	r19, Z
  ec:	23 23       	and	r18, r19
  ee:	20 83       	st	Z, r18
  f0:	08 95       	ret

000000f2 <Initial>:
 */
void Initial(void)
{
	// First setup the port directions for the PWM lines and the
	// 0 are inputs 1 are outputs
	DDRA = 0b10000000;          // Only PA7 is an output
  f2:	80 e8       	ldi	r24, 0x80	; 128
  f4:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0b11011010;         
  f6:	8a ed       	ldi	r24, 0xDA	; 218
  f8:	87 bb       	out	0x17, r24	; 23
	DDRC = 0xFF;                // Make all outputs
  fa:	8f ef       	ldi	r24, 0xFF	; 255
  fc:	84 bb       	out	0x14, r24	; 20
	DDRD = 0xFF;                // Make all outputs
  fe:	81 bb       	out	0x11, r24	; 17
	
	opMode = 0;     // This sets the function mode to heating mode
 100:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <opMode>
	desired_temp = 0;
 104:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <desired_temp>
	duty_cycle = (pump_m*fuelFlow + pump_b) / pump_tot_V;    // This is the initial guess for the fuel pump
 108:	8e e9       	ldi	r24, 0x9E	; 158
 10a:	99 e7       	ldi	r25, 0x79	; 121
 10c:	ab eb       	ldi	r26, 0xBB	; 187
 10e:	bd e3       	ldi	r27, 0x3D	; 61
 110:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <duty_cycle>
 114:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <duty_cycle+0x1>
 118:	a0 93 70 00 	sts	0x0070, r26	; 0x800070 <duty_cycle+0x2>
 11c:	b0 93 71 00 	sts	0x0071, r27	; 0x800071 <duty_cycle+0x3>
	
	// Now calculate the number of pulses I expect per 0.262144 seconds (max time for an 8 bit timer with prescalar of 1024)
	float pulse_flow = (fuelFlow / density) * K_factor * max_time / 1000;
	V_per_pulse = pump_m * (fuelFlow / pulse_flow);
 120:	80 e6       	ldi	r24, 0x60	; 96
 122:	90 ef       	ldi	r25, 0xF0	; 240
 124:	a3 e5       	ldi	r26, 0x53	; 83
 126:	bc e3       	ldi	r27, 0x3C	; 60
 128:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <V_per_pulse>
 12c:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <V_per_pulse+0x1>
 130:	a0 93 6c 00 	sts	0x006C, r26	; 0x80006c <V_per_pulse+0x2>
 134:	b0 93 6d 00 	sts	0x006D, r27	; 0x80006d <V_per_pulse+0x3>
	desired_pulses = (uint8_t) pulse_flow;                                    // round down and convert to an 8 bit number.  I expect it to be 170 so it will fit.
 138:	8d e8       	ldi	r24, 0x8D	; 141
 13a:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <desired_pulses>
	pulse_error_allow = (uint8_t)(desired_pulses * (fuelError / fuelFlow));   // This is the amount of pulses I can be off for it to still be considered a successes
 13e:	83 e0       	ldi	r24, 0x03	; 3
 140:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	assign_bit(&MCUCSR,ISC2,1);                                               // This will cause interrupts for INT2 to be caused on the rising edge
 144:	41 e0       	ldi	r20, 0x01	; 1
 146:	66 e0       	ldi	r22, 0x06	; 6
 148:	84 e5       	ldi	r24, 0x54	; 84
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&GIFR, INTF2, 1);                                              // Make sure the interrupt flag is cleared
 150:	41 e0       	ldi	r20, 0x01	; 1
 152:	65 e0       	ldi	r22, 0x05	; 5
 154:	8a e5       	ldi	r24, 0x5A	; 90
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	
	// Configure the ADC
	ADCSRA |= 1 << ADPS2;   // This is so there is a prescalar of 16.  ADC needs frequency between 50-200kHz so 1,000,000/16 puts it in this range.
 15c:	86 b1       	in	r24, 0x06	; 6
 15e:	84 60       	ori	r24, 0x04	; 4
 160:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 1 << ADEN;    // Enable the ADC
 162:	86 b1       	in	r24, 0x06	; 6
 164:	80 68       	ori	r24, 0x80	; 128
 166:	86 b9       	out	0x06, r24	; 6
	ADMUX |= 1 << REFS0;    // Make AVCC (5V) the reference voltage
 168:	87 b1       	in	r24, 0x07	; 7
 16a:	80 64       	ori	r24, 0x40	; 64
 16c:	87 b9       	out	0x07, r24	; 7

	sei();       // This sets the global interrupt flag to allow for hardware interrupts
 16e:	78 94       	sei
	
	// Now enable the timer1 for 0.5 sec
	TIMSK |= 1 << TOIE1;                 // turn on overflow interrupts
 170:	89 b7       	in	r24, 0x39	; 57
 172:	84 60       	ori	r24, 0x04	; 4
 174:	89 bf       	out	0x39, r24	; 57
	TCCR1B |= (1<<CS11);                 // This has a prescalar of 8
 176:	8e b5       	in	r24, 0x2e	; 46
 178:	82 60       	ori	r24, 0x02	; 2
 17a:	8e bd       	out	0x2e, r24	; 46
	TCNT1 = 3036;                        // This will load the value so that when using a prescalar of 8, it will overflow after 500ms
 17c:	8c ed       	ldi	r24, 0xDC	; 220
 17e:	9b e0       	ldi	r25, 0x0B	; 11
 180:	9d bd       	out	0x2d, r25	; 45
 182:	8c bd       	out	0x2c, r24	; 44
	
	saveTemps[0] = -100.0;        // Assign initial temperature values that for sure will be colder than the specified temps 
 184:	e2 e7       	ldi	r30, 0x72	; 114
 186:	f0 e0       	ldi	r31, 0x00	; 0
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	a8 ec       	ldi	r26, 0xC8	; 200
 18e:	b2 ec       	ldi	r27, 0xC2	; 194
 190:	80 83       	st	Z, r24
 192:	91 83       	std	Z+1, r25	; 0x01
 194:	a2 83       	std	Z+2, r26	; 0x02
 196:	b3 83       	std	Z+3, r27	; 0x03
	saveTemps[1] = -100.0;
 198:	84 83       	std	Z+4, r24	; 0x04
 19a:	95 83       	std	Z+5, r25	; 0x05
 19c:	a6 83       	std	Z+6, r26	; 0x06
 19e:	b7 83       	std	Z+7, r27	; 0x07
	saveTemps[2] = -100.0;
 1a0:	80 87       	std	Z+8, r24	; 0x08
 1a2:	91 87       	std	Z+9, r25	; 0x09
 1a4:	a2 87       	std	Z+10, r26	; 0x0a
 1a6:	b3 87       	std	Z+11, r27	; 0x0b
	saveTemps[3] = -100.0;
 1a8:	84 87       	std	Z+12, r24	; 0x0c
 1aa:	95 87       	std	Z+13, r25	; 0x0d
 1ac:	a6 87       	std	Z+14, r26	; 0x0e
 1ae:	b7 87       	std	Z+15, r27	; 0x0f
	saveTemps[4] = -100.0;
 1b0:	80 8b       	std	Z+16, r24	; 0x10
 1b2:	91 8b       	std	Z+17, r25	; 0x11
 1b4:	a2 8b       	std	Z+18, r26	; 0x12
 1b6:	b3 8b       	std	Z+19, r27	; 0x13
	saveTemps[5] = -100.0;
 1b8:	84 8b       	std	Z+20, r24	; 0x14
 1ba:	95 8b       	std	Z+21, r25	; 0x15
 1bc:	a6 8b       	std	Z+22, r26	; 0x16
 1be:	b7 8b       	std	Z+23, r27	; 0x17
	saveTemps[6] = -100.0; 
 1c0:	80 8f       	std	Z+24, r24	; 0x18
 1c2:	91 8f       	std	Z+25, r25	; 0x19
 1c4:	a2 8f       	std	Z+26, r26	; 0x1a
 1c6:	b3 8f       	std	Z+27, r27	; 0x1b
	
	// Now I need to turn on all of the heaters as well as set the duty cycles for the PWMs which will be on timers 0 and 2
	// Start with the PWM for the ECU, this will be on timer0
	TCNT0 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
 1c8:	12 be       	out	0x32, r1	; 50
	assign_bit(&TCCR0, WGM01, 1);
 1ca:	41 e0       	ldi	r20, 0x01	; 1
 1cc:	63 e0       	ldi	r22, 0x03	; 3
 1ce:	83 e5       	ldi	r24, 0x53	; 83
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, WGM00, 1);      // These two set the PWM Mode to "Fast PWM"
 1d6:	41 e0       	ldi	r20, 0x01	; 1
 1d8:	66 e0       	ldi	r22, 0x06	; 6
 1da:	83 e5       	ldi	r24, 0x53	; 83
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM01, 1); 
 1e2:	41 e0       	ldi	r20, 0x01	; 1
 1e4:	65 e0       	ldi	r22, 0x05	; 5
 1e6:	83 e5       	ldi	r24, 0x53	; 83
 1e8:	90 e0       	ldi	r25, 0x00	; 0
 1ea:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM00, 1);      // These two set the PWM type to inverting PWM
 1ee:	41 e0       	ldi	r20, 0x01	; 1
 1f0:	64 e0       	ldi	r22, 0x04	; 4
 1f2:	83 e5       	ldi	r24, 0x53	; 83
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	OCR0 = 255 - (255*ECU_duty);       // This will set it to the specified duty by the #define
 1fa:	8f e7       	ldi	r24, 0x7F	; 127
 1fc:	8c bf       	out	0x3c, r24	; 60
	
	TCCR0 |= (1 << CS02);              // This will start the PWM with a duty cycle of 65.536 ms
 1fe:	83 b7       	in	r24, 0x33	; 51
 200:	84 60       	ori	r24, 0x04	; 4
 202:	83 bf       	out	0x33, r24	; 51
	
	// Now do the PWM for the second fuel line which will use Timer 2,  this will look very similar to the last few lines of code
	TCNT2 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
 204:	14 bc       	out	0x24, r1	; 36
	assign_bit(&TCCR2, WGM21, 1);
 206:	41 e0       	ldi	r20, 0x01	; 1
 208:	63 e0       	ldi	r22, 0x03	; 3
 20a:	85 e4       	ldi	r24, 0x45	; 69
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, WGM20, 1);      // These two set the PWM Mode to "Fast PWM"
 212:	41 e0       	ldi	r20, 0x01	; 1
 214:	66 e0       	ldi	r22, 0x06	; 6
 216:	85 e4       	ldi	r24, 0x45	; 69
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM21, 1);
 21e:	41 e0       	ldi	r20, 0x01	; 1
 220:	65 e0       	ldi	r22, 0x05	; 5
 222:	85 e4       	ldi	r24, 0x45	; 69
 224:	90 e0       	ldi	r25, 0x00	; 0
 226:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM20, 1);      // These two set the PWM type to inverting PWM
 22a:	41 e0       	ldi	r20, 0x01	; 1
 22c:	64 e0       	ldi	r22, 0x04	; 4
 22e:	85 e4       	ldi	r24, 0x45	; 69
 230:	90 e0       	ldi	r25, 0x00	; 0
 232:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
	OCR2 = 255 - (255*F_line_duty);    // This will set it to the specified duty by the #define
 236:	89 ec       	ldi	r24, 0xC9	; 201
 238:	83 bd       	out	0x23, r24	; 35
		
	TCCR2 |= (1 << CS22);              // This will start the PWM with a duty cycle of 65.536 ms, just like before
 23a:	85 b5       	in	r24, 0x25	; 37
 23c:	84 60       	ori	r24, 0x04	; 4
 23e:	85 bd       	out	0x25, r24	; 37
	
	// Now turn on all the other heaters
	assign_bit(&PORTD, BatPin, 1);
 240:	41 e0       	ldi	r20, 0x01	; 1
 242:	60 e0       	ldi	r22, 0x00	; 0
 244:	82 e3       	ldi	r24, 0x32	; 50
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, HopperPin, 1);
 24c:	41 e0       	ldi	r20, 0x01	; 1
 24e:	61 e0       	ldi	r22, 0x01	; 1
 250:	82 e3       	ldi	r24, 0x32	; 50
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, FLine1Pin, 1);
 258:	41 e0       	ldi	r20, 0x01	; 1
 25a:	62 e0       	ldi	r22, 0x02	; 2
 25c:	82 e3       	ldi	r24, 0x32	; 50
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, ESB_Pin, 1);     // I can omit doing this for the ECU and FuelLine1
 264:	41 e0       	ldi	r20, 0x01	; 1
 266:	63 e0       	ldi	r22, 0x03	; 3
 268:	82 e3       	ldi	r24, 0x32	; 50
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 270:	08 95       	ret

00000272 <flowMeter>:
 *  @param void
 *  @return void
 *  @note Need to do a pump test to ensure that the voltage to flow rate function is actually correct.
 */
void flowMeter(void)
{
 272:	cf 93       	push	r28
 274:	df 93       	push	r29
	//for (unsigned i = 0; i < 14; i++){
	//	_delay_ms(250);                 // this should delay for 3.5 seconds
	//}
	
	// First I need to enable interrupt on INT2
	pulse_count = 0;
 276:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <pulse_count>
	GICR |= (1 << INT2);     // enable INT2 external interrupts
 27a:	8b b7       	in	r24, 0x3b	; 59
 27c:	80 62       	ori	r24, 0x20	; 32
 27e:	8b bf       	out	0x3b, r24	; 59
	
	
	// Second I need to begin timer0
	TCNT0 = 0;                                 // Make sure the timer/counter register is cleared so the full range can be used
 280:	12 be       	out	0x32, r1	; 50
	assign_bit(&TIFR,TOV1,1);                  // Make sure the overflow flag is set
 282:	41 e0       	ldi	r20, 0x01	; 1
 284:	62 e0       	ldi	r22, 0x02	; 2
 286:	88 e5       	ldi	r24, 0x58	; 88
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS02,1);
 28e:	41 e0       	ldi	r20, 0x01	; 1
 290:	62 e0       	ldi	r22, 0x02	; 2
 292:	83 e5       	ldi	r24, 0x53	; 83
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS01,0);
 29a:	40 e0       	ldi	r20, 0x00	; 0
 29c:	61 e0       	ldi	r22, 0x01	; 1
 29e:	83 e5       	ldi	r24, 0x53	; 83
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS00,1);                 // TThis will start the timer with a prescalar of 1024
 2a6:	41 e0       	ldi	r20, 0x01	; 1
 2a8:	60 e0       	ldi	r22, 0x00	; 0
 2aa:	83 e5       	ldi	r24, 0x53	; 83
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	while (!(TIFR & 0x01));                    // Hog the execution until the overflow flag is set
 2b2:	08 b6       	in	r0, 0x38	; 56
 2b4:	00 fe       	sbrs	r0, 0
 2b6:	fd cf       	rjmp	.-6      	; 0x2b2 <flowMeter+0x40>
	
	assign_bit(&GICR, INT2, 0);                // disable external interrupts for INT2
 2b8:	40 e0       	ldi	r20, 0x00	; 0
 2ba:	65 e0       	ldi	r22, 0x05	; 5
 2bc:	8b e5       	ldi	r24, 0x5B	; 91
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
	//}
	//else
	//{
		// Now I need to compare the number of pulses I got with what I should have received
		int8_t pulse_error = desired_pulses - pulse_count;   // This will be able to handle negative numbers
 2c4:	60 91 68 00 	lds	r22, 0x0068	; 0x800068 <pulse_count>
 2c8:	c0 91 69 00 	lds	r28, 0x0069	; 0x800069 <desired_pulses>
 2cc:	c6 1b       	sub	r28, r22
 2ce:	dc 2f       	mov	r29, r28
		measured_flow = V_per_pulse * (float) pulse_count;
 2d0:	70 e0       	ldi	r23, 0x00	; 0
 2d2:	80 e0       	ldi	r24, 0x00	; 0
 2d4:	90 e0       	ldi	r25, 0x00	; 0
 2d6:	0e 94 a9 05 	call	0xb52	; 0xb52 <__floatunsisf>
 2da:	20 91 6a 00 	lds	r18, 0x006A	; 0x80006a <V_per_pulse>
 2de:	30 91 6b 00 	lds	r19, 0x006B	; 0x80006b <V_per_pulse+0x1>
 2e2:	40 91 6c 00 	lds	r20, 0x006C	; 0x80006c <V_per_pulse+0x2>
 2e6:	50 91 6d 00 	lds	r21, 0x006D	; 0x80006d <V_per_pulse+0x3>
 2ea:	0e 94 60 06 	call	0xcc0	; 0xcc0 <__mulsf3>
		measured_flow = (measured_flow - pump_b) / pump_m;
 2ee:	27 e5       	ldi	r18, 0x57	; 87
 2f0:	3b e7       	ldi	r19, 0x7B	; 123
 2f2:	48 e4       	ldi	r20, 0x48	; 72
 2f4:	5e e3       	ldi	r21, 0x3E	; 62
 2f6:	0e 94 8f 04 	call	0x91e	; 0x91e <__subsf3>
 2fa:	21 e7       	ldi	r18, 0x71	; 113
 2fc:	32 ee       	ldi	r19, 0xE2	; 226
 2fe:	43 ec       	ldi	r20, 0xC3	; 195
 300:	5e e3       	ldi	r21, 0x3E	; 62
 302:	0e 94 01 05 	call	0xa02	; 0xa02 <__divsf3>
 306:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <measured_flow>
 30a:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <measured_flow+0x1>
 30e:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <measured_flow+0x2>
 312:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <measured_flow+0x3>
		//float change = (float) pulse_error * V_per_pulse * ((float) ICR1) / pump_tot_V;   // Check page 94 in notebook for correct derivation.
		//OCR1B -= (uint16_t) change;   
		// The above line should immediately change the PWM as well
		
		if (pulse_error < 0)
 316:	cc 23       	and	r28, r28
 318:	0c f4       	brge	.+2      	; 0x31c <flowMeter+0xaa>
			pulse_error = -pulse_error;          // Make it the absolute value 
 31a:	d1 95       	neg	r29
		if (pulse_error <= pulse_error_allow)    // mission is a success
 31c:	8d 2f       	mov	r24, r29
 31e:	dd 0f       	add	r29, r29
 320:	99 0b       	sbc	r25, r25
 322:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <_edata>
 326:	30 e0       	ldi	r19, 0x00	; 0
 328:	28 17       	cp	r18, r24
 32a:	39 07       	cpc	r19, r25
 32c:	24 f0       	brlt	.+8      	; 0x336 <flowMeter+0xc4>
			PORTD |= (1 << Fuel_LED);            // Make the fuel LED just stay on
 32e:	82 b3       	in	r24, 0x12	; 18
 330:	80 64       	ori	r24, 0x40	; 64
 332:	82 bb       	out	0x12, r24	; 18
 334:	04 c0       	rjmp	.+8      	; 0x33e <flowMeter+0xcc>
		else
			PORTD ^= (1 << Fuel_LED);            // Make the fuel LED blink saying that it is not done yet.
 336:	92 b3       	in	r25, 0x12	; 18
 338:	80 e4       	ldi	r24, 0x40	; 64
 33a:	89 27       	eor	r24, r25
 33c:	82 bb       	out	0x12, r24	; 18
	//}
}
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	08 95       	ret

00000344 <ECU_toggle>:
 *  @param[in] ECU_mode This variable denote which mode the system is configured in. 0 for dummy ECU, 1 for operational ECU
 *  @return void
 */
void ECU_toggle(uint8_t ECU_mode)
{
	assign_bit(&PORTA, ECUon_Pin, ECU_mode);   // make sure the ECU has its power circuit closed if it is an operational ECU
 344:	48 2f       	mov	r20, r24
 346:	67 e0       	ldi	r22, 0x07	; 7
 348:	8b e3       	ldi	r24, 0x3B	; 59
 34a:	90 e0       	ldi	r25, 0x00	; 0
 34c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 350:	08 95       	ret

00000352 <change_timers>:
 *  @param void
 *  @return void
 *  @see flowMeter
 */
void change_timers(void)
{
 352:	cf 93       	push	r28
 354:	df 93       	push	r29
	opMode = 1;                          // Change the operational mode
 356:	81 e0       	ldi	r24, 0x01	; 1
 358:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
	assign_bit(&PORTB,Warm_LED,1);    // Turn on the LED to signal the heating sequence is complete
 35c:	41 e0       	ldi	r20, 0x01	; 1
 35e:	61 e0       	ldi	r22, 0x01	; 1
 360:	88 e3       	ldi	r24, 0x38	; 56
 362:	90 e0       	ldi	r25, 0x00	; 0
 364:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	ECU_toggle(ECU_present);
 368:	80 e0       	ldi	r24, 0x00	; 0
 36a:	0e 94 a2 01 	call	0x344	; 0x344 <ECU_toggle>
	// Now need to assign timer 2 to the alive LED
	
	if (!ECU_present)
	{
		// First change Timer 1 to serve as the PWM output port for the pump
		assign_bit(&TIMSK,TOIE1,0);    // remove overflow interrupts for timer 1
 36e:	40 e0       	ldi	r20, 0x00	; 0
 370:	62 e0       	ldi	r22, 0x02	; 2
 372:	89 e5       	ldi	r24, 0x59	; 89
 374:	90 e0       	ldi	r25, 0x00	; 0
 376:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCCR1A |= (1 << WGM11);     // The sets one of the bits for the mode 14 waveform
 37a:	8f b5       	in	r24, 0x2f	; 47
 37c:	82 60       	ori	r24, 0x02	; 2
 37e:	8f bd       	out	0x2f, r24	; 47
		TCCR1B |= (1 << WGM12) | (1 << WGM13);   // This sets the other two bits for the waveform generation
 380:	8e b5       	in	r24, 0x2e	; 46
 382:	88 61       	ori	r24, 0x18	; 24
 384:	8e bd       	out	0x2e, r24	; 46
		TCCR1A |= (1 << COM1B1) | (1 << COM1B0);   // These set the output mode
 386:	8f b5       	in	r24, 0x2f	; 47
 388:	80 63       	ori	r24, 0x30	; 48
 38a:	8f bd       	out	0x2f, r24	; 47
		ICR1 = 1500;     // this will set the period of oscillation to 20ms  this was 20000
 38c:	8c ed       	ldi	r24, 0xDC	; 220
 38e:	95 e0       	ldi	r25, 0x05	; 5
 390:	97 bd       	out	0x27, r25	; 39
 392:	86 bd       	out	0x26, r24	; 38
			
		OCR1B = ICR1 - (int)(ICR1*duty_cycle);     // This will set the count at which the PWM will change to on. Also make sure to round down to int
 394:	c6 b5       	in	r28, 0x26	; 38
 396:	d7 b5       	in	r29, 0x27	; 39
 398:	66 b5       	in	r22, 0x26	; 38
 39a:	77 b5       	in	r23, 0x27	; 39
 39c:	80 e0       	ldi	r24, 0x00	; 0
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	0e 94 a9 05 	call	0xb52	; 0xb52 <__floatunsisf>
 3a4:	20 91 6e 00 	lds	r18, 0x006E	; 0x80006e <duty_cycle>
 3a8:	30 91 6f 00 	lds	r19, 0x006F	; 0x80006f <duty_cycle+0x1>
 3ac:	40 91 70 00 	lds	r20, 0x0070	; 0x800070 <duty_cycle+0x2>
 3b0:	50 91 71 00 	lds	r21, 0x0071	; 0x800071 <duty_cycle+0x3>
 3b4:	0e 94 60 06 	call	0xcc0	; 0xcc0 <__mulsf3>
 3b8:	0e 94 73 05 	call	0xae6	; 0xae6 <__fixsfsi>
 3bc:	c6 1b       	sub	r28, r22
 3be:	d7 0b       	sbc	r29, r23
 3c0:	d9 bd       	out	0x29, r29	; 41
 3c2:	c8 bd       	out	0x28, r28	; 40
		assign_bit(&TCCR1B, CS10, 1);              // This should start the PWM with a prescalar of 1
 3c4:	41 e0       	ldi	r20, 0x01	; 1
 3c6:	60 e0       	ldi	r22, 0x00	; 0
 3c8:	8e e4       	ldi	r24, 0x4E	; 78
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		// Now the PWM should be running
			
		// Second change Timer0 to serve as the counter for the pulse train from the flow meter
		TCCR0 = 0;                                 // Turn off the PWM so the ECU stops being warmed
 3d0:	13 be       	out	0x33, r1	; 51
		assign_bit(&TCCR0,CS02,0);
 3d2:	40 e0       	ldi	r20, 0x00	; 0
 3d4:	62 e0       	ldi	r22, 0x02	; 2
 3d6:	83 e5       	ldi	r24, 0x53	; 83
 3d8:	90 e0       	ldi	r25, 0x00	; 0
 3da:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS01,0);
 3de:	40 e0       	ldi	r20, 0x00	; 0
 3e0:	61 e0       	ldi	r22, 0x01	; 1
 3e2:	83 e5       	ldi	r24, 0x53	; 83
 3e4:	90 e0       	ldi	r25, 0x00	; 0
 3e6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS00,0);                 // TThis will make sure that the timer is stopped for now	
 3ea:	40 e0       	ldi	r20, 0x00	; 0
 3ec:	60 e0       	ldi	r22, 0x00	; 0
 3ee:	83 e5       	ldi	r24, 0x53	; 83
 3f0:	90 e0       	ldi	r25, 0x00	; 0
 3f2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		// Third set the MCU Control and Status Register for the Interrupt Sense Control 2
		MCUCSR |= (1 << ISC2);                    // This will make interrupts occur on the rising edge, so the beginning of the pulse
 3f6:	84 b7       	in	r24, 0x34	; 52
 3f8:	80 64       	ori	r24, 0x40	; 64
 3fa:	84 bf       	out	0x34, r24	; 52
		
		// Fourth set Timer2 for the 0.75/0.25 second blink of the Alive LED
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
 3fc:	41 e0       	ldi	r20, 0x01	; 1
 3fe:	65 e0       	ldi	r22, 0x05	; 5
 400:	82 e3       	ldi	r24, 0x32	; 50
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TIMSK |= (1 << TOIE2);                    // Enable overflow interrupts on the timer
 408:	89 b7       	in	r24, 0x39	; 57
 40a:	80 64       	ori	r24, 0x40	; 64
 40c:	89 bf       	out	0x39, r24	; 57
		TCNT2 = 11;                               // This is the value needed for the timer to run for 0.25 seconds
 40e:	8b e0       	ldi	r24, 0x0B	; 11
 410:	84 bd       	out	0x24, r24	; 36
		alive_counter = 0;                        // Reset the hand made prescalar
 412:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
		TCCR2 = 0x07;                             // Start the timer with a prescalar of 1024
 416:	87 e0       	ldi	r24, 0x07	; 7
 418:	85 bd       	out	0x25, r24	; 37
		TCCR1B = 0;         // This set is to prevent any unexpected triggering of the heating circuits
		TCCR1A = 0;
		
		
	}
}
 41a:	df 91       	pop	r29
 41c:	cf 91       	pop	r28
 41e:	08 95       	ret

00000420 <tempHeaterHelper>:
 *  @return void
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
 420:	cf 92       	push	r12
 422:	df 92       	push	r13
 424:	ef 92       	push	r14
 426:	ff 92       	push	r15
 428:	cf 93       	push	r28
	for (uint8_t i = 0; i < 6; i++)
 42a:	c0 e0       	ldi	r28, 0x00	; 0
 42c:	5d c1       	rjmp	.+698    	; 0x6e8 <tempHeaterHelper+0x2c8>
	{
		switch(i){
 42e:	c2 30       	cpi	r28, 0x02	; 2
 430:	09 f4       	brne	.+2      	; 0x434 <tempHeaterHelper+0x14>
 432:	6f c0       	rjmp	.+222    	; 0x512 <tempHeaterHelper+0xf2>
 434:	28 f4       	brcc	.+10     	; 0x440 <tempHeaterHelper+0x20>
 436:	cc 23       	and	r28, r28
 438:	61 f0       	breq	.+24     	; 0x452 <tempHeaterHelper+0x32>
 43a:	c1 30       	cpi	r28, 0x01	; 1
 43c:	d1 f1       	breq	.+116    	; 0x4b2 <tempHeaterHelper+0x92>
 43e:	53 c1       	rjmp	.+678    	; 0x6e6 <tempHeaterHelper+0x2c6>
 440:	c4 30       	cpi	r28, 0x04	; 4
 442:	09 f4       	brne	.+2      	; 0x446 <tempHeaterHelper+0x26>
 444:	dc c0       	rjmp	.+440    	; 0x5fe <tempHeaterHelper+0x1de>
 446:	08 f4       	brcc	.+2      	; 0x44a <tempHeaterHelper+0x2a>
 448:	aa c0       	rjmp	.+340    	; 0x59e <tempHeaterHelper+0x17e>
 44a:	c5 30       	cpi	r28, 0x05	; 5
 44c:	09 f4       	brne	.+2      	; 0x450 <tempHeaterHelper+0x30>
 44e:	1d c1       	rjmp	.+570    	; 0x68a <tempHeaterHelper+0x26a>
 450:	4a c1       	rjmp	.+660    	; 0x6e6 <tempHeaterHelper+0x2c6>
			case 0:                             // This is the case for the Lipo batteries   //////////////////////////////////////////////
				if (saveTemps[0] > TempBat )    // safety first so make sure that the temperature always turns off if one of the batteries is getting too hot
 452:	c0 90 72 00 	lds	r12, 0x0072	; 0x800072 <saveTemps>
 456:	d0 90 73 00 	lds	r13, 0x0073	; 0x800073 <saveTemps+0x1>
 45a:	e0 90 74 00 	lds	r14, 0x0074	; 0x800074 <saveTemps+0x2>
 45e:	f0 90 75 00 	lds	r15, 0x0075	; 0x800075 <saveTemps+0x3>
 462:	20 e0       	ldi	r18, 0x00	; 0
 464:	30 e0       	ldi	r19, 0x00	; 0
 466:	40 e2       	ldi	r20, 0x20	; 32
 468:	51 e4       	ldi	r21, 0x41	; 65
 46a:	c7 01       	movw	r24, r14
 46c:	b6 01       	movw	r22, r12
 46e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__gesf2>
 472:	18 16       	cp	r1, r24
 474:	64 f4       	brge	.+24     	; 0x48e <tempHeaterHelper+0x6e>
				{
					desired_temp |= 0x01;
 476:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 47a:	81 60       	ori	r24, 0x01	; 1
 47c:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
					assign_bit(&PORTD, BatPin, 0);       // Turn the heater off if either of these get too high
 480:	40 e0       	ldi	r20, 0x00	; 0
 482:	60 e0       	ldi	r22, 0x00	; 0
 484:	82 e3       	ldi	r24, 0x32	; 50
 486:	90 e0       	ldi	r25, 0x00	; 0
 488:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 48c:	2c c1       	rjmp	.+600    	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				else if(saveTemps[0] < TempBat)
 48e:	20 e0       	ldi	r18, 0x00	; 0
 490:	30 e0       	ldi	r19, 0x00	; 0
 492:	40 e2       	ldi	r20, 0x20	; 32
 494:	51 e4       	ldi	r21, 0x41	; 65
 496:	c7 01       	movw	r24, r14
 498:	b6 01       	movw	r22, r12
 49a:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__cmpsf2>
 49e:	88 23       	and	r24, r24
 4a0:	0c f0       	brlt	.+2      	; 0x4a4 <tempHeaterHelper+0x84>
 4a2:	21 c1       	rjmp	.+578    	; 0x6e6 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, BatPin, 1);    // Turn the heater back on to warm them up
 4a4:	41 e0       	ldi	r20, 0x01	; 1
 4a6:	60 e0       	ldi	r22, 0x00	; 0
 4a8:	82 e3       	ldi	r24, 0x32	; 50
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 4b0:	1a c1       	rjmp	.+564    	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 1:       // This is the case for the Hopper    /////////////////////////////////////////////////
				if (saveTemps[2] < TempHopper)           // Temp is too low so turn on the heater
 4b2:	c0 90 7a 00 	lds	r12, 0x007A	; 0x80007a <saveTemps+0x8>
 4b6:	d0 90 7b 00 	lds	r13, 0x007B	; 0x80007b <saveTemps+0x9>
 4ba:	e0 90 7c 00 	lds	r14, 0x007C	; 0x80007c <saveTemps+0xa>
 4be:	f0 90 7d 00 	lds	r15, 0x007D	; 0x80007d <saveTemps+0xb>
 4c2:	20 e0       	ldi	r18, 0x00	; 0
 4c4:	30 e0       	ldi	r19, 0x00	; 0
 4c6:	40 e2       	ldi	r20, 0x20	; 32
 4c8:	51 e4       	ldi	r21, 0x41	; 65
 4ca:	c7 01       	movw	r24, r14
 4cc:	b6 01       	movw	r22, r12
 4ce:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__cmpsf2>
 4d2:	88 23       	and	r24, r24
 4d4:	3c f4       	brge	.+14     	; 0x4e4 <tempHeaterHelper+0xc4>
					assign_bit(&PORTD, HopperPin, 1);
 4d6:	41 e0       	ldi	r20, 0x01	; 1
 4d8:	61 e0       	ldi	r22, 0x01	; 1
 4da:	82 e3       	ldi	r24, 0x32	; 50
 4dc:	90 e0       	ldi	r25, 0x00	; 0
 4de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 4e2:	01 c1       	rjmp	.+514    	; 0x6e6 <tempHeaterHelper+0x2c6>
				else if(saveTemps[2] > TempHopper)
 4e4:	20 e0       	ldi	r18, 0x00	; 0
 4e6:	30 e0       	ldi	r19, 0x00	; 0
 4e8:	40 e2       	ldi	r20, 0x20	; 32
 4ea:	51 e4       	ldi	r21, 0x41	; 65
 4ec:	c7 01       	movw	r24, r14
 4ee:	b6 01       	movw	r22, r12
 4f0:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__gesf2>
 4f4:	18 16       	cp	r1, r24
 4f6:	0c f0       	brlt	.+2      	; 0x4fa <tempHeaterHelper+0xda>
 4f8:	f6 c0       	rjmp	.+492    	; 0x6e6 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, HopperPin, 0);    // Too hot so turn off
 4fa:	40 e0       	ldi	r20, 0x00	; 0
 4fc:	61 e0       	ldi	r22, 0x01	; 1
 4fe:	82 e3       	ldi	r24, 0x32	; 50
 500:	90 e0       	ldi	r25, 0x00	; 0
 502:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x02;				
 506:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 50a:	82 60       	ori	r24, 0x02	; 2
 50c:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 510:	ea c0       	rjmp	.+468    	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 2:       // This is the case for the ECU  /////////////////////////////////////////////////
				if (saveTemps[3] < TempECU)
 512:	c0 90 7e 00 	lds	r12, 0x007E	; 0x80007e <saveTemps+0xc>
 516:	d0 90 7f 00 	lds	r13, 0x007F	; 0x80007f <saveTemps+0xd>
 51a:	e0 90 80 00 	lds	r14, 0x0080	; 0x800080 <saveTemps+0xe>
 51e:	f0 90 81 00 	lds	r15, 0x0081	; 0x800081 <saveTemps+0xf>
 522:	20 e0       	ldi	r18, 0x00	; 0
 524:	30 e0       	ldi	r19, 0x00	; 0
 526:	4a e7       	ldi	r20, 0x7A	; 122
 528:	54 e4       	ldi	r21, 0x44	; 68
 52a:	c7 01       	movw	r24, r14
 52c:	b6 01       	movw	r22, r12
 52e:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__cmpsf2>
 532:	88 23       	and	r24, r24
 534:	94 f4       	brge	.+36     	; 0x55a <tempHeaterHelper+0x13a>
					if (!opMode)
 536:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 53a:	81 11       	cpse	r24, r1
 53c:	07 c0       	rjmp	.+14     	; 0x54c <tempHeaterHelper+0x12c>
						assign_bit(&TCCR0, CS02, 1);      // This will turn the PWM back on
 53e:	41 e0       	ldi	r20, 0x01	; 1
 540:	62 e0       	ldi	r22, 0x02	; 2
 542:	83 e5       	ldi	r24, 0x53	; 83
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 54a:	cd c0       	rjmp	.+410    	; 0x6e6 <tempHeaterHelper+0x2c6>
					else
						assign_bit(&PORTB, ECU_pin, 1);   // Turn the heater on manually
 54c:	41 e0       	ldi	r20, 0x01	; 1
 54e:	63 e0       	ldi	r22, 0x03	; 3
 550:	88 e3       	ldi	r24, 0x38	; 56
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 558:	c6 c0       	rjmp	.+396    	; 0x6e6 <tempHeaterHelper+0x2c6>
				else if (saveTemps[3] > TempECU)
 55a:	20 e0       	ldi	r18, 0x00	; 0
 55c:	30 e0       	ldi	r19, 0x00	; 0
 55e:	4a e7       	ldi	r20, 0x7A	; 122
 560:	54 e4       	ldi	r21, 0x44	; 68
 562:	c7 01       	movw	r24, r14
 564:	b6 01       	movw	r22, r12
 566:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__gesf2>
 56a:	18 16       	cp	r1, r24
 56c:	0c f0       	brlt	.+2      	; 0x570 <tempHeaterHelper+0x150>
 56e:	bb c0       	rjmp	.+374    	; 0x6e6 <tempHeaterHelper+0x2c6>
				{
					if (!opMode)
 570:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 574:	81 11       	cpse	r24, r1
 576:	0c c0       	rjmp	.+24     	; 0x590 <tempHeaterHelper+0x170>
					{
						assign_bit(&TCCR0, CS02, 0);      // This will turn the PWM off
 578:	40 e0       	ldi	r20, 0x00	; 0
 57a:	62 e0       	ldi	r22, 0x02	; 2
 57c:	83 e5       	ldi	r24, 0x53	; 83
 57e:	90 e0       	ldi	r25, 0x00	; 0
 580:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x04;
 584:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 588:	84 60       	ori	r24, 0x04	; 4
 58a:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 58e:	ab c0       	rjmp	.+342    	; 0x6e6 <tempHeaterHelper+0x2c6>
					}
					else
						assign_bit(&PORTB, ECU_pin, 0);   // Turn the heater off manually.  Don't do the same thing with desired_temp for the manual mode
 590:	40 e0       	ldi	r20, 0x00	; 0
 592:	63 e0       	ldi	r22, 0x03	; 3
 594:	88 e3       	ldi	r24, 0x38	; 56
 596:	90 e0       	ldi	r25, 0x00	; 0
 598:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 59c:	a4 c0       	rjmp	.+328    	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 3:       // This is the case for Fuel Line 1  /////////////////////////////////////////////////
				if (saveTemps[4] < TempFLine1)
 59e:	c0 90 82 00 	lds	r12, 0x0082	; 0x800082 <saveTemps+0x10>
 5a2:	d0 90 83 00 	lds	r13, 0x0083	; 0x800083 <saveTemps+0x11>
 5a6:	e0 90 84 00 	lds	r14, 0x0084	; 0x800084 <saveTemps+0x12>
 5aa:	f0 90 85 00 	lds	r15, 0x0085	; 0x800085 <saveTemps+0x13>
 5ae:	20 e0       	ldi	r18, 0x00	; 0
 5b0:	30 e0       	ldi	r19, 0x00	; 0
 5b2:	40 e2       	ldi	r20, 0x20	; 32
 5b4:	51 e4       	ldi	r21, 0x41	; 65
 5b6:	c7 01       	movw	r24, r14
 5b8:	b6 01       	movw	r22, r12
 5ba:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__cmpsf2>
 5be:	88 23       	and	r24, r24
 5c0:	3c f4       	brge	.+14     	; 0x5d0 <tempHeaterHelper+0x1b0>
					assign_bit(&PORTD, FLine1Pin, 1);
 5c2:	41 e0       	ldi	r20, 0x01	; 1
 5c4:	62 e0       	ldi	r22, 0x02	; 2
 5c6:	82 e3       	ldi	r24, 0x32	; 50
 5c8:	90 e0       	ldi	r25, 0x00	; 0
 5ca:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 5ce:	8b c0       	rjmp	.+278    	; 0x6e6 <tempHeaterHelper+0x2c6>
				else if(saveTemps[4] > TempFLine1)
 5d0:	20 e0       	ldi	r18, 0x00	; 0
 5d2:	30 e0       	ldi	r19, 0x00	; 0
 5d4:	40 e2       	ldi	r20, 0x20	; 32
 5d6:	51 e4       	ldi	r21, 0x41	; 65
 5d8:	c7 01       	movw	r24, r14
 5da:	b6 01       	movw	r22, r12
 5dc:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__gesf2>
 5e0:	18 16       	cp	r1, r24
 5e2:	0c f0       	brlt	.+2      	; 0x5e6 <tempHeaterHelper+0x1c6>
 5e4:	80 c0       	rjmp	.+256    	; 0x6e6 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, FLine1Pin, 0);
 5e6:	40 e0       	ldi	r20, 0x00	; 0
 5e8:	62 e0       	ldi	r22, 0x02	; 2
 5ea:	82 e3       	ldi	r24, 0x32	; 50
 5ec:	90 e0       	ldi	r25, 0x00	; 0
 5ee:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x08;
 5f2:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 5f6:	88 60       	ori	r24, 0x08	; 8
 5f8:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 5fc:	74 c0       	rjmp	.+232    	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 4:       // This is the case for Fuel Line 2 /////////////////////////////////////////////////
				if (saveTemps[5] < TempFLine2){
 5fe:	c0 90 86 00 	lds	r12, 0x0086	; 0x800086 <saveTemps+0x14>
 602:	d0 90 87 00 	lds	r13, 0x0087	; 0x800087 <saveTemps+0x15>
 606:	e0 90 88 00 	lds	r14, 0x0088	; 0x800088 <saveTemps+0x16>
 60a:	f0 90 89 00 	lds	r15, 0x0089	; 0x800089 <saveTemps+0x17>
 60e:	20 e0       	ldi	r18, 0x00	; 0
 610:	30 e0       	ldi	r19, 0x00	; 0
 612:	4a e7       	ldi	r20, 0x7A	; 122
 614:	54 e4       	ldi	r21, 0x44	; 68
 616:	c7 01       	movw	r24, r14
 618:	b6 01       	movw	r22, r12
 61a:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__cmpsf2>
 61e:	88 23       	and	r24, r24
 620:	94 f4       	brge	.+36     	; 0x646 <tempHeaterHelper+0x226>
					if (!opMode)      // We are in the warming mode so this can use the PWM
 622:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 626:	81 11       	cpse	r24, r1
 628:	07 c0       	rjmp	.+14     	; 0x638 <tempHeaterHelper+0x218>
						assign_bit(&TCCR2, CS22, 1);          // Turn the PWM back on 
 62a:	41 e0       	ldi	r20, 0x01	; 1
 62c:	62 e0       	ldi	r22, 0x02	; 2
 62e:	85 e4       	ldi	r24, 0x45	; 69
 630:	90 e0       	ldi	r25, 0x00	; 0
 632:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 636:	57 c0       	rjmp	.+174    	; 0x6e6 <tempHeaterHelper+0x2c6>
					else
						assign_bit(&PORTD,Fline2Pin,1);       // Turn the heater on manually
 638:	41 e0       	ldi	r20, 0x01	; 1
 63a:	67 e0       	ldi	r22, 0x07	; 7
 63c:	82 e3       	ldi	r24, 0x32	; 50
 63e:	90 e0       	ldi	r25, 0x00	; 0
 640:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 644:	50 c0       	rjmp	.+160    	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				else if (saveTemps[5] > TempFLine2)
 646:	20 e0       	ldi	r18, 0x00	; 0
 648:	30 e0       	ldi	r19, 0x00	; 0
 64a:	4a e7       	ldi	r20, 0x7A	; 122
 64c:	54 e4       	ldi	r21, 0x44	; 68
 64e:	c7 01       	movw	r24, r14
 650:	b6 01       	movw	r22, r12
 652:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__gesf2>
 656:	18 16       	cp	r1, r24
 658:	0c f0       	brlt	.+2      	; 0x65c <tempHeaterHelper+0x23c>
 65a:	45 c0       	rjmp	.+138    	; 0x6e6 <tempHeaterHelper+0x2c6>
				{
					if (!opMode)           // We are in warming mode so this can use the PWM
 65c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 660:	81 11       	cpse	r24, r1
 662:	0c c0       	rjmp	.+24     	; 0x67c <tempHeaterHelper+0x25c>
					{
						assign_bit(&TCCR2, CS22, 0);       // Turn the PWM off
 664:	40 e0       	ldi	r20, 0x00	; 0
 666:	62 e0       	ldi	r22, 0x02	; 2
 668:	85 e4       	ldi	r24, 0x45	; 69
 66a:	90 e0       	ldi	r25, 0x00	; 0
 66c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x10;
 670:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 674:	80 61       	ori	r24, 0x10	; 16
 676:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 67a:	35 c0       	rjmp	.+106    	; 0x6e6 <tempHeaterHelper+0x2c6>
					}
					else
						assign_bit(&PORTD, Fline2Pin, 0);    // Turn the heater off manually
 67c:	40 e0       	ldi	r20, 0x00	; 0
 67e:	67 e0       	ldi	r22, 0x07	; 7
 680:	82 e3       	ldi	r24, 0x32	; 50
 682:	90 e0       	ldi	r25, 0x00	; 0
 684:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 688:	2e c0       	rjmp	.+92     	; 0x6e6 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 5:       // This is the case for the ESB    /////////////////////////////////////////////////
				if (saveTemps[5] < TempESB)
 68a:	c0 90 86 00 	lds	r12, 0x0086	; 0x800086 <saveTemps+0x14>
 68e:	d0 90 87 00 	lds	r13, 0x0087	; 0x800087 <saveTemps+0x15>
 692:	e0 90 88 00 	lds	r14, 0x0088	; 0x800088 <saveTemps+0x16>
 696:	f0 90 89 00 	lds	r15, 0x0089	; 0x800089 <saveTemps+0x17>
 69a:	20 e0       	ldi	r18, 0x00	; 0
 69c:	30 e0       	ldi	r19, 0x00	; 0
 69e:	40 e2       	ldi	r20, 0x20	; 32
 6a0:	51 e4       	ldi	r21, 0x41	; 65
 6a2:	c7 01       	movw	r24, r14
 6a4:	b6 01       	movw	r22, r12
 6a6:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__cmpsf2>
 6aa:	88 23       	and	r24, r24
 6ac:	3c f4       	brge	.+14     	; 0x6bc <tempHeaterHelper+0x29c>
					assign_bit(&PORTD, ESB_Pin, 1);
 6ae:	41 e0       	ldi	r20, 0x01	; 1
 6b0:	63 e0       	ldi	r22, 0x03	; 3
 6b2:	82 e3       	ldi	r24, 0x32	; 50
 6b4:	90 e0       	ldi	r25, 0x00	; 0
 6b6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 6ba:	15 c0       	rjmp	.+42     	; 0x6e6 <tempHeaterHelper+0x2c6>
				else if(saveTemps[5] > TempESB)
 6bc:	20 e0       	ldi	r18, 0x00	; 0
 6be:	30 e0       	ldi	r19, 0x00	; 0
 6c0:	40 e2       	ldi	r20, 0x20	; 32
 6c2:	51 e4       	ldi	r21, 0x41	; 65
 6c4:	c7 01       	movw	r24, r14
 6c6:	b6 01       	movw	r22, r12
 6c8:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <__gesf2>
 6cc:	18 16       	cp	r1, r24
 6ce:	5c f4       	brge	.+22     	; 0x6e6 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, ESB_Pin, 0);
 6d0:	40 e0       	ldi	r20, 0x00	; 0
 6d2:	63 e0       	ldi	r22, 0x03	; 3
 6d4:	82 e3       	ldi	r24, 0x32	; 50
 6d6:	90 e0       	ldi	r25, 0x00	; 0
 6d8:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x20;
 6dc:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 6e0:	80 62       	ori	r24, 0x20	; 32
 6e2:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
	for (uint8_t i = 0; i < 6; i++)
 6e6:	cf 5f       	subi	r28, 0xFF	; 255
 6e8:	c6 30       	cpi	r28, 0x06	; 6
 6ea:	08 f4       	brcc	.+2      	; 0x6ee <tempHeaterHelper+0x2ce>
 6ec:	a0 ce       	rjmp	.-704    	; 0x42e <tempHeaterHelper+0xe>
				break;
		}
		
	}
	
	if (desired_temp == 0x3F)      // Will go in here every time after it stops being mode 0
 6ee:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 6f2:	8f 33       	cpi	r24, 0x3F	; 63
 6f4:	31 f4       	brne	.+12     	; 0x702 <tempHeaterHelper+0x2e2>
		/* If desired_temp was 0111 1111, it would go to 1111 1111 with the or.
		*   Then the bitwise not (~) would make it 0000 0000.  And finally,
		*   the logical not (!) would make it 0000 0001 and it would go into the if statement.
		*   If desired_temp is anything but this, it will not go in here 
		*/
		if (!opMode)    // only do this if it has never gone in here before
 6f6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 6fa:	81 11       	cpse	r24, r1
 6fc:	02 c0       	rjmp	.+4      	; 0x702 <tempHeaterHelper+0x2e2>
			change_timers();                     // New initialization routine which will change the prescalars and such for the timers which will be serving different purposes
 6fe:	0e 94 a9 01 	call	0x352	; 0x352 <change_timers>
	}
}
 702:	cf 91       	pop	r28
 704:	ff 90       	pop	r15
 706:	ef 90       	pop	r14
 708:	df 90       	pop	r13
 70a:	cf 90       	pop	r12
 70c:	08 95       	ret

0000070e <tempConversion>:
 *  @param void
 *  @return void
 *  @see tempHeaterHelper
 */
void tempConversion(void)
{
 70e:	1f 93       	push	r17
 710:	cf 93       	push	r28
 712:	df 93       	push	r29
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
 714:	40 e0       	ldi	r20, 0x00	; 0
 716:	60 e0       	ldi	r22, 0x00	; 0
 718:	87 e2       	ldi	r24, 0x27	; 39
 71a:	90 e0       	ldi	r25, 0x00	; 0
 71c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX1,0);
 720:	40 e0       	ldi	r20, 0x00	; 0
 722:	61 e0       	ldi	r22, 0x01	; 1
 724:	87 e2       	ldi	r24, 0x27	; 39
 726:	90 e0       	ldi	r25, 0x00	; 0
 728:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX2,0);
 72c:	40 e0       	ldi	r20, 0x00	; 0
 72e:	62 e0       	ldi	r22, 0x02	; 2
 730:	87 e2       	ldi	r24, 0x27	; 39
 732:	90 e0       	ldi	r25, 0x00	; 0
 734:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	for (unsigned char i = 0; i < 6; i++)
 738:	10 e0       	ldi	r17, 0x00	; 0
 73a:	53 c0       	rjmp	.+166    	; 0x7e2 <tempConversion+0xd4>
	{
		ADCSRA |= 1 << ADSC;                             // Start the conversion
 73c:	86 b1       	in	r24, 0x06	; 6
 73e:	80 64       	ori	r24, 0x40	; 64
 740:	86 b9       	out	0x06, r24	; 6
		while (!((1 << ADIF) & ADCSRA));
 742:	34 9b       	sbis	0x06, 4	; 6
 744:	fe cf       	rjmp	.-4      	; 0x742 <tempConversion+0x34>
		
		while (bit_is_clear(ADCSRA, ADIF));				 // Hog execution until the ADC is done converting
 746:	34 9b       	sbis	0x06, 4	; 6
 748:	fe cf       	rjmp	.-4      	; 0x746 <tempConversion+0x38>

		// Save this as a float for the respective variable
		uint8_t low_bits = ADCL;
 74a:	84 b1       	in	r24, 0x04	; 4
		uint8_t high_bits = ADCH;						 // Do the shifting so that there is room made inside of the 16 bit register
 74c:	65 b1       	in	r22, 0x05	; 5
		uint16_t result = (high_bits << 8) | low_bits;
 74e:	70 e0       	ldi	r23, 0x00	; 0
 750:	76 2f       	mov	r23, r22
 752:	66 27       	eor	r22, r22
 754:	68 2b       	or	r22, r24
		
		// Now I need to convert this 16 bit number into an actual temperature
		
		float act_temp = (float)(0.0048828125*result);   // This dumb thing converts it to a voltage
 756:	80 e0       	ldi	r24, 0x00	; 0
 758:	90 e0       	ldi	r25, 0x00	; 0
 75a:	0e 94 a9 05 	call	0xb52	; 0xb52 <__floatunsisf>
 75e:	20 e0       	ldi	r18, 0x00	; 0
 760:	30 e0       	ldi	r19, 0x00	; 0
 762:	40 ea       	ldi	r20, 0xA0	; 160
 764:	5b e3       	ldi	r21, 0x3B	; 59
 766:	0e 94 60 06 	call	0xcc0	; 0xcc0 <__mulsf3>
		act_temp = act_temp*208.8 - 79.6;
 76a:	2d ec       	ldi	r18, 0xCD	; 205
 76c:	3c ec       	ldi	r19, 0xCC	; 204
 76e:	40 e5       	ldi	r20, 0x50	; 80
 770:	53 e4       	ldi	r21, 0x43	; 67
 772:	0e 94 60 06 	call	0xcc0	; 0xcc0 <__mulsf3>
 776:	23 e3       	ldi	r18, 0x33	; 51
 778:	33 e3       	ldi	r19, 0x33	; 51
 77a:	4f e9       	ldi	r20, 0x9F	; 159
 77c:	52 e4       	ldi	r21, 0x42	; 66
 77e:	0e 94 8f 04 	call	0x91e	; 0x91e <__subsf3>
		saveTemps[i] = act_temp;
 782:	c1 2f       	mov	r28, r17
 784:	d0 e0       	ldi	r29, 0x00	; 0
 786:	fe 01       	movw	r30, r28
 788:	ee 0f       	add	r30, r30
 78a:	ff 1f       	adc	r31, r31
 78c:	ee 0f       	add	r30, r30
 78e:	ff 1f       	adc	r31, r31
 790:	ee 58       	subi	r30, 0x8E	; 142
 792:	ff 4f       	sbci	r31, 0xFF	; 255
 794:	60 83       	st	Z, r22
 796:	71 83       	std	Z+1, r23	; 0x01
 798:	82 83       	std	Z+2, r24	; 0x02
 79a:	93 83       	std	Z+3, r25	; 0x03
		
		// Now update the channel the ADC is using
		assign_bit(&ADMUX,MUX0,(i + 1) & 0x01);           // Assign bit 0
 79c:	1f 5f       	subi	r17, 0xFF	; 255
 79e:	41 2f       	mov	r20, r17
 7a0:	41 70       	andi	r20, 0x01	; 1
 7a2:	60 e0       	ldi	r22, 0x00	; 0
 7a4:	87 e2       	ldi	r24, 0x27	; 39
 7a6:	90 e0       	ldi	r25, 0x00	; 0
 7a8:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX1,((i + 1) >> 1) & 0x01);    // Assign bit 1
 7ac:	21 96       	adiw	r28, 0x01	; 1
 7ae:	ae 01       	movw	r20, r28
 7b0:	55 95       	asr	r21
 7b2:	47 95       	ror	r20
 7b4:	41 70       	andi	r20, 0x01	; 1
 7b6:	61 e0       	ldi	r22, 0x01	; 1
 7b8:	87 e2       	ldi	r24, 0x27	; 39
 7ba:	90 e0       	ldi	r25, 0x00	; 0
 7bc:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
 7c0:	d5 95       	asr	r29
 7c2:	c7 95       	ror	r28
 7c4:	d5 95       	asr	r29
 7c6:	c7 95       	ror	r28
 7c8:	4c 2f       	mov	r20, r28
 7ca:	41 70       	andi	r20, 0x01	; 1
 7cc:	62 e0       	ldi	r22, 0x02	; 2
 7ce:	87 e2       	ldi	r24, 0x27	; 39
 7d0:	90 e0       	ldi	r25, 0x00	; 0
 7d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet
 7d6:	41 e0       	ldi	r20, 0x01	; 1
 7d8:	64 e0       	ldi	r22, 0x04	; 4
 7da:	86 e2       	ldi	r24, 0x26	; 38
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
	assign_bit(&ADMUX,MUX1,0);
	assign_bit(&ADMUX,MUX2,0);
	
	for (unsigned char i = 0; i < 6; i++)
 7e2:	16 30       	cpi	r17, 0x06	; 6
 7e4:	08 f4       	brcc	.+2      	; 0x7e8 <tempConversion+0xda>
 7e6:	aa cf       	rjmp	.-172    	; 0x73c <tempConversion+0x2e>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet

	}
	tempHeaterHelper();             // Call the helper function.  This will serve the added bonus of killing some time so that if capacitors need to charge for the next conversion, it has the time here.  Data sheet didn't say that it needed this though.
 7e8:	0e 94 10 02 	call	0x420	; 0x420 <tempHeaterHelper>
	if (opMode != 1)
 7ec:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 7f0:	81 30       	cpi	r24, 0x01	; 1
 7f2:	31 f0       	breq	.+12     	; 0x800 <tempConversion+0xf2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 7f4:	83 e2       	ldi	r24, 0x23	; 35
 7f6:	94 ef       	ldi	r25, 0xF4	; 244
 7f8:	01 97       	sbiw	r24, 0x01	; 1
 7fa:	f1 f7       	brne	.-4      	; 0x7f8 <tempConversion+0xea>
 7fc:	00 c0       	rjmp	.+0      	; 0x7fe <tempConversion+0xf0>
 7fe:	00 00       	nop
		_delay_ms(250);                 // Delay for 1/4 of a second.   This will only impact modes 0 and 2
	
}
 800:	df 91       	pop	r29
 802:	cf 91       	pop	r28
 804:	1f 91       	pop	r17
 806:	08 95       	ret

00000808 <__vector_3>:
 *  @param[in] pulse_count This is the number which describes how many pulses have been received for the sampling period.  It is an implicit argument as it is a global variable which is not explicitly passed in.
 *  @return void
 *  @see flowMeter
 */
ISR(INT2_vect)
{
 808:	1f 92       	push	r1
 80a:	0f 92       	push	r0
 80c:	0f b6       	in	r0, 0x3f	; 63
 80e:	0f 92       	push	r0
 810:	11 24       	eor	r1, r1
 812:	8f 93       	push	r24
	pulse_count++;  // The interrupt flag will automatically be cleared by hardware
 814:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <pulse_count>
 818:	8f 5f       	subi	r24, 0xFF	; 255
 81a:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <pulse_count>
}
 81e:	8f 91       	pop	r24
 820:	0f 90       	pop	r0
 822:	0f be       	out	0x3f, r0	; 63
 824:	0f 90       	pop	r0
 826:	1f 90       	pop	r1
 828:	18 95       	reti

0000082a <__vector_5>:
 *
 *  @param[in] alive_counter Variable to act as a custom prescalar for the timer
 *  @return void
 */
ISR(TIMER2_OVF_vect)
{
 82a:	1f 92       	push	r1
 82c:	0f 92       	push	r0
 82e:	0f b6       	in	r0, 0x3f	; 63
 830:	0f 92       	push	r0
 832:	11 24       	eor	r1, r1
 834:	2f 93       	push	r18
 836:	3f 93       	push	r19
 838:	4f 93       	push	r20
 83a:	5f 93       	push	r21
 83c:	6f 93       	push	r22
 83e:	7f 93       	push	r23
 840:	8f 93       	push	r24
 842:	9f 93       	push	r25
 844:	af 93       	push	r26
 846:	bf 93       	push	r27
 848:	ef 93       	push	r30
 84a:	ff 93       	push	r31
	if (opMode == 1)     // Operation mode 1 so do 0.75 sec on and 0.25 sec off
 84c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 850:	81 30       	cpi	r24, 0x01	; 1
 852:	29 f5       	brne	.+74     	; 0x89e <__stack+0x3f>
	{
		if (alive_counter == 2)
 854:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 858:	82 30       	cpi	r24, 0x02	; 2
 85a:	71 f4       	brne	.+28     	; 0x878 <__stack+0x19>
		{
			assign_bit(&PORTD, Alive_LED, 0);        // Turn the LED off since it is at the end of the 0.75 sec portion
 85c:	40 e0       	ldi	r20, 0x00	; 0
 85e:	65 e0       	ldi	r22, 0x05	; 5
 860:	82 e3       	ldi	r24, 0x32	; 50
 862:	90 e0       	ldi	r25, 0x00	; 0
 864:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
 868:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 86c:	8f 5f       	subi	r24, 0xFF	; 255
 86e:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 11;
 872:	8b e0       	ldi	r24, 0x0B	; 11
 874:	84 bd       	out	0x24, r24	; 36
 876:	37 c0       	rjmp	.+110    	; 0x8e6 <__stack+0x87>
		}
		else if (alive_counter == 3)
 878:	83 30       	cpi	r24, 0x03	; 3
 87a:	59 f4       	brne	.+22     	; 0x892 <__stack+0x33>
		{
			assign_bit(&PORTD, Alive_LED, 1);        // Turn the LED back on since it is about to begin the 0.75 second portion
 87c:	41 e0       	ldi	r20, 0x01	; 1
 87e:	65 e0       	ldi	r22, 0x05	; 5
 880:	82 e3       	ldi	r24, 0x32	; 50
 882:	90 e0       	ldi	r25, 0x00	; 0
 884:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
 888:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
			TCNT2 = 11;                              // Assign the correct value into the Timer register so that it goes for 0.25 sec
 88c:	8b e0       	ldi	r24, 0x0B	; 11
 88e:	84 bd       	out	0x24, r24	; 36
 890:	2a c0       	rjmp	.+84     	; 0x8e6 <__stack+0x87>
		}
		else                                         // This section is for if it is in the middle of the 0.75 sec portion
		{
			alive_counter++;
 892:	8f 5f       	subi	r24, 0xFF	; 255
 894:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 11;
 898:	8b e0       	ldi	r24, 0x0B	; 11
 89a:	84 bd       	out	0x24, r24	; 36
 89c:	24 c0       	rjmp	.+72     	; 0x8e6 <__stack+0x87>
		}
	}
	else   // I am in operation mode 2 so I need to do 0.1 sec on 0.9 sec off
	{
		if (alive_counter == 1)
 89e:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 8a2:	81 30       	cpi	r24, 0x01	; 1
 8a4:	71 f4       	brne	.+28     	; 0x8c2 <__stack+0x63>
		{
			assign_bit(&PORTD, Alive_LED, 0);            // Turn off the LED since we are at the end of the 0.1 sec period
 8a6:	40 e0       	ldi	r20, 0x00	; 0
 8a8:	65 e0       	ldi	r22, 0x05	; 5
 8aa:	82 e3       	ldi	r24, 0x32	; 50
 8ac:	90 e0       	ldi	r25, 0x00	; 0
 8ae:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
 8b2:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 8b6:	8f 5f       	subi	r24, 0xFF	; 255
 8b8:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 60;
 8bc:	8c e3       	ldi	r24, 0x3C	; 60
 8be:	84 bd       	out	0x24, r24	; 36
 8c0:	12 c0       	rjmp	.+36     	; 0x8e6 <__stack+0x87>
		}
		else if (alive_counter == 19)
 8c2:	83 31       	cpi	r24, 0x13	; 19
 8c4:	59 f4       	brne	.+22     	; 0x8dc <__stack+0x7d>
		{
			assign_bit(&PORTD, Alive_LED, 1);            // Turn on the LED since we are at the end of the 0.9 sec period
 8c6:	41 e0       	ldi	r20, 0x01	; 1
 8c8:	65 e0       	ldi	r22, 0x05	; 5
 8ca:	82 e3       	ldi	r24, 0x32	; 50
 8cc:	90 e0       	ldi	r25, 0x00	; 0
 8ce:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
 8d2:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
			TCNT2 = 60;
 8d6:	8c e3       	ldi	r24, 0x3C	; 60
 8d8:	84 bd       	out	0x24, r24	; 36
 8da:	05 c0       	rjmp	.+10     	; 0x8e6 <__stack+0x87>

		}
		else
		{
			alive_counter++;                             // At one of the intermediate points so just keep the LED how it is
 8dc:	8f 5f       	subi	r24, 0xFF	; 255
 8de:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 60; 
 8e2:	8c e3       	ldi	r24, 0x3C	; 60
 8e4:	84 bd       	out	0x24, r24	; 36
		}
	}
}
 8e6:	ff 91       	pop	r31
 8e8:	ef 91       	pop	r30
 8ea:	bf 91       	pop	r27
 8ec:	af 91       	pop	r26
 8ee:	9f 91       	pop	r25
 8f0:	8f 91       	pop	r24
 8f2:	7f 91       	pop	r23
 8f4:	6f 91       	pop	r22
 8f6:	5f 91       	pop	r21
 8f8:	4f 91       	pop	r20
 8fa:	3f 91       	pop	r19
 8fc:	2f 91       	pop	r18
 8fe:	0f 90       	pop	r0
 900:	0f be       	out	0x3f, r0	; 63
 902:	0f 90       	pop	r0
 904:	1f 90       	pop	r1
 906:	18 95       	reti

00000908 <main>:
 */ 
#include "HCU_Funcs.h"

int main(void)
{
    Initial();
 908:	0e 94 79 00 	call	0xf2	; 0xf2 <Initial>
    while (1) 
    {
		tempConversion();
 90c:	0e 94 87 03 	call	0x70e	; 0x70e <tempConversion>
		if (!ECU_present && (opMode == 1))    // Will only go in here if the ECU is not present and in pumping mode
 910:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 914:	81 30       	cpi	r24, 0x01	; 1
 916:	d1 f7       	brne	.-12     	; 0x90c <main+0x4>
			flowMeter();
 918:	0e 94 39 01 	call	0x272	; 0x272 <flowMeter>
 91c:	f7 cf       	rjmp	.-18     	; 0x90c <main+0x4>

0000091e <__subsf3>:
 91e:	50 58       	subi	r21, 0x80	; 128

00000920 <__addsf3>:
 920:	bb 27       	eor	r27, r27
 922:	aa 27       	eor	r26, r26
 924:	0e 94 a7 04 	call	0x94e	; 0x94e <__addsf3x>
 928:	0c 94 21 06 	jmp	0xc42	; 0xc42 <__fp_round>
 92c:	0e 94 13 06 	call	0xc26	; 0xc26 <__fp_pscA>
 930:	38 f0       	brcs	.+14     	; 0x940 <__addsf3+0x20>
 932:	0e 94 1a 06 	call	0xc34	; 0xc34 <__fp_pscB>
 936:	20 f0       	brcs	.+8      	; 0x940 <__addsf3+0x20>
 938:	39 f4       	brne	.+14     	; 0x948 <__addsf3+0x28>
 93a:	9f 3f       	cpi	r25, 0xFF	; 255
 93c:	19 f4       	brne	.+6      	; 0x944 <__addsf3+0x24>
 93e:	26 f4       	brtc	.+8      	; 0x948 <__addsf3+0x28>
 940:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_nan>
 944:	0e f4       	brtc	.+2      	; 0x948 <__addsf3+0x28>
 946:	e0 95       	com	r30
 948:	e7 fb       	bst	r30, 7
 94a:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <__fp_inf>

0000094e <__addsf3x>:
 94e:	e9 2f       	mov	r30, r25
 950:	0e 94 32 06 	call	0xc64	; 0xc64 <__fp_split3>
 954:	58 f3       	brcs	.-42     	; 0x92c <__addsf3+0xc>
 956:	ba 17       	cp	r27, r26
 958:	62 07       	cpc	r22, r18
 95a:	73 07       	cpc	r23, r19
 95c:	84 07       	cpc	r24, r20
 95e:	95 07       	cpc	r25, r21
 960:	20 f0       	brcs	.+8      	; 0x96a <__addsf3x+0x1c>
 962:	79 f4       	brne	.+30     	; 0x982 <__addsf3x+0x34>
 964:	a6 f5       	brtc	.+104    	; 0x9ce <__addsf3x+0x80>
 966:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__fp_zero>
 96a:	0e f4       	brtc	.+2      	; 0x96e <__addsf3x+0x20>
 96c:	e0 95       	com	r30
 96e:	0b 2e       	mov	r0, r27
 970:	ba 2f       	mov	r27, r26
 972:	a0 2d       	mov	r26, r0
 974:	0b 01       	movw	r0, r22
 976:	b9 01       	movw	r22, r18
 978:	90 01       	movw	r18, r0
 97a:	0c 01       	movw	r0, r24
 97c:	ca 01       	movw	r24, r20
 97e:	a0 01       	movw	r20, r0
 980:	11 24       	eor	r1, r1
 982:	ff 27       	eor	r31, r31
 984:	59 1b       	sub	r21, r25
 986:	99 f0       	breq	.+38     	; 0x9ae <__addsf3x+0x60>
 988:	59 3f       	cpi	r21, 0xF9	; 249
 98a:	50 f4       	brcc	.+20     	; 0x9a0 <__addsf3x+0x52>
 98c:	50 3e       	cpi	r21, 0xE0	; 224
 98e:	68 f1       	brcs	.+90     	; 0x9ea <__addsf3x+0x9c>
 990:	1a 16       	cp	r1, r26
 992:	f0 40       	sbci	r31, 0x00	; 0
 994:	a2 2f       	mov	r26, r18
 996:	23 2f       	mov	r18, r19
 998:	34 2f       	mov	r19, r20
 99a:	44 27       	eor	r20, r20
 99c:	58 5f       	subi	r21, 0xF8	; 248
 99e:	f3 cf       	rjmp	.-26     	; 0x986 <__addsf3x+0x38>
 9a0:	46 95       	lsr	r20
 9a2:	37 95       	ror	r19
 9a4:	27 95       	ror	r18
 9a6:	a7 95       	ror	r26
 9a8:	f0 40       	sbci	r31, 0x00	; 0
 9aa:	53 95       	inc	r21
 9ac:	c9 f7       	brne	.-14     	; 0x9a0 <__addsf3x+0x52>
 9ae:	7e f4       	brtc	.+30     	; 0x9ce <__addsf3x+0x80>
 9b0:	1f 16       	cp	r1, r31
 9b2:	ba 0b       	sbc	r27, r26
 9b4:	62 0b       	sbc	r22, r18
 9b6:	73 0b       	sbc	r23, r19
 9b8:	84 0b       	sbc	r24, r20
 9ba:	ba f0       	brmi	.+46     	; 0x9ea <__addsf3x+0x9c>
 9bc:	91 50       	subi	r25, 0x01	; 1
 9be:	a1 f0       	breq	.+40     	; 0x9e8 <__addsf3x+0x9a>
 9c0:	ff 0f       	add	r31, r31
 9c2:	bb 1f       	adc	r27, r27
 9c4:	66 1f       	adc	r22, r22
 9c6:	77 1f       	adc	r23, r23
 9c8:	88 1f       	adc	r24, r24
 9ca:	c2 f7       	brpl	.-16     	; 0x9bc <__addsf3x+0x6e>
 9cc:	0e c0       	rjmp	.+28     	; 0x9ea <__addsf3x+0x9c>
 9ce:	ba 0f       	add	r27, r26
 9d0:	62 1f       	adc	r22, r18
 9d2:	73 1f       	adc	r23, r19
 9d4:	84 1f       	adc	r24, r20
 9d6:	48 f4       	brcc	.+18     	; 0x9ea <__addsf3x+0x9c>
 9d8:	87 95       	ror	r24
 9da:	77 95       	ror	r23
 9dc:	67 95       	ror	r22
 9de:	b7 95       	ror	r27
 9e0:	f7 95       	ror	r31
 9e2:	9e 3f       	cpi	r25, 0xFE	; 254
 9e4:	08 f0       	brcs	.+2      	; 0x9e8 <__addsf3x+0x9a>
 9e6:	b0 cf       	rjmp	.-160    	; 0x948 <__addsf3+0x28>
 9e8:	93 95       	inc	r25
 9ea:	88 0f       	add	r24, r24
 9ec:	08 f0       	brcs	.+2      	; 0x9f0 <__addsf3x+0xa2>
 9ee:	99 27       	eor	r25, r25
 9f0:	ee 0f       	add	r30, r30
 9f2:	97 95       	ror	r25
 9f4:	87 95       	ror	r24
 9f6:	08 95       	ret

000009f8 <__cmpsf2>:
 9f8:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__fp_cmp>
 9fc:	08 f4       	brcc	.+2      	; 0xa00 <__cmpsf2+0x8>
 9fe:	81 e0       	ldi	r24, 0x01	; 1
 a00:	08 95       	ret

00000a02 <__divsf3>:
 a02:	0e 94 15 05 	call	0xa2a	; 0xa2a <__divsf3x>
 a06:	0c 94 21 06 	jmp	0xc42	; 0xc42 <__fp_round>
 a0a:	0e 94 1a 06 	call	0xc34	; 0xc34 <__fp_pscB>
 a0e:	58 f0       	brcs	.+22     	; 0xa26 <__divsf3+0x24>
 a10:	0e 94 13 06 	call	0xc26	; 0xc26 <__fp_pscA>
 a14:	40 f0       	brcs	.+16     	; 0xa26 <__divsf3+0x24>
 a16:	29 f4       	brne	.+10     	; 0xa22 <__divsf3+0x20>
 a18:	5f 3f       	cpi	r21, 0xFF	; 255
 a1a:	29 f0       	breq	.+10     	; 0xa26 <__divsf3+0x24>
 a1c:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <__fp_inf>
 a20:	51 11       	cpse	r21, r1
 a22:	0c 94 55 06 	jmp	0xcaa	; 0xcaa <__fp_szero>
 a26:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_nan>

00000a2a <__divsf3x>:
 a2a:	0e 94 32 06 	call	0xc64	; 0xc64 <__fp_split3>
 a2e:	68 f3       	brcs	.-38     	; 0xa0a <__divsf3+0x8>

00000a30 <__divsf3_pse>:
 a30:	99 23       	and	r25, r25
 a32:	b1 f3       	breq	.-20     	; 0xa20 <__divsf3+0x1e>
 a34:	55 23       	and	r21, r21
 a36:	91 f3       	breq	.-28     	; 0xa1c <__divsf3+0x1a>
 a38:	95 1b       	sub	r25, r21
 a3a:	55 0b       	sbc	r21, r21
 a3c:	bb 27       	eor	r27, r27
 a3e:	aa 27       	eor	r26, r26
 a40:	62 17       	cp	r22, r18
 a42:	73 07       	cpc	r23, r19
 a44:	84 07       	cpc	r24, r20
 a46:	38 f0       	brcs	.+14     	; 0xa56 <__divsf3_pse+0x26>
 a48:	9f 5f       	subi	r25, 0xFF	; 255
 a4a:	5f 4f       	sbci	r21, 0xFF	; 255
 a4c:	22 0f       	add	r18, r18
 a4e:	33 1f       	adc	r19, r19
 a50:	44 1f       	adc	r20, r20
 a52:	aa 1f       	adc	r26, r26
 a54:	a9 f3       	breq	.-22     	; 0xa40 <__divsf3_pse+0x10>
 a56:	35 d0       	rcall	.+106    	; 0xac2 <__divsf3_pse+0x92>
 a58:	0e 2e       	mov	r0, r30
 a5a:	3a f0       	brmi	.+14     	; 0xa6a <__divsf3_pse+0x3a>
 a5c:	e0 e8       	ldi	r30, 0x80	; 128
 a5e:	32 d0       	rcall	.+100    	; 0xac4 <__divsf3_pse+0x94>
 a60:	91 50       	subi	r25, 0x01	; 1
 a62:	50 40       	sbci	r21, 0x00	; 0
 a64:	e6 95       	lsr	r30
 a66:	00 1c       	adc	r0, r0
 a68:	ca f7       	brpl	.-14     	; 0xa5c <__divsf3_pse+0x2c>
 a6a:	2b d0       	rcall	.+86     	; 0xac2 <__divsf3_pse+0x92>
 a6c:	fe 2f       	mov	r31, r30
 a6e:	29 d0       	rcall	.+82     	; 0xac2 <__divsf3_pse+0x92>
 a70:	66 0f       	add	r22, r22
 a72:	77 1f       	adc	r23, r23
 a74:	88 1f       	adc	r24, r24
 a76:	bb 1f       	adc	r27, r27
 a78:	26 17       	cp	r18, r22
 a7a:	37 07       	cpc	r19, r23
 a7c:	48 07       	cpc	r20, r24
 a7e:	ab 07       	cpc	r26, r27
 a80:	b0 e8       	ldi	r27, 0x80	; 128
 a82:	09 f0       	breq	.+2      	; 0xa86 <__divsf3_pse+0x56>
 a84:	bb 0b       	sbc	r27, r27
 a86:	80 2d       	mov	r24, r0
 a88:	bf 01       	movw	r22, r30
 a8a:	ff 27       	eor	r31, r31
 a8c:	93 58       	subi	r25, 0x83	; 131
 a8e:	5f 4f       	sbci	r21, 0xFF	; 255
 a90:	3a f0       	brmi	.+14     	; 0xaa0 <__divsf3_pse+0x70>
 a92:	9e 3f       	cpi	r25, 0xFE	; 254
 a94:	51 05       	cpc	r21, r1
 a96:	78 f0       	brcs	.+30     	; 0xab6 <__divsf3_pse+0x86>
 a98:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <__fp_inf>
 a9c:	0c 94 55 06 	jmp	0xcaa	; 0xcaa <__fp_szero>
 aa0:	5f 3f       	cpi	r21, 0xFF	; 255
 aa2:	e4 f3       	brlt	.-8      	; 0xa9c <__divsf3_pse+0x6c>
 aa4:	98 3e       	cpi	r25, 0xE8	; 232
 aa6:	d4 f3       	brlt	.-12     	; 0xa9c <__divsf3_pse+0x6c>
 aa8:	86 95       	lsr	r24
 aaa:	77 95       	ror	r23
 aac:	67 95       	ror	r22
 aae:	b7 95       	ror	r27
 ab0:	f7 95       	ror	r31
 ab2:	9f 5f       	subi	r25, 0xFF	; 255
 ab4:	c9 f7       	brne	.-14     	; 0xaa8 <__divsf3_pse+0x78>
 ab6:	88 0f       	add	r24, r24
 ab8:	91 1d       	adc	r25, r1
 aba:	96 95       	lsr	r25
 abc:	87 95       	ror	r24
 abe:	97 f9       	bld	r25, 7
 ac0:	08 95       	ret
 ac2:	e1 e0       	ldi	r30, 0x01	; 1
 ac4:	66 0f       	add	r22, r22
 ac6:	77 1f       	adc	r23, r23
 ac8:	88 1f       	adc	r24, r24
 aca:	bb 1f       	adc	r27, r27
 acc:	62 17       	cp	r22, r18
 ace:	73 07       	cpc	r23, r19
 ad0:	84 07       	cpc	r24, r20
 ad2:	ba 07       	cpc	r27, r26
 ad4:	20 f0       	brcs	.+8      	; 0xade <__divsf3_pse+0xae>
 ad6:	62 1b       	sub	r22, r18
 ad8:	73 0b       	sbc	r23, r19
 ada:	84 0b       	sbc	r24, r20
 adc:	ba 0b       	sbc	r27, r26
 ade:	ee 1f       	adc	r30, r30
 ae0:	88 f7       	brcc	.-30     	; 0xac4 <__divsf3_pse+0x94>
 ae2:	e0 95       	com	r30
 ae4:	08 95       	ret

00000ae6 <__fixsfsi>:
 ae6:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <__fixunssfsi>
 aea:	68 94       	set
 aec:	b1 11       	cpse	r27, r1
 aee:	0c 94 55 06 	jmp	0xcaa	; 0xcaa <__fp_szero>
 af2:	08 95       	ret

00000af4 <__fixunssfsi>:
 af4:	0e 94 3a 06 	call	0xc74	; 0xc74 <__fp_splitA>
 af8:	88 f0       	brcs	.+34     	; 0xb1c <__fixunssfsi+0x28>
 afa:	9f 57       	subi	r25, 0x7F	; 127
 afc:	98 f0       	brcs	.+38     	; 0xb24 <__fixunssfsi+0x30>
 afe:	b9 2f       	mov	r27, r25
 b00:	99 27       	eor	r25, r25
 b02:	b7 51       	subi	r27, 0x17	; 23
 b04:	b0 f0       	brcs	.+44     	; 0xb32 <__fixunssfsi+0x3e>
 b06:	e1 f0       	breq	.+56     	; 0xb40 <__fixunssfsi+0x4c>
 b08:	66 0f       	add	r22, r22
 b0a:	77 1f       	adc	r23, r23
 b0c:	88 1f       	adc	r24, r24
 b0e:	99 1f       	adc	r25, r25
 b10:	1a f0       	brmi	.+6      	; 0xb18 <__fixunssfsi+0x24>
 b12:	ba 95       	dec	r27
 b14:	c9 f7       	brne	.-14     	; 0xb08 <__fixunssfsi+0x14>
 b16:	14 c0       	rjmp	.+40     	; 0xb40 <__fixunssfsi+0x4c>
 b18:	b1 30       	cpi	r27, 0x01	; 1
 b1a:	91 f0       	breq	.+36     	; 0xb40 <__fixunssfsi+0x4c>
 b1c:	0e 94 54 06 	call	0xca8	; 0xca8 <__fp_zero>
 b20:	b1 e0       	ldi	r27, 0x01	; 1
 b22:	08 95       	ret
 b24:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__fp_zero>
 b28:	67 2f       	mov	r22, r23
 b2a:	78 2f       	mov	r23, r24
 b2c:	88 27       	eor	r24, r24
 b2e:	b8 5f       	subi	r27, 0xF8	; 248
 b30:	39 f0       	breq	.+14     	; 0xb40 <__fixunssfsi+0x4c>
 b32:	b9 3f       	cpi	r27, 0xF9	; 249
 b34:	cc f3       	brlt	.-14     	; 0xb28 <__fixunssfsi+0x34>
 b36:	86 95       	lsr	r24
 b38:	77 95       	ror	r23
 b3a:	67 95       	ror	r22
 b3c:	b3 95       	inc	r27
 b3e:	d9 f7       	brne	.-10     	; 0xb36 <__fixunssfsi+0x42>
 b40:	3e f4       	brtc	.+14     	; 0xb50 <__fixunssfsi+0x5c>
 b42:	90 95       	com	r25
 b44:	80 95       	com	r24
 b46:	70 95       	com	r23
 b48:	61 95       	neg	r22
 b4a:	7f 4f       	sbci	r23, 0xFF	; 255
 b4c:	8f 4f       	sbci	r24, 0xFF	; 255
 b4e:	9f 4f       	sbci	r25, 0xFF	; 255
 b50:	08 95       	ret

00000b52 <__floatunsisf>:
 b52:	e8 94       	clt
 b54:	09 c0       	rjmp	.+18     	; 0xb68 <__floatsisf+0x12>

00000b56 <__floatsisf>:
 b56:	97 fb       	bst	r25, 7
 b58:	3e f4       	brtc	.+14     	; 0xb68 <__floatsisf+0x12>
 b5a:	90 95       	com	r25
 b5c:	80 95       	com	r24
 b5e:	70 95       	com	r23
 b60:	61 95       	neg	r22
 b62:	7f 4f       	sbci	r23, 0xFF	; 255
 b64:	8f 4f       	sbci	r24, 0xFF	; 255
 b66:	9f 4f       	sbci	r25, 0xFF	; 255
 b68:	99 23       	and	r25, r25
 b6a:	a9 f0       	breq	.+42     	; 0xb96 <__floatsisf+0x40>
 b6c:	f9 2f       	mov	r31, r25
 b6e:	96 e9       	ldi	r25, 0x96	; 150
 b70:	bb 27       	eor	r27, r27
 b72:	93 95       	inc	r25
 b74:	f6 95       	lsr	r31
 b76:	87 95       	ror	r24
 b78:	77 95       	ror	r23
 b7a:	67 95       	ror	r22
 b7c:	b7 95       	ror	r27
 b7e:	f1 11       	cpse	r31, r1
 b80:	f8 cf       	rjmp	.-16     	; 0xb72 <__floatsisf+0x1c>
 b82:	fa f4       	brpl	.+62     	; 0xbc2 <__floatsisf+0x6c>
 b84:	bb 0f       	add	r27, r27
 b86:	11 f4       	brne	.+4      	; 0xb8c <__floatsisf+0x36>
 b88:	60 ff       	sbrs	r22, 0
 b8a:	1b c0       	rjmp	.+54     	; 0xbc2 <__floatsisf+0x6c>
 b8c:	6f 5f       	subi	r22, 0xFF	; 255
 b8e:	7f 4f       	sbci	r23, 0xFF	; 255
 b90:	8f 4f       	sbci	r24, 0xFF	; 255
 b92:	9f 4f       	sbci	r25, 0xFF	; 255
 b94:	16 c0       	rjmp	.+44     	; 0xbc2 <__floatsisf+0x6c>
 b96:	88 23       	and	r24, r24
 b98:	11 f0       	breq	.+4      	; 0xb9e <__floatsisf+0x48>
 b9a:	96 e9       	ldi	r25, 0x96	; 150
 b9c:	11 c0       	rjmp	.+34     	; 0xbc0 <__floatsisf+0x6a>
 b9e:	77 23       	and	r23, r23
 ba0:	21 f0       	breq	.+8      	; 0xbaa <__floatsisf+0x54>
 ba2:	9e e8       	ldi	r25, 0x8E	; 142
 ba4:	87 2f       	mov	r24, r23
 ba6:	76 2f       	mov	r23, r22
 ba8:	05 c0       	rjmp	.+10     	; 0xbb4 <__floatsisf+0x5e>
 baa:	66 23       	and	r22, r22
 bac:	71 f0       	breq	.+28     	; 0xbca <__floatsisf+0x74>
 bae:	96 e8       	ldi	r25, 0x86	; 134
 bb0:	86 2f       	mov	r24, r22
 bb2:	70 e0       	ldi	r23, 0x00	; 0
 bb4:	60 e0       	ldi	r22, 0x00	; 0
 bb6:	2a f0       	brmi	.+10     	; 0xbc2 <__floatsisf+0x6c>
 bb8:	9a 95       	dec	r25
 bba:	66 0f       	add	r22, r22
 bbc:	77 1f       	adc	r23, r23
 bbe:	88 1f       	adc	r24, r24
 bc0:	da f7       	brpl	.-10     	; 0xbb8 <__floatsisf+0x62>
 bc2:	88 0f       	add	r24, r24
 bc4:	96 95       	lsr	r25
 bc6:	87 95       	ror	r24
 bc8:	97 f9       	bld	r25, 7
 bca:	08 95       	ret

00000bcc <__fp_cmp>:
 bcc:	99 0f       	add	r25, r25
 bce:	00 08       	sbc	r0, r0
 bd0:	55 0f       	add	r21, r21
 bd2:	aa 0b       	sbc	r26, r26
 bd4:	e0 e8       	ldi	r30, 0x80	; 128
 bd6:	fe ef       	ldi	r31, 0xFE	; 254
 bd8:	16 16       	cp	r1, r22
 bda:	17 06       	cpc	r1, r23
 bdc:	e8 07       	cpc	r30, r24
 bde:	f9 07       	cpc	r31, r25
 be0:	c0 f0       	brcs	.+48     	; 0xc12 <__fp_cmp+0x46>
 be2:	12 16       	cp	r1, r18
 be4:	13 06       	cpc	r1, r19
 be6:	e4 07       	cpc	r30, r20
 be8:	f5 07       	cpc	r31, r21
 bea:	98 f0       	brcs	.+38     	; 0xc12 <__fp_cmp+0x46>
 bec:	62 1b       	sub	r22, r18
 bee:	73 0b       	sbc	r23, r19
 bf0:	84 0b       	sbc	r24, r20
 bf2:	95 0b       	sbc	r25, r21
 bf4:	39 f4       	brne	.+14     	; 0xc04 <__fp_cmp+0x38>
 bf6:	0a 26       	eor	r0, r26
 bf8:	61 f0       	breq	.+24     	; 0xc12 <__fp_cmp+0x46>
 bfa:	23 2b       	or	r18, r19
 bfc:	24 2b       	or	r18, r20
 bfe:	25 2b       	or	r18, r21
 c00:	21 f4       	brne	.+8      	; 0xc0a <__fp_cmp+0x3e>
 c02:	08 95       	ret
 c04:	0a 26       	eor	r0, r26
 c06:	09 f4       	brne	.+2      	; 0xc0a <__fp_cmp+0x3e>
 c08:	a1 40       	sbci	r26, 0x01	; 1
 c0a:	a6 95       	lsr	r26
 c0c:	8f ef       	ldi	r24, 0xFF	; 255
 c0e:	81 1d       	adc	r24, r1
 c10:	81 1d       	adc	r24, r1
 c12:	08 95       	ret

00000c14 <__fp_inf>:
 c14:	97 f9       	bld	r25, 7
 c16:	9f 67       	ori	r25, 0x7F	; 127
 c18:	80 e8       	ldi	r24, 0x80	; 128
 c1a:	70 e0       	ldi	r23, 0x00	; 0
 c1c:	60 e0       	ldi	r22, 0x00	; 0
 c1e:	08 95       	ret

00000c20 <__fp_nan>:
 c20:	9f ef       	ldi	r25, 0xFF	; 255
 c22:	80 ec       	ldi	r24, 0xC0	; 192
 c24:	08 95       	ret

00000c26 <__fp_pscA>:
 c26:	00 24       	eor	r0, r0
 c28:	0a 94       	dec	r0
 c2a:	16 16       	cp	r1, r22
 c2c:	17 06       	cpc	r1, r23
 c2e:	18 06       	cpc	r1, r24
 c30:	09 06       	cpc	r0, r25
 c32:	08 95       	ret

00000c34 <__fp_pscB>:
 c34:	00 24       	eor	r0, r0
 c36:	0a 94       	dec	r0
 c38:	12 16       	cp	r1, r18
 c3a:	13 06       	cpc	r1, r19
 c3c:	14 06       	cpc	r1, r20
 c3e:	05 06       	cpc	r0, r21
 c40:	08 95       	ret

00000c42 <__fp_round>:
 c42:	09 2e       	mov	r0, r25
 c44:	03 94       	inc	r0
 c46:	00 0c       	add	r0, r0
 c48:	11 f4       	brne	.+4      	; 0xc4e <__fp_round+0xc>
 c4a:	88 23       	and	r24, r24
 c4c:	52 f0       	brmi	.+20     	; 0xc62 <__fp_round+0x20>
 c4e:	bb 0f       	add	r27, r27
 c50:	40 f4       	brcc	.+16     	; 0xc62 <__fp_round+0x20>
 c52:	bf 2b       	or	r27, r31
 c54:	11 f4       	brne	.+4      	; 0xc5a <__fp_round+0x18>
 c56:	60 ff       	sbrs	r22, 0
 c58:	04 c0       	rjmp	.+8      	; 0xc62 <__fp_round+0x20>
 c5a:	6f 5f       	subi	r22, 0xFF	; 255
 c5c:	7f 4f       	sbci	r23, 0xFF	; 255
 c5e:	8f 4f       	sbci	r24, 0xFF	; 255
 c60:	9f 4f       	sbci	r25, 0xFF	; 255
 c62:	08 95       	ret

00000c64 <__fp_split3>:
 c64:	57 fd       	sbrc	r21, 7
 c66:	90 58       	subi	r25, 0x80	; 128
 c68:	44 0f       	add	r20, r20
 c6a:	55 1f       	adc	r21, r21
 c6c:	59 f0       	breq	.+22     	; 0xc84 <__fp_splitA+0x10>
 c6e:	5f 3f       	cpi	r21, 0xFF	; 255
 c70:	71 f0       	breq	.+28     	; 0xc8e <__fp_splitA+0x1a>
 c72:	47 95       	ror	r20

00000c74 <__fp_splitA>:
 c74:	88 0f       	add	r24, r24
 c76:	97 fb       	bst	r25, 7
 c78:	99 1f       	adc	r25, r25
 c7a:	61 f0       	breq	.+24     	; 0xc94 <__fp_splitA+0x20>
 c7c:	9f 3f       	cpi	r25, 0xFF	; 255
 c7e:	79 f0       	breq	.+30     	; 0xc9e <__fp_splitA+0x2a>
 c80:	87 95       	ror	r24
 c82:	08 95       	ret
 c84:	12 16       	cp	r1, r18
 c86:	13 06       	cpc	r1, r19
 c88:	14 06       	cpc	r1, r20
 c8a:	55 1f       	adc	r21, r21
 c8c:	f2 cf       	rjmp	.-28     	; 0xc72 <__fp_split3+0xe>
 c8e:	46 95       	lsr	r20
 c90:	f1 df       	rcall	.-30     	; 0xc74 <__fp_splitA>
 c92:	08 c0       	rjmp	.+16     	; 0xca4 <__fp_splitA+0x30>
 c94:	16 16       	cp	r1, r22
 c96:	17 06       	cpc	r1, r23
 c98:	18 06       	cpc	r1, r24
 c9a:	99 1f       	adc	r25, r25
 c9c:	f1 cf       	rjmp	.-30     	; 0xc80 <__fp_splitA+0xc>
 c9e:	86 95       	lsr	r24
 ca0:	71 05       	cpc	r23, r1
 ca2:	61 05       	cpc	r22, r1
 ca4:	08 94       	sec
 ca6:	08 95       	ret

00000ca8 <__fp_zero>:
 ca8:	e8 94       	clt

00000caa <__fp_szero>:
 caa:	bb 27       	eor	r27, r27
 cac:	66 27       	eor	r22, r22
 cae:	77 27       	eor	r23, r23
 cb0:	cb 01       	movw	r24, r22
 cb2:	97 f9       	bld	r25, 7
 cb4:	08 95       	ret

00000cb6 <__gesf2>:
 cb6:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__fp_cmp>
 cba:	08 f4       	brcc	.+2      	; 0xcbe <__gesf2+0x8>
 cbc:	8f ef       	ldi	r24, 0xFF	; 255
 cbe:	08 95       	ret

00000cc0 <__mulsf3>:
 cc0:	0e 94 73 06 	call	0xce6	; 0xce6 <__mulsf3x>
 cc4:	0c 94 21 06 	jmp	0xc42	; 0xc42 <__fp_round>
 cc8:	0e 94 13 06 	call	0xc26	; 0xc26 <__fp_pscA>
 ccc:	38 f0       	brcs	.+14     	; 0xcdc <__mulsf3+0x1c>
 cce:	0e 94 1a 06 	call	0xc34	; 0xc34 <__fp_pscB>
 cd2:	20 f0       	brcs	.+8      	; 0xcdc <__mulsf3+0x1c>
 cd4:	95 23       	and	r25, r21
 cd6:	11 f0       	breq	.+4      	; 0xcdc <__mulsf3+0x1c>
 cd8:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <__fp_inf>
 cdc:	0c 94 10 06 	jmp	0xc20	; 0xc20 <__fp_nan>
 ce0:	11 24       	eor	r1, r1
 ce2:	0c 94 55 06 	jmp	0xcaa	; 0xcaa <__fp_szero>

00000ce6 <__mulsf3x>:
 ce6:	0e 94 32 06 	call	0xc64	; 0xc64 <__fp_split3>
 cea:	70 f3       	brcs	.-36     	; 0xcc8 <__mulsf3+0x8>

00000cec <__mulsf3_pse>:
 cec:	95 9f       	mul	r25, r21
 cee:	c1 f3       	breq	.-16     	; 0xce0 <__mulsf3+0x20>
 cf0:	95 0f       	add	r25, r21
 cf2:	50 e0       	ldi	r21, 0x00	; 0
 cf4:	55 1f       	adc	r21, r21
 cf6:	62 9f       	mul	r22, r18
 cf8:	f0 01       	movw	r30, r0
 cfa:	72 9f       	mul	r23, r18
 cfc:	bb 27       	eor	r27, r27
 cfe:	f0 0d       	add	r31, r0
 d00:	b1 1d       	adc	r27, r1
 d02:	63 9f       	mul	r22, r19
 d04:	aa 27       	eor	r26, r26
 d06:	f0 0d       	add	r31, r0
 d08:	b1 1d       	adc	r27, r1
 d0a:	aa 1f       	adc	r26, r26
 d0c:	64 9f       	mul	r22, r20
 d0e:	66 27       	eor	r22, r22
 d10:	b0 0d       	add	r27, r0
 d12:	a1 1d       	adc	r26, r1
 d14:	66 1f       	adc	r22, r22
 d16:	82 9f       	mul	r24, r18
 d18:	22 27       	eor	r18, r18
 d1a:	b0 0d       	add	r27, r0
 d1c:	a1 1d       	adc	r26, r1
 d1e:	62 1f       	adc	r22, r18
 d20:	73 9f       	mul	r23, r19
 d22:	b0 0d       	add	r27, r0
 d24:	a1 1d       	adc	r26, r1
 d26:	62 1f       	adc	r22, r18
 d28:	83 9f       	mul	r24, r19
 d2a:	a0 0d       	add	r26, r0
 d2c:	61 1d       	adc	r22, r1
 d2e:	22 1f       	adc	r18, r18
 d30:	74 9f       	mul	r23, r20
 d32:	33 27       	eor	r19, r19
 d34:	a0 0d       	add	r26, r0
 d36:	61 1d       	adc	r22, r1
 d38:	23 1f       	adc	r18, r19
 d3a:	84 9f       	mul	r24, r20
 d3c:	60 0d       	add	r22, r0
 d3e:	21 1d       	adc	r18, r1
 d40:	82 2f       	mov	r24, r18
 d42:	76 2f       	mov	r23, r22
 d44:	6a 2f       	mov	r22, r26
 d46:	11 24       	eor	r1, r1
 d48:	9f 57       	subi	r25, 0x7F	; 127
 d4a:	50 40       	sbci	r21, 0x00	; 0
 d4c:	9a f0       	brmi	.+38     	; 0xd74 <__mulsf3_pse+0x88>
 d4e:	f1 f0       	breq	.+60     	; 0xd8c <__mulsf3_pse+0xa0>
 d50:	88 23       	and	r24, r24
 d52:	4a f0       	brmi	.+18     	; 0xd66 <__mulsf3_pse+0x7a>
 d54:	ee 0f       	add	r30, r30
 d56:	ff 1f       	adc	r31, r31
 d58:	bb 1f       	adc	r27, r27
 d5a:	66 1f       	adc	r22, r22
 d5c:	77 1f       	adc	r23, r23
 d5e:	88 1f       	adc	r24, r24
 d60:	91 50       	subi	r25, 0x01	; 1
 d62:	50 40       	sbci	r21, 0x00	; 0
 d64:	a9 f7       	brne	.-22     	; 0xd50 <__mulsf3_pse+0x64>
 d66:	9e 3f       	cpi	r25, 0xFE	; 254
 d68:	51 05       	cpc	r21, r1
 d6a:	80 f0       	brcs	.+32     	; 0xd8c <__mulsf3_pse+0xa0>
 d6c:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <__fp_inf>
 d70:	0c 94 55 06 	jmp	0xcaa	; 0xcaa <__fp_szero>
 d74:	5f 3f       	cpi	r21, 0xFF	; 255
 d76:	e4 f3       	brlt	.-8      	; 0xd70 <__mulsf3_pse+0x84>
 d78:	98 3e       	cpi	r25, 0xE8	; 232
 d7a:	d4 f3       	brlt	.-12     	; 0xd70 <__mulsf3_pse+0x84>
 d7c:	86 95       	lsr	r24
 d7e:	77 95       	ror	r23
 d80:	67 95       	ror	r22
 d82:	b7 95       	ror	r27
 d84:	f7 95       	ror	r31
 d86:	e7 95       	ror	r30
 d88:	9f 5f       	subi	r25, 0xFF	; 255
 d8a:	c1 f7       	brne	.-16     	; 0xd7c <__mulsf3_pse+0x90>
 d8c:	fe 2b       	or	r31, r30
 d8e:	88 0f       	add	r24, r24
 d90:	91 1d       	adc	r25, r1
 d92:	96 95       	lsr	r25
 d94:	87 95       	ror	r24
 d96:	97 f9       	bld	r25, 7
 d98:	08 95       	ret

00000d9a <_exit>:
 d9a:	f8 94       	cli

00000d9c <__stop_program>:
 d9c:	ff cf       	rjmp	.-2      	; 0xd9c <__stop_program>
