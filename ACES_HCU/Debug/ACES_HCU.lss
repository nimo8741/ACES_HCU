
ACES_HCU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001032  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000010a6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000f8  00800060  00800060  000010a6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010a6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000010d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00001114  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001709  00000000  00000000  0000119c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000764  00000000  00000000  000028a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000961  00000000  00000000  00003009  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001a8  00000000  00000000  0000396c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004e9  00000000  00000000  00003b14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000045c  00000000  00000000  00003ffd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  00004459  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
       8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
       c:	0c 94 3a 05 	jmp	0xa74	; 0xa74 <__vector_3>
      10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      14:	0c 94 4b 05 	jmp	0xa96	; 0xa96 <__vector_5>
      18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__vector_9>
      28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
      50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
      60:	21 e0       	ldi	r18, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
      68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
      6a:	a8 35       	cpi	r26, 0x58	; 88
      6c:	b2 07       	cpc	r27, r18
      6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
      70:	0e 94 ba 05 	call	0xb74	; 0xb74 <main>
      74:	0c 94 17 08 	jmp	0x102e	; 0x102e <_exit>

00000078 <__bad_interrupt>:
      78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <__vector_9>:
 *
 *  @param TIMER1_OVF_vect    The interrupt vector for the overflow of timer 1 
 *  @return Void
 */
ISR(TIMER1_OVF_vect)
{
      7c:	1f 92       	push	r1
      7e:	0f 92       	push	r0
      80:	0f b6       	in	r0, 0x3f	; 63
      82:	0f 92       	push	r0
      84:	11 24       	eor	r1, r1
      86:	8f 93       	push	r24
      88:	9f 93       	push	r25
	// The LED is on PD5
	alive_counter++;
      8a:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
      8e:	8f 5f       	subi	r24, 0xFF	; 255
      90:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
	if (alive_counter % 2 == 1)
      94:	80 ff       	sbrs	r24, 0
      96:	04 c0       	rjmp	.+8      	; 0xa0 <__vector_9+0x24>
	PORTD ^= (1 << Alive_LED);
      98:	92 b3       	in	r25, 0x12	; 18
      9a:	80 e2       	ldi	r24, 0x20	; 32
      9c:	89 27       	eor	r24, r25
      9e:	82 bb       	out	0x12, r24	; 18
		
	PORTB ^= (1 << Warm_LED);   // This will have the warming LED blink 0.5 sec on 0.5 sec off and the alive LED blinking twice as slow
      a0:	98 b3       	in	r25, 0x18	; 24
      a2:	82 e0       	ldi	r24, 0x02	; 2
      a4:	89 27       	eor	r24, r25
      a6:	88 bb       	out	0x18, r24	; 24
		
	// Now reset the register
	TCNT1 = 3036;  // The interrupt will clear automatically when this function is called
      a8:	8c ed       	ldi	r24, 0xDC	; 220
      aa:	9b e0       	ldi	r25, 0x0B	; 11
      ac:	9d bd       	out	0x2d, r25	; 45
      ae:	8c bd       	out	0x2c, r24	; 44
}
      b0:	9f 91       	pop	r25
      b2:	8f 91       	pop	r24
      b4:	0f 90       	pop	r0
      b6:	0f be       	out	0x3f, r0	; 63
      b8:	0f 90       	pop	r0
      ba:	1f 90       	pop	r1
      bc:	18 95       	reti

000000be <assign_bit>:
 *  @param[in] val The value, either 1 or 0, that the user would like the bit to be after the function call.
 *  @return void
 */
void assign_bit(volatile uint8_t *sfr,uint8_t bit, uint8_t val)
{
	if (val)      // This is for if I want the value to be a 1
      be:	44 23       	and	r20, r20
      c0:	59 f0       	breq	.+22     	; 0xd8 <assign_bit+0x1a>
	{
		val = (val << bit);
      c2:	50 e0       	ldi	r21, 0x00	; 0
      c4:	02 c0       	rjmp	.+4      	; 0xca <assign_bit+0xc>
      c6:	44 0f       	add	r20, r20
      c8:	55 1f       	adc	r21, r21
      ca:	6a 95       	dec	r22
      cc:	e2 f7       	brpl	.-8      	; 0xc6 <assign_bit+0x8>
		*sfr |= val;
      ce:	fc 01       	movw	r30, r24
      d0:	20 81       	ld	r18, Z
      d2:	42 2b       	or	r20, r18
      d4:	40 83       	st	Z, r20
      d6:	08 95       	ret
	}
	else             // This is for if I want the value to be a 0
	{
		val = ~(1 << bit);
      d8:	21 e0       	ldi	r18, 0x01	; 1
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	02 c0       	rjmp	.+4      	; 0xe2 <assign_bit+0x24>
      de:	22 0f       	add	r18, r18
      e0:	33 1f       	adc	r19, r19
      e2:	6a 95       	dec	r22
      e4:	e2 f7       	brpl	.-8      	; 0xde <assign_bit+0x20>
      e6:	20 95       	com	r18
		*sfr &= val;
      e8:	fc 01       	movw	r30, r24
      ea:	30 81       	ld	r19, Z
      ec:	23 23       	and	r18, r19
      ee:	20 83       	st	Z, r18
      f0:	08 95       	ret

000000f2 <Initial>:
 */
void Initial(void)
{
	// First setup the port directions for the PWM lines and the
	// 0 are inputs 1 are outputs
	DDRA = 0b10000000;          // Only PA7 is an output
      f2:	80 e8       	ldi	r24, 0x80	; 128
      f4:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0b11011010;         
      f6:	8a ed       	ldi	r24, 0xDA	; 218
      f8:	87 bb       	out	0x17, r24	; 23
	DDRC = 0xFF;                // Make all outputs
      fa:	8f ef       	ldi	r24, 0xFF	; 255
      fc:	84 bb       	out	0x14, r24	; 20
	DDRD = 0xFF;                // Make all outputs
      fe:	81 bb       	out	0x11, r24	; 17
		
	
	opMode = 0;     // This sets the function mode to heating mode
     100:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <opMode>
	desired_temp = 0;
     104:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <desired_temp>
	duty_cycle = 0.55;    // Experimentally determined duty cycle which is pretty good. 0.53
     108:	8d ec       	ldi	r24, 0xCD	; 205
     10a:	9c ec       	ldi	r25, 0xCC	; 204
     10c:	ac e0       	ldi	r26, 0x0C	; 12
     10e:	bf e3       	ldi	r27, 0x3F	; 63
     110:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <duty_cycle>
     114:	90 93 3d 01 	sts	0x013D, r25	; 0x80013d <duty_cycle+0x1>
     118:	a0 93 3e 01 	sts	0x013E, r26	; 0x80013e <duty_cycle+0x2>
     11c:	b0 93 3f 01 	sts	0x013F, r27	; 0x80013f <duty_cycle+0x3>
	
	// Now calculate the number of pulses I expect per 0.262144 seconds (max time for an 8 bit timer with prescalar of 1024)
	float pulse_flow = (fuelFlow / density) * K_factor * max_time / 1000;
	V_per_pulse = pump_m * (fuelFlow / pulse_flow);
     120:	80 e6       	ldi	r24, 0x60	; 96
     122:	90 ef       	ldi	r25, 0xF0	; 240
     124:	a3 e5       	ldi	r26, 0x53	; 83
     126:	bc e3       	ldi	r27, 0x3C	; 60
     128:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <V_per_pulse>
     12c:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <V_per_pulse+0x1>
     130:	a0 93 38 01 	sts	0x0138, r26	; 0x800138 <V_per_pulse+0x2>
     134:	b0 93 39 01 	sts	0x0139, r27	; 0x800139 <V_per_pulse+0x3>
	desired_pulses = (uint8_t) pulse_flow;                                    // round down and convert to an 8 bit number.  I expect it to be 170 so it will fit.
     138:	8d e8       	ldi	r24, 0x8D	; 141
     13a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <desired_pulses>
	pulse_error_allow = (uint8_t)(desired_pulses * (fuelError / fuelFlow));   // This is the amount of pulses I can be off for it to still be considered a successes
     13e:	83 e0       	ldi	r24, 0x03	; 3
     140:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	assign_bit(&MCUCSR,ISC2,1);                                               // This will cause interrupts for INT2 to be caused on the rising edge
     144:	41 e0       	ldi	r20, 0x01	; 1
     146:	66 e0       	ldi	r22, 0x06	; 6
     148:	84 e5       	ldi	r24, 0x54	; 84
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&GIFR, INTF2, 1);                                              // Make sure the interrupt flag is cleared
     150:	41 e0       	ldi	r20, 0x01	; 1
     152:	65 e0       	ldi	r22, 0x05	; 5
     154:	8a e5       	ldi	r24, 0x5A	; 90
     156:	90 e0       	ldi	r25, 0x00	; 0
     158:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	
	// Configure the ADC
	ADCSRA |= 1 << ADPS2;   // This is so there is a prescalar of 16.  ADC needs frequency between 50-200kHz so 1,000,000/16 puts it in this range.
     15c:	86 b1       	in	r24, 0x06	; 6
     15e:	84 60       	ori	r24, 0x04	; 4
     160:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 1 << ADEN;    // Enable the ADC
     162:	86 b1       	in	r24, 0x06	; 6
     164:	80 68       	ori	r24, 0x80	; 128
     166:	86 b9       	out	0x06, r24	; 6
	ADMUX |= 1 << REFS0;    // Make AVCC (5V) the reference voltage
     168:	87 b1       	in	r24, 0x07	; 7
     16a:	80 64       	ori	r24, 0x40	; 64
     16c:	87 b9       	out	0x07, r24	; 7

	sei();       // This sets the global interrupt flag to allow for hardware interrupts
     16e:	78 94       	sei
	
	// Now enable the timer1 for 0.5 sec
	TIMSK |= 1 << TOIE1;                 // turn on overflow interrupts
     170:	89 b7       	in	r24, 0x39	; 57
     172:	84 60       	ori	r24, 0x04	; 4
     174:	89 bf       	out	0x39, r24	; 57
	TCCR1B |= (1<<CS11);                 // This has a prescalar of 8
     176:	8e b5       	in	r24, 0x2e	; 46
     178:	82 60       	ori	r24, 0x02	; 2
     17a:	8e bd       	out	0x2e, r24	; 46
	TCNT1 = 3036;                        // This will load the value so that when using a prescalar of 8, it will overflow after 500ms
     17c:	8c ed       	ldi	r24, 0xDC	; 220
     17e:	9b e0       	ldi	r25, 0x0B	; 11
     180:	9d bd       	out	0x2d, r25	; 45
     182:	8c bd       	out	0x2c, r24	; 44
	
	saveTemps[0] = -100.0;        // Assign initial temperature values that for sure will be colder than the specified temps 
     184:	e0 e4       	ldi	r30, 0x40	; 64
     186:	f1 e0       	ldi	r31, 0x01	; 1
     188:	80 e0       	ldi	r24, 0x00	; 0
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	a8 ec       	ldi	r26, 0xC8	; 200
     18e:	b2 ec       	ldi	r27, 0xC2	; 194
     190:	80 83       	st	Z, r24
     192:	91 83       	std	Z+1, r25	; 0x01
     194:	a2 83       	std	Z+2, r26	; 0x02
     196:	b3 83       	std	Z+3, r27	; 0x03
	saveTemps[1] = -100.0;
     198:	84 83       	std	Z+4, r24	; 0x04
     19a:	95 83       	std	Z+5, r25	; 0x05
     19c:	a6 83       	std	Z+6, r26	; 0x06
     19e:	b7 83       	std	Z+7, r27	; 0x07
	saveTemps[2] = -100.0;
     1a0:	80 87       	std	Z+8, r24	; 0x08
     1a2:	91 87       	std	Z+9, r25	; 0x09
     1a4:	a2 87       	std	Z+10, r26	; 0x0a
     1a6:	b3 87       	std	Z+11, r27	; 0x0b
	saveTemps[3] = -100.0;
     1a8:	84 87       	std	Z+12, r24	; 0x0c
     1aa:	95 87       	std	Z+13, r25	; 0x0d
     1ac:	a6 87       	std	Z+14, r26	; 0x0e
     1ae:	b7 87       	std	Z+15, r27	; 0x0f
	saveTemps[4] = -100.0;
     1b0:	80 8b       	std	Z+16, r24	; 0x10
     1b2:	91 8b       	std	Z+17, r25	; 0x11
     1b4:	a2 8b       	std	Z+18, r26	; 0x12
     1b6:	b3 8b       	std	Z+19, r27	; 0x13
	saveTemps[5] = -100.0;
     1b8:	84 8b       	std	Z+20, r24	; 0x14
     1ba:	95 8b       	std	Z+21, r25	; 0x15
     1bc:	a6 8b       	std	Z+22, r26	; 0x16
     1be:	b7 8b       	std	Z+23, r27	; 0x17
	saveTemps[6] = -100.0; 
     1c0:	80 8f       	std	Z+24, r24	; 0x18
     1c2:	91 8f       	std	Z+25, r25	; 0x19
     1c4:	a2 8f       	std	Z+26, r26	; 0x1a
     1c6:	b3 8f       	std	Z+27, r27	; 0x1b
	
	// Now I need to turn on all of the heaters as well as set the duty cycles for the PWMs which will be on timers 0 and 2
	// Start with the PWM for the ECU, this will be on timer0
	TCNT0 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
     1c8:	12 be       	out	0x32, r1	; 50
	assign_bit(&TCCR0, WGM01, 1);
     1ca:	41 e0       	ldi	r20, 0x01	; 1
     1cc:	63 e0       	ldi	r22, 0x03	; 3
     1ce:	83 e5       	ldi	r24, 0x53	; 83
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, WGM00, 1);      // These two set the PWM Mode to "Fast PWM"
     1d6:	41 e0       	ldi	r20, 0x01	; 1
     1d8:	66 e0       	ldi	r22, 0x06	; 6
     1da:	83 e5       	ldi	r24, 0x53	; 83
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM01, 1); 
     1e2:	41 e0       	ldi	r20, 0x01	; 1
     1e4:	65 e0       	ldi	r22, 0x05	; 5
     1e6:	83 e5       	ldi	r24, 0x53	; 83
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM00, 1);      // These two set the PWM type to inverting PWM
     1ee:	41 e0       	ldi	r20, 0x01	; 1
     1f0:	64 e0       	ldi	r22, 0x04	; 4
     1f2:	83 e5       	ldi	r24, 0x53	; 83
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	OCR0 = 255 - (255*ECU_duty);       // This will set it to the specified duty by the #define
     1fa:	8f e7       	ldi	r24, 0x7F	; 127
     1fc:	8c bf       	out	0x3c, r24	; 60
	
	TCCR0 |= (1 << CS02);              // This will start the PWM with a duty cycle of 65.536 ms
     1fe:	83 b7       	in	r24, 0x33	; 51
     200:	84 60       	ori	r24, 0x04	; 4
     202:	83 bf       	out	0x33, r24	; 51
	
	// Now do the PWM for the second fuel line which will use Timer 2,  this will look very similar to the last few lines of code
	TCNT2 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
     204:	14 bc       	out	0x24, r1	; 36
	assign_bit(&TCCR2, WGM21, 1);
     206:	41 e0       	ldi	r20, 0x01	; 1
     208:	63 e0       	ldi	r22, 0x03	; 3
     20a:	85 e4       	ldi	r24, 0x45	; 69
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, WGM20, 1);      // These two set the PWM Mode to "Fast PWM"
     212:	41 e0       	ldi	r20, 0x01	; 1
     214:	66 e0       	ldi	r22, 0x06	; 6
     216:	85 e4       	ldi	r24, 0x45	; 69
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM21, 1);
     21e:	41 e0       	ldi	r20, 0x01	; 1
     220:	65 e0       	ldi	r22, 0x05	; 5
     222:	85 e4       	ldi	r24, 0x45	; 69
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM20, 1);      // These two set the PWM type to inverting PWM
     22a:	41 e0       	ldi	r20, 0x01	; 1
     22c:	64 e0       	ldi	r22, 0x04	; 4
     22e:	85 e4       	ldi	r24, 0x45	; 69
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
	OCR2 = 255 - (255*F_line_duty);    // This will set it to the specified duty by the #define
     236:	8c ec       	ldi	r24, 0xCC	; 204
     238:	83 bd       	out	0x23, r24	; 35
		
	TCCR2 |= (1 << CS22);              // This will start the PWM with a duty cycle of 65.536 ms, just like before
     23a:	85 b5       	in	r24, 0x25	; 37
     23c:	84 60       	ori	r24, 0x04	; 4
     23e:	85 bd       	out	0x25, r24	; 37
	
	// Now turn on all the other heaters
	assign_bit(&PORTD, BatPin, 1);
     240:	41 e0       	ldi	r20, 0x01	; 1
     242:	60 e0       	ldi	r22, 0x00	; 0
     244:	82 e3       	ldi	r24, 0x32	; 50
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, HopperPin, 1);
     24c:	41 e0       	ldi	r20, 0x01	; 1
     24e:	61 e0       	ldi	r22, 0x01	; 1
     250:	82 e3       	ldi	r24, 0x32	; 50
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, FLine1Pin, 1);
     258:	41 e0       	ldi	r20, 0x01	; 1
     25a:	62 e0       	ldi	r22, 0x02	; 2
     25c:	82 e3       	ldi	r24, 0x32	; 50
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, ESB_Pin, 1);     // I can omit doing this for the ECU and FuelLine1
     264:	41 e0       	ldi	r20, 0x01	; 1
     266:	63 e0       	ldi	r22, 0x03	; 3
     268:	82 e3       	ldi	r24, 0x32	; 50
     26a:	90 e0       	ldi	r25, 0x00	; 0
     26c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	output_count = 0;
     270:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <output_count+0x1>
     274:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <output_count>
	hand_pwm = 7;     // This means that the fuel line 2 will have a 10 percent 
     278:	87 e0       	ldi	r24, 0x07	; 7
     27a:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <hand_pwm>
	pwm_count = 0;
     27e:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <pwm_count>
     282:	08 95       	ret

00000284 <flowMeter>:
 *  @param void
 *  @return void
 *  @note Need to do a pump test to ensure that the voltage to flow rate function is actually correct.
 */
void flowMeter(void)
{
     284:	cf 92       	push	r12
     286:	df 92       	push	r13
     288:	ef 92       	push	r14
     28a:	ff 92       	push	r15
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
	// First I need to enable interrupt on INT2
	pulse_count = 0;
     294:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <pulse_count>
	GICR |= (1 << INT2);     // enable INT2 external interrupts
     298:	8b b7       	in	r24, 0x3b	; 59
     29a:	80 62       	ori	r24, 0x20	; 32
     29c:	8b bf       	out	0x3b, r24	; 59
	
	
	// Second I need to begin timer0
	TCNT0 = 0;                                 // Make sure the timer/counter register is cleared so the full range can be used
     29e:	12 be       	out	0x32, r1	; 50
	assign_bit(&TIFR,TOV1,1);                  // Make sure the overflow flag is set
     2a0:	41 e0       	ldi	r20, 0x01	; 1
     2a2:	62 e0       	ldi	r22, 0x02	; 2
     2a4:	88 e5       	ldi	r24, 0x58	; 88
     2a6:	90 e0       	ldi	r25, 0x00	; 0
     2a8:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS02,1);
     2ac:	41 e0       	ldi	r20, 0x01	; 1
     2ae:	62 e0       	ldi	r22, 0x02	; 2
     2b0:	83 e5       	ldi	r24, 0x53	; 83
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS01,0);
     2b8:	40 e0       	ldi	r20, 0x00	; 0
     2ba:	61 e0       	ldi	r22, 0x01	; 1
     2bc:	83 e5       	ldi	r24, 0x53	; 83
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS00,1);                 // TThis will start the timer with a prescalar of 1024
     2c4:	41 e0       	ldi	r20, 0x01	; 1
     2c6:	60 e0       	ldi	r22, 0x00	; 0
     2c8:	83 e5       	ldi	r24, 0x53	; 83
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	while (!(TIFR & 0x01));                    // Hog the execution until the overflow flag is set
     2d0:	08 b6       	in	r0, 0x38	; 56
     2d2:	00 fe       	sbrs	r0, 0
     2d4:	fd cf       	rjmp	.-6      	; 0x2d0 <flowMeter+0x4c>
	
	assign_bit(&GICR, INT2, 0);                // disable external interrupts for INT2
     2d6:	40 e0       	ldi	r20, 0x00	; 0
     2d8:	65 e0       	ldi	r22, 0x05	; 5
     2da:	8b e5       	ldi	r24, 0x5B	; 91
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	pump_count--;
     2e2:	c0 91 33 01 	lds	r28, 0x0133	; 0x800133 <pump_count>
     2e6:	c1 50       	subi	r28, 0x01	; 1
     2e8:	c0 93 33 01 	sts	0x0133, r28	; 0x800133 <pump_count>
	
	int8_t pulse_error = desired_pulses - pulse_count;   // This will be able to handle negative numbers
     2ec:	10 91 90 00 	lds	r17, 0x0090	; 0x800090 <pulse_count>
     2f0:	d0 91 31 01 	lds	r29, 0x0131	; 0x800131 <desired_pulses>
     2f4:	d1 1b       	sub	r29, r17
     2f6:	0d 2f       	mov	r16, r29
	measured_flow = V_per_pulse * (float) pulse_count;
     2f8:	61 2f       	mov	r22, r17
     2fa:	70 e0       	ldi	r23, 0x00	; 0
     2fc:	80 e0       	ldi	r24, 0x00	; 0
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	0e 94 f3 06 	call	0xde6	; 0xde6 <__floatunsisf>
     304:	c0 90 36 01 	lds	r12, 0x0136	; 0x800136 <V_per_pulse>
     308:	d0 90 37 01 	lds	r13, 0x0137	; 0x800137 <V_per_pulse+0x1>
     30c:	e0 90 38 01 	lds	r14, 0x0138	; 0x800138 <V_per_pulse+0x2>
     310:	f0 90 39 01 	lds	r15, 0x0139	; 0x800139 <V_per_pulse+0x3>
     314:	a7 01       	movw	r20, r14
     316:	96 01       	movw	r18, r12
     318:	0e 94 aa 07 	call	0xf54	; 0xf54 <__mulsf3>
	measured_flow = measured_flow / pump_m;
     31c:	21 e7       	ldi	r18, 0x71	; 113
     31e:	32 ee       	ldi	r19, 0xE2	; 226
     320:	43 ec       	ldi	r20, 0xC3	; 195
     322:	5e e3       	ldi	r21, 0x3E	; 62
     324:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     328:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <measured_flow>
     32c:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <measured_flow+0x1>
     330:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <measured_flow+0x2>
     334:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <measured_flow+0x3>
	flow_save[pump_count] = measured_flow;
     338:	2c 2f       	mov	r18, r28
     33a:	30 e0       	ldi	r19, 0x00	; 0
     33c:	f9 01       	movw	r30, r18
     33e:	ee 0f       	add	r30, r30
     340:	ff 1f       	adc	r31, r31
     342:	ee 0f       	add	r30, r30
     344:	ff 1f       	adc	r31, r31
     346:	ef 56       	subi	r30, 0x6F	; 111
     348:	ff 4f       	sbci	r31, 0xFF	; 255
     34a:	60 83       	st	Z, r22
     34c:	71 83       	std	Z+1, r23	; 0x01
     34e:	82 83       	std	Z+2, r24	; 0x02
     350:	93 83       	std	Z+3, r25	; 0x03
	pulse_count_array[pump_count] = pulse_count;
     352:	f9 01       	movw	r30, r18
     354:	e8 59       	subi	r30, 0x98	; 152
     356:	ff 4f       	sbci	r31, 0xFF	; 255
     358:	10 83       	st	Z, r17


	
	if (pump_lock){     // decrease the pump lock by one. 
     35a:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <pump_lock>
     35e:	88 23       	and	r24, r24
     360:	21 f0       	breq	.+8      	; 0x36a <flowMeter+0xe6>
		pump_lock--;
     362:	81 50       	subi	r24, 0x01	; 1
     364:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <pump_lock>
     368:	a5 c0       	rjmp	.+330    	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
	}
	else if ((!pump_count))                          // There is either no more fuel or there is a stoppage.  This if statement might be the end of me...
     36a:	c1 11       	cpse	r28, r1
     36c:	5e c0       	rjmp	.+188    	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
	{
		assign_bit(&TCCR1B, CS10, 0);          // This should stop the PWM for the pump
     36e:	40 e0       	ldi	r20, 0x00	; 0
     370:	60 e0       	ldi	r22, 0x00	; 0
     372:	8e e4       	ldi	r24, 0x4E	; 78
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR1B, WGM12, 0);
     37a:	40 e0       	ldi	r20, 0x00	; 0
     37c:	63 e0       	ldi	r22, 0x03	; 3
     37e:	8e e4       	ldi	r24, 0x4E	; 78
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR1B, WGM13, 0);
     386:	40 e0       	ldi	r20, 0x00	; 0
     388:	64 e0       	ldi	r22, 0x04	; 4
     38a:	8e e4       	ldi	r24, 0x4E	; 78
     38c:	90 e0       	ldi	r25, 0x00	; 0
     38e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR1A, COM1B1, 0);
     392:	40 e0       	ldi	r20, 0x00	; 0
     394:	65 e0       	ldi	r22, 0x05	; 5
     396:	8f e4       	ldi	r24, 0x4F	; 79
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR1A, COM1B0, 0);
     39e:	40 e0       	ldi	r20, 0x00	; 0
     3a0:	64 e0       	ldi	r22, 0x04	; 4
     3a2:	8f e4       	ldi	r24, 0x4F	; 79
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>


		assign_bit(&PORTD, PD4, 0);            // This will drive the state of the pin low
     3aa:	40 e0       	ldi	r20, 0x00	; 0
     3ac:	64 e0       	ldi	r22, 0x04	; 4
     3ae:	82 e3       	ldi	r24, 0x32	; 50
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD, Fuel_LED, 1);
     3b6:	41 e0       	ldi	r20, 0x01	; 1
     3b8:	66 e0       	ldi	r22, 0x06	; 6
     3ba:	82 e3       	ldi	r24, 0x32	; 50
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCNT2 = 60;                               // Value needed for the timer to run for 0.05 second
     3c2:	8c e3       	ldi	r24, 0x3C	; 60
     3c4:	84 bd       	out	0x24, r24	; 36
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
     3c6:	41 e0       	ldi	r20, 0x01	; 1
     3c8:	65 e0       	ldi	r22, 0x05	; 5
     3ca:	82 e3       	ldi	r24, 0x32	; 50
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		alive_counter = 0;                        // reset the hand made prescalar
     3d2:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
		TCCR2 = 0x06;                             // This will start the Timer with a prescalar of 256 and stop the PWM stuff
     3d6:	86 e0       	ldi	r24, 0x06	; 6
     3d8:	85 bd       	out	0x25, r24	; 37
		
		// Now need to turn off all of the heaters real quick
		assign_bit(&PORTD,PD0,0);
     3da:	40 e0       	ldi	r20, 0x00	; 0
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	82 e3       	ldi	r24, 0x32	; 50
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD,PD1,0);
     3e6:	40 e0       	ldi	r20, 0x00	; 0
     3e8:	61 e0       	ldi	r22, 0x01	; 1
     3ea:	82 e3       	ldi	r24, 0x32	; 50
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD,PD2,0);
     3f2:	40 e0       	ldi	r20, 0x00	; 0
     3f4:	62 e0       	ldi	r22, 0x02	; 2
     3f6:	82 e3       	ldi	r24, 0x32	; 50
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD,PD3,0);
     3fe:	40 e0       	ldi	r20, 0x00	; 0
     400:	63 e0       	ldi	r22, 0x03	; 3
     402:	82 e3       	ldi	r24, 0x32	; 50
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD,PD7,0);
     40a:	40 e0       	ldi	r20, 0x00	; 0
     40c:	67 e0       	ldi	r22, 0x07	; 7
     40e:	82 e3       	ldi	r24, 0x32	; 50
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTB,PB3,0);
     416:	40 e0       	ldi	r20, 0x00	; 0
     418:	63 e0       	ldi	r22, 0x03	; 3
     41a:	88 e3       	ldi	r24, 0x38	; 56
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		opMode = 2;    // this is when I can view the flow data
     422:	82 e0       	ldi	r24, 0x02	; 2
     424:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
     428:	45 c0       	rjmp	.+138    	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
		
	}
	else
	{
		// Now I need to compare the number of pulses I got with what I should have received
		float change = (float) pulse_error * V_per_pulse * ((float) ICR1) / pump_tot_V;   // Check page 94 in notebook for correct derivation.
     42a:	6d 2f       	mov	r22, r29
     42c:	0d 2e       	mov	r0, r29
     42e:	00 0c       	add	r0, r0
     430:	77 0b       	sbc	r23, r23
     432:	88 0b       	sbc	r24, r24
     434:	99 0b       	sbc	r25, r25
     436:	0e 94 f5 06 	call	0xdea	; 0xdea <__floatsisf>
     43a:	9b 01       	movw	r18, r22
     43c:	ac 01       	movw	r20, r24
     43e:	c7 01       	movw	r24, r14
     440:	b6 01       	movw	r22, r12
     442:	0e 94 aa 07 	call	0xf54	; 0xf54 <__mulsf3>
     446:	6b 01       	movw	r12, r22
     448:	7c 01       	movw	r14, r24
     44a:	66 b5       	in	r22, 0x26	; 38
     44c:	77 b5       	in	r23, 0x27	; 39
     44e:	80 e0       	ldi	r24, 0x00	; 0
     450:	90 e0       	ldi	r25, 0x00	; 0
     452:	0e 94 f3 06 	call	0xde6	; 0xde6 <__floatunsisf>
     456:	9b 01       	movw	r18, r22
     458:	ac 01       	movw	r20, r24
     45a:	c7 01       	movw	r24, r14
     45c:	b6 01       	movw	r22, r12
     45e:	0e 94 aa 07 	call	0xf54	; 0xf54 <__mulsf3>
     462:	24 ea       	ldi	r18, 0xA4	; 164
     464:	30 e7       	ldi	r19, 0x70	; 112
     466:	4d ec       	ldi	r20, 0xCD	; 205
     468:	50 e4       	ldi	r21, 0x40	; 64
     46a:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
		OCR1B -= (uint16_t) (change / 3.0);   // the larger the number, the slower it is to respond, but the less overshoot it has
     46e:	e8 b4       	in	r14, 0x28	; 40
     470:	f9 b4       	in	r15, 0x29	; 41
     472:	20 e0       	ldi	r18, 0x00	; 0
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	40 e4       	ldi	r20, 0x40	; 64
     478:	50 e4       	ldi	r21, 0x40	; 64
     47a:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     47e:	0e 94 c4 06 	call	0xd88	; 0xd88 <__fixunssfsi>
     482:	e6 1a       	sub	r14, r22
     484:	f7 0a       	sbc	r15, r23
     486:	f9 bc       	out	0x29, r15	; 41
     488:	e8 bc       	out	0x28, r14	; 40
		// The above line should immediately change the PWM as well
		
		if (pulse_error < 0)
     48a:	dd 23       	and	r29, r29
     48c:	14 f4       	brge	.+4      	; 0x492 <__LOCK_REGION_LENGTH__+0x92>
			pulse_error = -pulse_error;          // Make it the absolute value 
     48e:	0d 2f       	mov	r16, r29
     490:	01 95       	neg	r16
		if (pulse_error <= pulse_error_allow)    // mission is a success
     492:	80 2f       	mov	r24, r16
     494:	00 0f       	add	r16, r16
     496:	99 0b       	sbc	r25, r25
     498:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <_edata>
     49c:	30 e0       	ldi	r19, 0x00	; 0
     49e:	28 17       	cp	r18, r24
     4a0:	39 07       	cpc	r19, r25
     4a2:	24 f0       	brlt	.+8      	; 0x4ac <__LOCK_REGION_LENGTH__+0xac>
			PORTD |= (1 << Fuel_LED);            // Make the fuel LED just stay on
     4a4:	82 b3       	in	r24, 0x12	; 18
     4a6:	80 64       	ori	r24, 0x40	; 64
     4a8:	82 bb       	out	0x12, r24	; 18
     4aa:	04 c0       	rjmp	.+8      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
		else
			PORTD ^= (1 << Fuel_LED);            // Make the fuel LED blink saying that it is not done yet.
     4ac:	92 b3       	in	r25, 0x12	; 18
     4ae:	80 e4       	ldi	r24, 0x40	; 64
     4b0:	89 27       	eor	r24, r25
     4b2:	82 bb       	out	0x12, r24	; 18
	}
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	1f 91       	pop	r17
     4ba:	0f 91       	pop	r16
     4bc:	ff 90       	pop	r15
     4be:	ef 90       	pop	r14
     4c0:	df 90       	pop	r13
     4c2:	cf 90       	pop	r12
     4c4:	08 95       	ret

000004c6 <ECU_toggle>:
 *  @param[in] ECU_mode This variable denote which mode the system is configured in. 0 for dummy ECU, 1 for operational ECU
 *  @return void
 */
void ECU_toggle(uint8_t ECU_mode)
{
	assign_bit(&PORTA, ECUon_Pin, ECU_mode);   // make sure the ECU has its power circuit closed if it is an operational ECU
     4c6:	48 2f       	mov	r20, r24
     4c8:	67 e0       	ldi	r22, 0x07	; 7
     4ca:	8b e3       	ldi	r24, 0x3B	; 59
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     4d2:	08 95       	ret

000004d4 <change_timers>:
 *  @param void
 *  @return void
 *  @see flowMeter
 */
void change_timers(void)
{
     4d4:	cf 93       	push	r28
     4d6:	df 93       	push	r29
	opMode = 1;                          // Change the operational mode
     4d8:	81 e0       	ldi	r24, 0x01	; 1
     4da:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
	assign_bit(&PORTB,Warm_LED,1);    // Turn on the LED to signal the heating sequence is complete
     4de:	41 e0       	ldi	r20, 0x01	; 1
     4e0:	61 e0       	ldi	r22, 0x01	; 1
     4e2:	88 e3       	ldi	r24, 0x38	; 56
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	pump_count = 39;   // this was 39, was 44
     4ea:	87 e2       	ldi	r24, 0x27	; 39
     4ec:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <pump_count>
	ECU_toggle(ECU_present);
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	0e 94 63 02 	call	0x4c6	; 0x4c6 <ECU_toggle>
	// Now need to assign timer 2 to the alive LED
	
	if (!ECU_present)
	{
		// First change Timer 1 to serve as the PWM output port for the pump
		assign_bit(&TIMSK,TOIE1,0);    // remove overflow interrupts for timer 1
     4f6:	40 e0       	ldi	r20, 0x00	; 0
     4f8:	62 e0       	ldi	r22, 0x02	; 2
     4fa:	89 e5       	ldi	r24, 0x59	; 89
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR1B, CS11, 0);  // need to do this so that the prescalar will be set to 1 later
     502:	40 e0       	ldi	r20, 0x00	; 0
     504:	61 e0       	ldi	r22, 0x01	; 1
     506:	8e e4       	ldi	r24, 0x4E	; 78
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCCR1A |= (1 << WGM11);     // The sets one of the bits for the mode 14 waveform
     50e:	8f b5       	in	r24, 0x2f	; 47
     510:	82 60       	ori	r24, 0x02	; 2
     512:	8f bd       	out	0x2f, r24	; 47
		TCCR1B |= (1 << WGM12) | (1 << WGM13);   // This sets the other two bits for the waveform generation
     514:	8e b5       	in	r24, 0x2e	; 46
     516:	88 61       	ori	r24, 0x18	; 24
     518:	8e bd       	out	0x2e, r24	; 46
		TCCR1A |= (1 << COM1B1) | (1 << COM1B0);   // These set the output mode
     51a:	8f b5       	in	r24, 0x2f	; 47
     51c:	80 63       	ori	r24, 0x30	; 48
     51e:	8f bd       	out	0x2f, r24	; 47
		ICR1 = 1000;     // this will set the period of oscillation to 10ms This is exactly 100 Hz on the o-scope.
     520:	88 ee       	ldi	r24, 0xE8	; 232
     522:	93 e0       	ldi	r25, 0x03	; 3
     524:	97 bd       	out	0x27, r25	; 39
     526:	86 bd       	out	0x26, r24	; 38
		// This seems to cause the motor to operate smoothly even though the voltage across the pump oscillates much more
			
		OCR1B = ICR1 - (int)(ICR1*duty_cycle);     // This will set the count at which the PWM will change to on. Also make sure to round down to int
     528:	c6 b5       	in	r28, 0x26	; 38
     52a:	d7 b5       	in	r29, 0x27	; 39
     52c:	66 b5       	in	r22, 0x26	; 38
     52e:	77 b5       	in	r23, 0x27	; 39
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	0e 94 f3 06 	call	0xde6	; 0xde6 <__floatunsisf>
     538:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <duty_cycle>
     53c:	30 91 3d 01 	lds	r19, 0x013D	; 0x80013d <duty_cycle+0x1>
     540:	40 91 3e 01 	lds	r20, 0x013E	; 0x80013e <duty_cycle+0x2>
     544:	50 91 3f 01 	lds	r21, 0x013F	; 0x80013f <duty_cycle+0x3>
     548:	0e 94 aa 07 	call	0xf54	; 0xf54 <__mulsf3>
     54c:	0e 94 bd 06 	call	0xd7a	; 0xd7a <__fixsfsi>
     550:	c6 1b       	sub	r28, r22
     552:	d7 0b       	sbc	r29, r23
     554:	d9 bd       	out	0x29, r29	; 41
     556:	c8 bd       	out	0x28, r28	; 40
		assign_bit(&TCCR1B, CS10, 1);              // This should start the PWM with a prescalar of 1
     558:	41 e0       	ldi	r20, 0x01	; 1
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	8e e4       	ldi	r24, 0x4E	; 78
     55e:	90 e0       	ldi	r25, 0x00	; 0
     560:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		pump_lock = 5;                             // This should lock the pump at the starting duty for 2 second
     564:	85 e0       	ldi	r24, 0x05	; 5
     566:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <pump_lock>
		// Now the PWM should be running
			
		// Second change Timer0 to serve as the counter for the pulse train from the flow meter
		TCCR0 = 0;                                 // Turn off the PWM so the ECU stops being warmed
     56a:	13 be       	out	0x33, r1	; 51
		assign_bit(&TCCR0,CS02,0);
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	62 e0       	ldi	r22, 0x02	; 2
     570:	83 e5       	ldi	r24, 0x53	; 83
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS01,0);
     578:	40 e0       	ldi	r20, 0x00	; 0
     57a:	61 e0       	ldi	r22, 0x01	; 1
     57c:	83 e5       	ldi	r24, 0x53	; 83
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS00,0);                 // TThis will make sure that the timer is stopped for now	
     584:	40 e0       	ldi	r20, 0x00	; 0
     586:	60 e0       	ldi	r22, 0x00	; 0
     588:	83 e5       	ldi	r24, 0x53	; 83
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		// Third set the MCU Control and Status Register for the Interrupt Sense Control 2
		MCUCSR |= (1 << ISC2);                    // This will make interrupts occur on the rising edge, so the beginning of the pulse
     590:	84 b7       	in	r24, 0x34	; 52
     592:	80 64       	ori	r24, 0x40	; 64
     594:	84 bf       	out	0x34, r24	; 52
		
		// Fourth set Timer2 for the 0.75/0.25 second blink of the Alive LED
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
     596:	41 e0       	ldi	r20, 0x01	; 1
     598:	65 e0       	ldi	r22, 0x05	; 5
     59a:	82 e3       	ldi	r24, 0x32	; 50
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TIMSK |= (1 << TOIE2);                    // Enable overflow interrupts on the timer
     5a2:	89 b7       	in	r24, 0x39	; 57
     5a4:	80 64       	ori	r24, 0x40	; 64
     5a6:	89 bf       	out	0x39, r24	; 57
		TCNT2 = 11;                               // This is the value needed for the timer to run for 0.25 seconds
     5a8:	8b e0       	ldi	r24, 0x0B	; 11
     5aa:	84 bd       	out	0x24, r24	; 36
		alive_counter = 0;                        // Reset the hand made prescalar
     5ac:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
		TCCR2 = 0x07;                             // Start the timer with a prescalar of 1024
     5b0:	87 e0       	ldi	r24, 0x07	; 7
     5b2:	85 bd       	out	0x25, r24	; 37
		TCCR0 = 0;
		TCCR1B = 0;         // This set is to prevent any unexpected triggering of the heating circuits
		TCCR1A = 0;
		
	}
}
     5b4:	df 91       	pop	r29
     5b6:	cf 91       	pop	r28
     5b8:	08 95       	ret

000005ba <tempHeaterHelper>:
 *  @return void
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
     5ba:	cf 92       	push	r12
     5bc:	df 92       	push	r13
     5be:	ef 92       	push	r14
     5c0:	ff 92       	push	r15
     5c2:	cf 93       	push	r28
	for (uint8_t i = 0; i < 6; i++)
     5c4:	c0 e0       	ldi	r28, 0x00	; 0
     5c6:	b2 c1       	rjmp	.+868    	; 0x92c <__stack+0xcd>
	{
		switch(i){
     5c8:	c2 30       	cpi	r28, 0x02	; 2
     5ca:	09 f4       	brne	.+2      	; 0x5ce <tempHeaterHelper+0x14>
     5cc:	6f c0       	rjmp	.+222    	; 0x6ac <tempHeaterHelper+0xf2>
     5ce:	28 f4       	brcc	.+10     	; 0x5da <tempHeaterHelper+0x20>
     5d0:	cc 23       	and	r28, r28
     5d2:	61 f0       	breq	.+24     	; 0x5ec <tempHeaterHelper+0x32>
     5d4:	c1 30       	cpi	r28, 0x01	; 1
     5d6:	d1 f1       	breq	.+116    	; 0x64c <tempHeaterHelper+0x92>
     5d8:	a8 c1       	rjmp	.+848    	; 0x92a <__stack+0xcb>
     5da:	c4 30       	cpi	r28, 0x04	; 4
     5dc:	09 f4       	brne	.+2      	; 0x5e0 <tempHeaterHelper+0x26>
     5de:	0a c1       	rjmp	.+532    	; 0x7f4 <tempHeaterHelper+0x23a>
     5e0:	08 f4       	brcc	.+2      	; 0x5e4 <tempHeaterHelper+0x2a>
     5e2:	d8 c0       	rjmp	.+432    	; 0x794 <tempHeaterHelper+0x1da>
     5e4:	c5 30       	cpi	r28, 0x05	; 5
     5e6:	09 f4       	brne	.+2      	; 0x5ea <tempHeaterHelper+0x30>
     5e8:	72 c1       	rjmp	.+740    	; 0x8ce <__stack+0x6f>
     5ea:	9f c1       	rjmp	.+830    	; 0x92a <__stack+0xcb>
			case 0:                             // This is the case for the Lipo batteries   //////////////////////////////////////////////
				if (saveTemps[0] > TempBat )    // safety first so make sure that the temperature always turns off if one of the batteries is getting too hot
     5ec:	c0 90 40 01 	lds	r12, 0x0140	; 0x800140 <saveTemps>
     5f0:	d0 90 41 01 	lds	r13, 0x0141	; 0x800141 <saveTemps+0x1>
     5f4:	e0 90 42 01 	lds	r14, 0x0142	; 0x800142 <saveTemps+0x2>
     5f8:	f0 90 43 01 	lds	r15, 0x0143	; 0x800143 <saveTemps+0x3>
     5fc:	20 e0       	ldi	r18, 0x00	; 0
     5fe:	30 e0       	ldi	r19, 0x00	; 0
     600:	40 e2       	ldi	r20, 0x20	; 32
     602:	51 e4       	ldi	r21, 0x41	; 65
     604:	c7 01       	movw	r24, r14
     606:	b6 01       	movw	r22, r12
     608:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__gesf2>
     60c:	18 16       	cp	r1, r24
     60e:	64 f4       	brge	.+24     	; 0x628 <tempHeaterHelper+0x6e>
				{
					desired_temp |= 0x01;
     610:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     614:	81 60       	ori	r24, 0x01	; 1
     616:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
					assign_bit(&PORTD, BatPin, 0);       // Turn the heater off if either of these get too high
     61a:	40 e0       	ldi	r20, 0x00	; 0
     61c:	60 e0       	ldi	r22, 0x00	; 0
     61e:	82 e3       	ldi	r24, 0x32	; 50
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     626:	81 c1       	rjmp	.+770    	; 0x92a <__stack+0xcb>
				}
				else if(saveTemps[0] < TempBat)
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	40 e2       	ldi	r20, 0x20	; 32
     62e:	51 e4       	ldi	r21, 0x41	; 65
     630:	c7 01       	movw	r24, r14
     632:	b6 01       	movw	r22, r12
     634:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
     638:	88 23       	and	r24, r24
     63a:	0c f0       	brlt	.+2      	; 0x63e <tempHeaterHelper+0x84>
     63c:	76 c1       	rjmp	.+748    	; 0x92a <__stack+0xcb>
				{
					assign_bit(&PORTD, BatPin, 1);    // Turn the heater back on to warm them up
     63e:	41 e0       	ldi	r20, 0x01	; 1
     640:	60 e0       	ldi	r22, 0x00	; 0
     642:	82 e3       	ldi	r24, 0x32	; 50
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     64a:	6f c1       	rjmp	.+734    	; 0x92a <__stack+0xcb>
				}
				break;
				
			case 1:       // This is the case for the Hopper    /////////////////////////////////////////////////
				if (saveTemps[1] < TempHopper)           // Temp is too low so turn on the heater
     64c:	c0 90 44 01 	lds	r12, 0x0144	; 0x800144 <saveTemps+0x4>
     650:	d0 90 45 01 	lds	r13, 0x0145	; 0x800145 <saveTemps+0x5>
     654:	e0 90 46 01 	lds	r14, 0x0146	; 0x800146 <saveTemps+0x6>
     658:	f0 90 47 01 	lds	r15, 0x0147	; 0x800147 <saveTemps+0x7>
     65c:	20 e0       	ldi	r18, 0x00	; 0
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	40 e2       	ldi	r20, 0x20	; 32
     662:	51 e4       	ldi	r21, 0x41	; 65
     664:	c7 01       	movw	r24, r14
     666:	b6 01       	movw	r22, r12
     668:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
     66c:	88 23       	and	r24, r24
     66e:	3c f4       	brge	.+14     	; 0x67e <tempHeaterHelper+0xc4>
					assign_bit(&PORTD, HopperPin, 1);
     670:	41 e0       	ldi	r20, 0x01	; 1
     672:	61 e0       	ldi	r22, 0x01	; 1
     674:	82 e3       	ldi	r24, 0x32	; 50
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     67c:	56 c1       	rjmp	.+684    	; 0x92a <__stack+0xcb>
				else if(saveTemps[1] > TempHopper)
     67e:	20 e0       	ldi	r18, 0x00	; 0
     680:	30 e0       	ldi	r19, 0x00	; 0
     682:	40 e2       	ldi	r20, 0x20	; 32
     684:	51 e4       	ldi	r21, 0x41	; 65
     686:	c7 01       	movw	r24, r14
     688:	b6 01       	movw	r22, r12
     68a:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__gesf2>
     68e:	18 16       	cp	r1, r24
     690:	0c f0       	brlt	.+2      	; 0x694 <tempHeaterHelper+0xda>
     692:	4b c1       	rjmp	.+662    	; 0x92a <__stack+0xcb>
				{
					assign_bit(&PORTD, HopperPin, 0);    // Too hot so turn off
     694:	40 e0       	ldi	r20, 0x00	; 0
     696:	61 e0       	ldi	r22, 0x01	; 1
     698:	82 e3       	ldi	r24, 0x32	; 50
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x02;				
     6a0:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     6a4:	82 60       	ori	r24, 0x02	; 2
     6a6:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
     6aa:	3f c1       	rjmp	.+638    	; 0x92a <__stack+0xcb>
				}
				break;
				
			case 2:       // This is the case for the ECU  /////////////////////////////////////////////////
				if (saveTemps[2] < TempECU){
     6ac:	c0 90 48 01 	lds	r12, 0x0148	; 0x800148 <saveTemps+0x8>
     6b0:	d0 90 49 01 	lds	r13, 0x0149	; 0x800149 <saveTemps+0x9>
     6b4:	e0 90 4a 01 	lds	r14, 0x014A	; 0x80014a <saveTemps+0xa>
     6b8:	f0 90 4b 01 	lds	r15, 0x014B	; 0x80014b <saveTemps+0xb>
     6bc:	20 e0       	ldi	r18, 0x00	; 0
     6be:	30 e0       	ldi	r19, 0x00	; 0
     6c0:	40 e2       	ldi	r20, 0x20	; 32
     6c2:	51 e4       	ldi	r21, 0x41	; 65
     6c4:	c7 01       	movw	r24, r14
     6c6:	b6 01       	movw	r22, r12
     6c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
     6cc:	88 23       	and	r24, r24
     6ce:	74 f5       	brge	.+92     	; 0x72c <tempHeaterHelper+0x172>
					if (!opMode){
     6d0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     6d4:	81 11       	cpse	r24, r1
     6d6:	13 c0       	rjmp	.+38     	; 0x6fe <tempHeaterHelper+0x144>
						assign_bit(&TCCR0, COM01, 1);
     6d8:	41 e0       	ldi	r20, 0x01	; 1
     6da:	65 e0       	ldi	r22, 0x05	; 5
     6dc:	83 e5       	ldi	r24, 0x53	; 83
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&TCCR0, COM00, 1);    // give the PWM its output pin back
     6e4:	41 e0       	ldi	r20, 0x01	; 1
     6e6:	64 e0       	ldi	r22, 0x04	; 4
     6e8:	83 e5       	ldi	r24, 0x53	; 83
     6ea:	90 e0       	ldi	r25, 0x00	; 0
     6ec:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&TCCR0, CS02, 1);      // This will turn the PWM back on
     6f0:	41 e0       	ldi	r20, 0x01	; 1
     6f2:	62 e0       	ldi	r22, 0x02	; 2
     6f4:	83 e5       	ldi	r24, 0x53	; 83
     6f6:	90 e0       	ldi	r25, 0x00	; 0
     6f8:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     6fc:	16 c1       	rjmp	.+556    	; 0x92a <__stack+0xcb>

					}
					else if (opMode == 2){
     6fe:	82 30       	cpi	r24, 0x02	; 2
     700:	09 f0       	breq	.+2      	; 0x704 <tempHeaterHelper+0x14a>
     702:	13 c1       	rjmp	.+550    	; 0x92a <__stack+0xcb>
						// I need to implement the 10% DS
						if (pwm_count == hand_pwm){
     704:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <pwm_count>
     708:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <hand_pwm>
     70c:	98 13       	cpse	r25, r24
     70e:	07 c0       	rjmp	.+14     	; 0x71e <tempHeaterHelper+0x164>
							assign_bit(&PORTB,ECU_pin,1);   // turn it on for the one count
     710:	41 e0       	ldi	r20, 0x01	; 1
     712:	63 e0       	ldi	r22, 0x03	; 3
     714:	88 e3       	ldi	r24, 0x38	; 56
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     71c:	06 c1       	rjmp	.+524    	; 0x92a <__stack+0xcb>
						}
						else{
							assign_bit(&PORTB, ECU_pin,0);  // turn it off otherwise
     71e:	40 e0       	ldi	r20, 0x00	; 0
     720:	63 e0       	ldi	r22, 0x03	; 3
     722:	88 e3       	ldi	r24, 0x38	; 56
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     72a:	ff c0       	rjmp	.+510    	; 0x92a <__stack+0xcb>
						}
					}
				}
				else if (saveTemps[2] > TempECU)
     72c:	20 e0       	ldi	r18, 0x00	; 0
     72e:	30 e0       	ldi	r19, 0x00	; 0
     730:	40 e2       	ldi	r20, 0x20	; 32
     732:	51 e4       	ldi	r21, 0x41	; 65
     734:	c7 01       	movw	r24, r14
     736:	b6 01       	movw	r22, r12
     738:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__gesf2>
     73c:	18 16       	cp	r1, r24
     73e:	0c f0       	brlt	.+2      	; 0x742 <tempHeaterHelper+0x188>
     740:	f4 c0       	rjmp	.+488    	; 0x92a <__stack+0xcb>
				{
					if (opMode != 1)
     742:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     746:	81 30       	cpi	r24, 0x01	; 1
     748:	f1 f0       	breq	.+60     	; 0x786 <tempHeaterHelper+0x1cc>
					{
						assign_bit(&TCCR0, CS02, 0);      // This will turn the PWM off
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	62 e0       	ldi	r22, 0x02	; 2
     74e:	83 e5       	ldi	r24, 0x53	; 83
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						// now force the PWM module off of the pin
						assign_bit(&TCCR0, COM01, 0);
     756:	40 e0       	ldi	r20, 0x00	; 0
     758:	65 e0       	ldi	r22, 0x05	; 5
     75a:	83 e5       	ldi	r24, 0x53	; 83
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&TCCR0, COM00, 0);
     762:	40 e0       	ldi	r20, 0x00	; 0
     764:	64 e0       	ldi	r22, 0x04	; 4
     766:	83 e5       	ldi	r24, 0x53	; 83
     768:	90 e0       	ldi	r25, 0x00	; 0
     76a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&PORTB,ECU_pin,0);     // and force the pin low
     76e:	40 e0       	ldi	r20, 0x00	; 0
     770:	63 e0       	ldi	r22, 0x03	; 3
     772:	88 e3       	ldi	r24, 0x38	; 56
     774:	90 e0       	ldi	r25, 0x00	; 0
     776:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x04;
     77a:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     77e:	84 60       	ori	r24, 0x04	; 4
     780:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
     784:	d2 c0       	rjmp	.+420    	; 0x92a <__stack+0xcb>
					}
					else{
						assign_bit(&PORTB,ECU_pin,0);    // drive the pin low if it is too high
     786:	40 e0       	ldi	r20, 0x00	; 0
     788:	63 e0       	ldi	r22, 0x03	; 3
     78a:	88 e3       	ldi	r24, 0x38	; 56
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     792:	cb c0       	rjmp	.+406    	; 0x92a <__stack+0xcb>
					}
				}
				break;
				
			case 3:       // This is the case for Fuel Line 1  /////////////////////////////////////////////////
				if (saveTemps[3] < TempFLine1)
     794:	c0 90 4c 01 	lds	r12, 0x014C	; 0x80014c <saveTemps+0xc>
     798:	d0 90 4d 01 	lds	r13, 0x014D	; 0x80014d <saveTemps+0xd>
     79c:	e0 90 4e 01 	lds	r14, 0x014E	; 0x80014e <saveTemps+0xe>
     7a0:	f0 90 4f 01 	lds	r15, 0x014F	; 0x80014f <saveTemps+0xf>
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	40 e2       	ldi	r20, 0x20	; 32
     7aa:	51 e4       	ldi	r21, 0x41	; 65
     7ac:	c7 01       	movw	r24, r14
     7ae:	b6 01       	movw	r22, r12
     7b0:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
     7b4:	88 23       	and	r24, r24
     7b6:	3c f4       	brge	.+14     	; 0x7c6 <tempHeaterHelper+0x20c>
					assign_bit(&PORTD, FLine1Pin, 1);
     7b8:	41 e0       	ldi	r20, 0x01	; 1
     7ba:	62 e0       	ldi	r22, 0x02	; 2
     7bc:	82 e3       	ldi	r24, 0x32	; 50
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     7c4:	b2 c0       	rjmp	.+356    	; 0x92a <__stack+0xcb>
				else if(saveTemps[3] > TempFLine1)
     7c6:	20 e0       	ldi	r18, 0x00	; 0
     7c8:	30 e0       	ldi	r19, 0x00	; 0
     7ca:	40 e2       	ldi	r20, 0x20	; 32
     7cc:	51 e4       	ldi	r21, 0x41	; 65
     7ce:	c7 01       	movw	r24, r14
     7d0:	b6 01       	movw	r22, r12
     7d2:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__gesf2>
     7d6:	18 16       	cp	r1, r24
     7d8:	0c f0       	brlt	.+2      	; 0x7dc <tempHeaterHelper+0x222>
     7da:	a7 c0       	rjmp	.+334    	; 0x92a <__stack+0xcb>
				{
					assign_bit(&PORTD, FLine1Pin, 0);
     7dc:	40 e0       	ldi	r20, 0x00	; 0
     7de:	62 e0       	ldi	r22, 0x02	; 2
     7e0:	82 e3       	ldi	r24, 0x32	; 50
     7e2:	90 e0       	ldi	r25, 0x00	; 0
     7e4:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x08;
     7e8:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     7ec:	88 60       	ori	r24, 0x08	; 8
     7ee:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
     7f2:	9b c0       	rjmp	.+310    	; 0x92a <__stack+0xcb>
				}
				break;
				
			case 4:       // This is the case for Fuel Line 2 /////////////////////////////////////////////////
				if (saveTemps[4] < TempFLine2){
     7f4:	c0 90 50 01 	lds	r12, 0x0150	; 0x800150 <saveTemps+0x10>
     7f8:	d0 90 51 01 	lds	r13, 0x0151	; 0x800151 <saveTemps+0x11>
     7fc:	e0 90 52 01 	lds	r14, 0x0152	; 0x800152 <saveTemps+0x12>
     800:	f0 90 53 01 	lds	r15, 0x0153	; 0x800153 <saveTemps+0x13>
     804:	20 e0       	ldi	r18, 0x00	; 0
     806:	30 e0       	ldi	r19, 0x00	; 0
     808:	40 ea       	ldi	r20, 0xA0	; 160
     80a:	52 e4       	ldi	r21, 0x42	; 66
     80c:	c7 01       	movw	r24, r14
     80e:	b6 01       	movw	r22, r12
     810:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
     814:	88 23       	and	r24, r24
     816:	74 f5       	brge	.+92     	; 0x874 <__stack+0x15>
					if (!opMode){      // We are in the warming mode so this can use the PWM
     818:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     81c:	81 11       	cpse	r24, r1
     81e:	13 c0       	rjmp	.+38     	; 0x846 <tempHeaterHelper+0x28c>
						// force the PWM to be on
						assign_bit(&TCCR2, COM21, 1);
     820:	41 e0       	ldi	r20, 0x01	; 1
     822:	65 e0       	ldi	r22, 0x05	; 5
     824:	85 e4       	ldi	r24, 0x45	; 69
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&TCCR2, COM20, 1);   // This will set it to inverting mode
     82c:	41 e0       	ldi	r20, 0x01	; 1
     82e:	64 e0       	ldi	r22, 0x04	; 4
     830:	85 e4       	ldi	r24, 0x45	; 69
     832:	90 e0       	ldi	r25, 0x00	; 0
     834:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&TCCR2, CS22, 1);    // this will turn the PWM on
     838:	41 e0       	ldi	r20, 0x01	; 1
     83a:	62 e0       	ldi	r22, 0x02	; 2
     83c:	85 e4       	ldi	r24, 0x45	; 69
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     844:	72 c0       	rjmp	.+228    	; 0x92a <__stack+0xcb>
					}
					else if (opMode == 2){
     846:	82 30       	cpi	r24, 0x02	; 2
     848:	09 f0       	breq	.+2      	; 0x84c <tempHeaterHelper+0x292>
     84a:	6f c0       	rjmp	.+222    	; 0x92a <__stack+0xcb>
						// I need to implement the 10% DS
						if (pwm_count == hand_pwm){
     84c:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <pwm_count>
     850:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <hand_pwm>
     854:	98 13       	cpse	r25, r24
     856:	07 c0       	rjmp	.+14     	; 0x866 <__stack+0x7>
							assign_bit(&PORTD,Fline2Pin,1);   // turn it on for the one count
     858:	41 e0       	ldi	r20, 0x01	; 1
     85a:	67 e0       	ldi	r22, 0x07	; 7
     85c:	82 e3       	ldi	r24, 0x32	; 50
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     864:	62 c0       	rjmp	.+196    	; 0x92a <__stack+0xcb>
						}
						else{
							assign_bit(&PORTD, Fline2Pin,0);  // turn it off otherwise
     866:	40 e0       	ldi	r20, 0x00	; 0
     868:	67 e0       	ldi	r22, 0x07	; 7
     86a:	82 e3       	ldi	r24, 0x32	; 50
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     872:	5b c0       	rjmp	.+182    	; 0x92a <__stack+0xcb>
						}
					}
				}
				else if (saveTemps[4] > TempFLine2)
     874:	20 e0       	ldi	r18, 0x00	; 0
     876:	30 e0       	ldi	r19, 0x00	; 0
     878:	40 ea       	ldi	r20, 0xA0	; 160
     87a:	52 e4       	ldi	r21, 0x42	; 66
     87c:	c7 01       	movw	r24, r14
     87e:	b6 01       	movw	r22, r12
     880:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__gesf2>
     884:	18 16       	cp	r1, r24
     886:	0c f0       	brlt	.+2      	; 0x88a <__stack+0x2b>
     888:	50 c0       	rjmp	.+160    	; 0x92a <__stack+0xcb>
				{
					if (!opMode)           // We are in warming mode so this can use the PWM
     88a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     88e:	81 11       	cpse	r24, r1
     890:	4c c0       	rjmp	.+152    	; 0x92a <__stack+0xcb>
					{
						assign_bit(&TCCR2, CS22, 0);       // Turn the PWM off
     892:	40 e0       	ldi	r20, 0x00	; 0
     894:	62 e0       	ldi	r22, 0x02	; 2
     896:	85 e4       	ldi	r24, 0x45	; 69
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						// now need to disconnect the port from the PWM module
						assign_bit(&TCCR2, COM21, 0);
     89e:	40 e0       	ldi	r20, 0x00	; 0
     8a0:	65 e0       	ldi	r22, 0x05	; 5
     8a2:	85 e4       	ldi	r24, 0x45	; 69
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&TCCR2, COM20, 0);
     8aa:	40 e0       	ldi	r20, 0x00	; 0
     8ac:	64 e0       	ldi	r22, 0x04	; 4
     8ae:	85 e4       	ldi	r24, 0x45	; 69
     8b0:	90 e0       	ldi	r25, 0x00	; 0
     8b2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						assign_bit(&PORTD, Fline2Pin, 0);    // force the pin to be low
     8b6:	40 e0       	ldi	r20, 0x00	; 0
     8b8:	67 e0       	ldi	r22, 0x07	; 7
     8ba:	82 e3       	ldi	r24, 0x32	; 50
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x10;
     8c2:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     8c6:	80 61       	ori	r24, 0x10	; 16
     8c8:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
     8cc:	2e c0       	rjmp	.+92     	; 0x92a <__stack+0xcb>
					}
				}
				break;
				
			case 5:       // This is the case for the ESB    /////////////////////////////////////////////////
				if (saveTemps[5] < TempESB)
     8ce:	c0 90 54 01 	lds	r12, 0x0154	; 0x800154 <saveTemps+0x14>
     8d2:	d0 90 55 01 	lds	r13, 0x0155	; 0x800155 <saveTemps+0x15>
     8d6:	e0 90 56 01 	lds	r14, 0x0156	; 0x800156 <saveTemps+0x16>
     8da:	f0 90 57 01 	lds	r15, 0x0157	; 0x800157 <saveTemps+0x17>
     8de:	20 e0       	ldi	r18, 0x00	; 0
     8e0:	30 e0       	ldi	r19, 0x00	; 0
     8e2:	40 e2       	ldi	r20, 0x20	; 32
     8e4:	51 e4       	ldi	r21, 0x41	; 65
     8e6:	c7 01       	movw	r24, r14
     8e8:	b6 01       	movw	r22, r12
     8ea:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
     8ee:	88 23       	and	r24, r24
     8f0:	3c f4       	brge	.+14     	; 0x900 <__stack+0xa1>
					assign_bit(&PORTD, ESB_Pin, 1);
     8f2:	41 e0       	ldi	r20, 0x01	; 1
     8f4:	63 e0       	ldi	r22, 0x03	; 3
     8f6:	82 e3       	ldi	r24, 0x32	; 50
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
     8fe:	15 c0       	rjmp	.+42     	; 0x92a <__stack+0xcb>
				else if(saveTemps[5] > TempESB)
     900:	20 e0       	ldi	r18, 0x00	; 0
     902:	30 e0       	ldi	r19, 0x00	; 0
     904:	40 e2       	ldi	r20, 0x20	; 32
     906:	51 e4       	ldi	r21, 0x41	; 65
     908:	c7 01       	movw	r24, r14
     90a:	b6 01       	movw	r22, r12
     90c:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__gesf2>
     910:	18 16       	cp	r1, r24
     912:	5c f4       	brge	.+22     	; 0x92a <__stack+0xcb>
				{
					assign_bit(&PORTD, ESB_Pin, 0);
     914:	40 e0       	ldi	r20, 0x00	; 0
     916:	63 e0       	ldi	r22, 0x03	; 3
     918:	82 e3       	ldi	r24, 0x32	; 50
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x20;
     920:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     924:	80 62       	ori	r24, 0x20	; 32
     926:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
	for (uint8_t i = 0; i < 6; i++)
     92a:	cf 5f       	subi	r28, 0xFF	; 255
     92c:	c6 30       	cpi	r28, 0x06	; 6
     92e:	08 f4       	brcc	.+2      	; 0x932 <__stack+0xd3>
     930:	4b ce       	rjmp	.-874    	; 0x5c8 <tempHeaterHelper+0xe>
				break;
		}
		
	}
	
	if (desired_temp == 0x3F)      // Will go in here every time after it stops being mode 0 this was 3F
     932:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
     936:	8f 33       	cpi	r24, 0x3F	; 63
     938:	31 f4       	brne	.+12     	; 0x946 <__stack+0xe7>
		/* If desired_temp was 0111 1111, it would go to 1111 1111 with the or.
		*   Then the bitwise not (~) would make it 0000 0000.  And finally,
		*   the logical not (!) would make it 0000 0001 and it would go into the if statement.
		*   If desired_temp is anything but this, it will not go in here 
		*/
		if (!opMode)    // only do this if it has never gone in here before
     93a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     93e:	81 11       	cpse	r24, r1
     940:	02 c0       	rjmp	.+4      	; 0x946 <__stack+0xe7>
			change_timers();                     // New initialization routine which will change the prescalars and such for the timers which will be serving different purposes
     942:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <change_timers>
	}
}
     946:	cf 91       	pop	r28
     948:	ff 90       	pop	r15
     94a:	ef 90       	pop	r14
     94c:	df 90       	pop	r13
     94e:	cf 90       	pop	r12
     950:	08 95       	ret

00000952 <tempConversion>:
 *  @param void
 *  @return void
 *  @see tempHeaterHelper
 */
void tempConversion(void)
{
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	cf 93       	push	r28
     958:	df 93       	push	r29
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
     95a:	40 e0       	ldi	r20, 0x00	; 0
     95c:	60 e0       	ldi	r22, 0x00	; 0
     95e:	87 e2       	ldi	r24, 0x27	; 39
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX1,0);
     966:	40 e0       	ldi	r20, 0x00	; 0
     968:	61 e0       	ldi	r22, 0x01	; 1
     96a:	87 e2       	ldi	r24, 0x27	; 39
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX2,0);
     972:	40 e0       	ldi	r20, 0x00	; 0
     974:	62 e0       	ldi	r22, 0x02	; 2
     976:	87 e2       	ldi	r24, 0x27	; 39
     978:	90 e0       	ldi	r25, 0x00	; 0
     97a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	for (unsigned char i = 0; i < 6; i++)
     97e:	10 e0       	ldi	r17, 0x00	; 0
     980:	65 c0       	rjmp	.+202    	; 0xa4c <tempConversion+0xfa>
	{
		ADCSRA |= 1 << ADSC;                             // Start the conversion
     982:	86 b1       	in	r24, 0x06	; 6
     984:	80 64       	ori	r24, 0x40	; 64
     986:	86 b9       	out	0x06, r24	; 6
		while (!((1 << ADIF) & ADCSRA));
     988:	34 9b       	sbis	0x06, 4	; 6
     98a:	fe cf       	rjmp	.-4      	; 0x988 <tempConversion+0x36>
		
		while (bit_is_clear(ADCSRA, ADIF));				 // Hog execution until the ADC is done converting
     98c:	34 9b       	sbis	0x06, 4	; 6
     98e:	fe cf       	rjmp	.-4      	; 0x98c <tempConversion+0x3a>

		// Save this as a float for the respective variable
		uint8_t low_bits = ADCL;
     990:	84 b1       	in	r24, 0x04	; 4
		uint8_t high_bits = ADCH;						 // Do the shifting so that there is room made inside of the 16 bit register
     992:	65 b1       	in	r22, 0x05	; 5
		uint16_t result = (high_bits << 8) | low_bits;
     994:	70 e0       	ldi	r23, 0x00	; 0
     996:	76 2f       	mov	r23, r22
     998:	66 27       	eor	r22, r22
     99a:	68 2b       	or	r22, r24
		
		// Now I need to convert this 16 bit number into an actual temperature
		
		float act_temp = (float)(0.0048828125*result);   // This dumb thing converts it to a voltage
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	90 e0       	ldi	r25, 0x00	; 0
     9a0:	0e 94 f3 06 	call	0xde6	; 0xde6 <__floatunsisf>
     9a4:	20 e0       	ldi	r18, 0x00	; 0
     9a6:	30 e0       	ldi	r19, 0x00	; 0
     9a8:	40 ea       	ldi	r20, 0xA0	; 160
     9aa:	5b e3       	ldi	r21, 0x3B	; 59
     9ac:	0e 94 aa 07 	call	0xf54	; 0xf54 <__mulsf3>
		act_temp = act_temp*208.8 - 79.6;
     9b0:	2d ec       	ldi	r18, 0xCD	; 205
     9b2:	3c ec       	ldi	r19, 0xCC	; 204
     9b4:	40 e5       	ldi	r20, 0x50	; 80
     9b6:	53 e4       	ldi	r21, 0x43	; 67
     9b8:	0e 94 aa 07 	call	0xf54	; 0xf54 <__mulsf3>
     9bc:	23 e3       	ldi	r18, 0x33	; 51
     9be:	33 e3       	ldi	r19, 0x33	; 51
     9c0:	4f e9       	ldi	r20, 0x9F	; 159
     9c2:	52 e4       	ldi	r21, 0x42	; 66
     9c4:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
		saveTemps[i] = act_temp;
     9c8:	c1 2f       	mov	r28, r17
     9ca:	d0 e0       	ldi	r29, 0x00	; 0
     9cc:	fe 01       	movw	r30, r28
     9ce:	ee 0f       	add	r30, r30
     9d0:	ff 1f       	adc	r31, r31
     9d2:	ee 0f       	add	r30, r30
     9d4:	ff 1f       	adc	r31, r31
     9d6:	e0 5c       	subi	r30, 0xC0	; 192
     9d8:	fe 4f       	sbci	r31, 0xFE	; 254
     9da:	60 83       	st	Z, r22
     9dc:	71 83       	std	Z+1, r23	; 0x01
     9de:	82 83       	std	Z+2, r24	; 0x02
     9e0:	93 83       	std	Z+3, r25	; 0x03
		
		if (i == 4){
     9e2:	14 30       	cpi	r17, 0x04	; 4
     9e4:	31 f4       	brne	.+12     	; 0x9f2 <tempConversion+0xa0>
			assign_bit(&ADMUX, MUX1,0);
     9e6:	40 e0       	ldi	r20, 0x00	; 0
     9e8:	61 e0       	ldi	r22, 0x01	; 1
     9ea:	87 e2       	ldi	r24, 0x27	; 39
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		}
		// Now update the channel the ADC is using
		assign_bit(&ADMUX,MUX0,(i + 1) & 0x01);           // Assign bit 0
     9f2:	01 e0       	ldi	r16, 0x01	; 1
     9f4:	01 0f       	add	r16, r17
     9f6:	40 2f       	mov	r20, r16
     9f8:	41 70       	andi	r20, 0x01	; 1
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	87 e2       	ldi	r24, 0x27	; 39
     9fe:	90 e0       	ldi	r25, 0x00	; 0
     a00:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX1,((i + 1) >> 1) & 0x01);    // Assign bit 1
     a04:	21 96       	adiw	r28, 0x01	; 1
     a06:	ae 01       	movw	r20, r28
     a08:	55 95       	asr	r21
     a0a:	47 95       	ror	r20
     a0c:	41 70       	andi	r20, 0x01	; 1
     a0e:	61 e0       	ldi	r22, 0x01	; 1
     a10:	87 e2       	ldi	r24, 0x27	; 39
     a12:	90 e0       	ldi	r25, 0x00	; 0
     a14:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
     a18:	d5 95       	asr	r29
     a1a:	c7 95       	ror	r28
     a1c:	d5 95       	asr	r29
     a1e:	c7 95       	ror	r28
     a20:	4c 2f       	mov	r20, r28
     a22:	41 70       	andi	r20, 0x01	; 1
     a24:	62 e0       	ldi	r22, 0x02	; 2
     a26:	87 e2       	ldi	r24, 0x27	; 39
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		if (i == 3){
     a2e:	13 30       	cpi	r17, 0x03	; 3
     a30:	31 f4       	brne	.+12     	; 0xa3e <tempConversion+0xec>
			assign_bit(&ADMUX, MUX1,1);
     a32:	41 e0       	ldi	r20, 0x01	; 1
     a34:	61 e0       	ldi	r22, 0x01	; 1
     a36:	87 e2       	ldi	r24, 0x27	; 39
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		}

		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet
     a3e:	41 e0       	ldi	r20, 0x01	; 1
     a40:	64 e0       	ldi	r22, 0x04	; 4
     a42:	86 e2       	ldi	r24, 0x26	; 38
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
	assign_bit(&ADMUX,MUX1,0);
	assign_bit(&ADMUX,MUX2,0);
	
	for (unsigned char i = 0; i < 6; i++)
     a4a:	10 2f       	mov	r17, r16
     a4c:	16 30       	cpi	r17, 0x06	; 6
     a4e:	08 f4       	brcc	.+2      	; 0xa52 <tempConversion+0x100>
     a50:	98 cf       	rjmp	.-208    	; 0x982 <tempConversion+0x30>

		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet

	}
	tempHeaterHelper();             // Call the helper function.  This will serve the added bonus of killing some time so that if capacitors need to charge for the next conversion, it has the time here.  Data sheet didn't say that it needed this though.
     a52:	0e 94 dd 02 	call	0x5ba	; 0x5ba <tempHeaterHelper>
	if (opMode != 1)
     a56:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     a5a:	81 30       	cpi	r24, 0x01	; 1
     a5c:	31 f0       	breq	.+12     	; 0xa6a <tempConversion+0x118>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a5e:	83 e2       	ldi	r24, 0x23	; 35
     a60:	94 ef       	ldi	r25, 0xF4	; 244
     a62:	01 97       	sbiw	r24, 0x01	; 1
     a64:	f1 f7       	brne	.-4      	; 0xa62 <tempConversion+0x110>
     a66:	00 c0       	rjmp	.+0      	; 0xa68 <tempConversion+0x116>
     a68:	00 00       	nop
		_delay_ms(250);                 // Delay for 1/4 of a second.   This will only impact modes 0 and 2
	
}
     a6a:	df 91       	pop	r29
     a6c:	cf 91       	pop	r28
     a6e:	1f 91       	pop	r17
     a70:	0f 91       	pop	r16
     a72:	08 95       	ret

00000a74 <__vector_3>:
 *  @param[in] pulse_count This is the number which describes how many pulses have been received for the sampling period.  It is an implicit argument as it is a global variable which is not explicitly passed in.
 *  @return void
 *  @see flowMeter
 */
ISR(INT2_vect)
{
     a74:	1f 92       	push	r1
     a76:	0f 92       	push	r0
     a78:	0f b6       	in	r0, 0x3f	; 63
     a7a:	0f 92       	push	r0
     a7c:	11 24       	eor	r1, r1
     a7e:	8f 93       	push	r24
	pulse_count++;  // The interrupt flag will automatically be cleared by hardware
     a80:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pulse_count>
     a84:	8f 5f       	subi	r24, 0xFF	; 255
     a86:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pulse_count>
}
     a8a:	8f 91       	pop	r24
     a8c:	0f 90       	pop	r0
     a8e:	0f be       	out	0x3f, r0	; 63
     a90:	0f 90       	pop	r0
     a92:	1f 90       	pop	r1
     a94:	18 95       	reti

00000a96 <__vector_5>:
 *
 *  @param[in] alive_counter Variable to act as a custom prescalar for the timer
 *  @return void
 */
ISR(TIMER2_OVF_vect)
{
     a96:	1f 92       	push	r1
     a98:	0f 92       	push	r0
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	0f 92       	push	r0
     a9e:	11 24       	eor	r1, r1
     aa0:	2f 93       	push	r18
     aa2:	3f 93       	push	r19
     aa4:	4f 93       	push	r20
     aa6:	5f 93       	push	r21
     aa8:	6f 93       	push	r22
     aaa:	7f 93       	push	r23
     aac:	8f 93       	push	r24
     aae:	9f 93       	push	r25
     ab0:	af 93       	push	r26
     ab2:	bf 93       	push	r27
     ab4:	ef 93       	push	r30
     ab6:	ff 93       	push	r31
	if (opMode == 1)     // Operation mode 1 so do 0.75 sec on and 0.25 sec off
     ab8:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     abc:	81 30       	cpi	r24, 0x01	; 1
     abe:	29 f5       	brne	.+74     	; 0xb0a <__vector_5+0x74>
	{
		if (alive_counter == 2)
     ac0:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
     ac4:	82 30       	cpi	r24, 0x02	; 2
     ac6:	71 f4       	brne	.+28     	; 0xae4 <__vector_5+0x4e>
		{
			assign_bit(&PORTD, Alive_LED, 0);        // Turn the LED off since it is at the end of the 0.75 sec portion
     ac8:	40 e0       	ldi	r20, 0x00	; 0
     aca:	65 e0       	ldi	r22, 0x05	; 5
     acc:	82 e3       	ldi	r24, 0x32	; 50
     ace:	90 e0       	ldi	r25, 0x00	; 0
     ad0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
     ad4:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
     ad8:	8f 5f       	subi	r24, 0xFF	; 255
     ada:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 11;
     ade:	8b e0       	ldi	r24, 0x0B	; 11
     ae0:	84 bd       	out	0x24, r24	; 36
     ae2:	37 c0       	rjmp	.+110    	; 0xb52 <__vector_5+0xbc>
		}
		else if (alive_counter == 3)
     ae4:	83 30       	cpi	r24, 0x03	; 3
     ae6:	59 f4       	brne	.+22     	; 0xafe <__vector_5+0x68>
		{
			assign_bit(&PORTD, Alive_LED, 1);        // Turn the LED back on since it is about to begin the 0.75 second portion
     ae8:	41 e0       	ldi	r20, 0x01	; 1
     aea:	65 e0       	ldi	r22, 0x05	; 5
     aec:	82 e3       	ldi	r24, 0x32	; 50
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
     af4:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
			TCNT2 = 11;                              // Assign the correct value into the Timer register so that it goes for 0.25 sec
     af8:	8b e0       	ldi	r24, 0x0B	; 11
     afa:	84 bd       	out	0x24, r24	; 36
     afc:	2a c0       	rjmp	.+84     	; 0xb52 <__vector_5+0xbc>
		}
		else                                         // This section is for if it is in the middle of the 0.75 sec portion
		{
			alive_counter++;
     afe:	8f 5f       	subi	r24, 0xFF	; 255
     b00:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 11;
     b04:	8b e0       	ldi	r24, 0x0B	; 11
     b06:	84 bd       	out	0x24, r24	; 36
     b08:	24 c0       	rjmp	.+72     	; 0xb52 <__vector_5+0xbc>
		}
	}
	else   // I am in operation mode 2 so I need to do 0.1 sec on 0.9 sec off
	{
		if (alive_counter == 1)
     b0a:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
     b0e:	81 30       	cpi	r24, 0x01	; 1
     b10:	71 f4       	brne	.+28     	; 0xb2e <__vector_5+0x98>
		{
			assign_bit(&PORTD, Alive_LED, 0);            // Turn off the LED since we are at the end of the 0.1 sec period
     b12:	40 e0       	ldi	r20, 0x00	; 0
     b14:	65 e0       	ldi	r22, 0x05	; 5
     b16:	82 e3       	ldi	r24, 0x32	; 50
     b18:	90 e0       	ldi	r25, 0x00	; 0
     b1a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
     b1e:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
     b22:	8f 5f       	subi	r24, 0xFF	; 255
     b24:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 60;
     b28:	8c e3       	ldi	r24, 0x3C	; 60
     b2a:	84 bd       	out	0x24, r24	; 36
     b2c:	12 c0       	rjmp	.+36     	; 0xb52 <__vector_5+0xbc>
		}
		else if (alive_counter == 19)
     b2e:	83 31       	cpi	r24, 0x13	; 19
     b30:	59 f4       	brne	.+22     	; 0xb48 <__vector_5+0xb2>
		{
			assign_bit(&PORTD, Alive_LED, 1);            // Turn on the LED since we are at the end of the 0.9 sec period
     b32:	41 e0       	ldi	r20, 0x01	; 1
     b34:	65 e0       	ldi	r22, 0x05	; 5
     b36:	82 e3       	ldi	r24, 0x32	; 50
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
     b3e:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
			TCNT2 = 60;
     b42:	8c e3       	ldi	r24, 0x3C	; 60
     b44:	84 bd       	out	0x24, r24	; 36
     b46:	05 c0       	rjmp	.+10     	; 0xb52 <__vector_5+0xbc>

		}
		else
		{
			alive_counter++;                             // At one of the intermediate points so just keep the LED how it is
     b48:	8f 5f       	subi	r24, 0xFF	; 255
     b4a:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 60; 
     b4e:	8c e3       	ldi	r24, 0x3C	; 60
     b50:	84 bd       	out	0x24, r24	; 36
		}
	}
}
     b52:	ff 91       	pop	r31
     b54:	ef 91       	pop	r30
     b56:	bf 91       	pop	r27
     b58:	af 91       	pop	r26
     b5a:	9f 91       	pop	r25
     b5c:	8f 91       	pop	r24
     b5e:	7f 91       	pop	r23
     b60:	6f 91       	pop	r22
     b62:	5f 91       	pop	r21
     b64:	4f 91       	pop	r20
     b66:	3f 91       	pop	r19
     b68:	2f 91       	pop	r18
     b6a:	0f 90       	pop	r0
     b6c:	0f be       	out	0x3f, r0	; 63
     b6e:	0f 90       	pop	r0
     b70:	1f 90       	pop	r1
     b72:	18 95       	reti

00000b74 <main>:
 */ 
#include "HCU_Funcs.h"

int main(void)
{
    Initial();
     b74:	0e 94 79 00 	call	0xf2	; 0xf2 <Initial>
    while (1) 
    {
		output_count++;
     b78:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <output_count>
     b7c:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <output_count+0x1>
     b80:	01 96       	adiw	r24, 0x01	; 1
     b82:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <output_count+0x1>
     b86:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <output_count>
		tempConversion();
     b8a:	0e 94 a9 04 	call	0x952	; 0x952 <tempConversion>
		if (!ECU_present && (opMode == 1))    // Will only go in here if the ECU is not present and in pumping mode
     b8e:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
     b92:	81 30       	cpi	r24, 0x01	; 1
     b94:	11 f4       	brne	.+4      	; 0xb9a <main+0x26>
			flowMeter();
     b96:	0e 94 42 01 	call	0x284	; 0x284 <flowMeter>
		pwm_count++;
     b9a:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <pwm_count>
     b9e:	8f 5f       	subi	r24, 0xFF	; 255
     ba0:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <pwm_count>
		if (pwm_count > hand_pwm)
     ba4:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <hand_pwm>
     ba8:	98 17       	cp	r25, r24
     baa:	30 f7       	brcc	.-52     	; 0xb78 <main+0x4>
			pwm_count = 0;
     bac:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <pwm_count>
     bb0:	e3 cf       	rjmp	.-58     	; 0xb78 <main+0x4>

00000bb2 <__subsf3>:
     bb2:	50 58       	subi	r21, 0x80	; 128

00000bb4 <__addsf3>:
     bb4:	bb 27       	eor	r27, r27
     bb6:	aa 27       	eor	r26, r26
     bb8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <__addsf3x>
     bbc:	0c 94 6b 07 	jmp	0xed6	; 0xed6 <__fp_round>
     bc0:	0e 94 5d 07 	call	0xeba	; 0xeba <__fp_pscA>
     bc4:	38 f0       	brcs	.+14     	; 0xbd4 <__addsf3+0x20>
     bc6:	0e 94 64 07 	call	0xec8	; 0xec8 <__fp_pscB>
     bca:	20 f0       	brcs	.+8      	; 0xbd4 <__addsf3+0x20>
     bcc:	39 f4       	brne	.+14     	; 0xbdc <__addsf3+0x28>
     bce:	9f 3f       	cpi	r25, 0xFF	; 255
     bd0:	19 f4       	brne	.+6      	; 0xbd8 <__addsf3+0x24>
     bd2:	26 f4       	brtc	.+8      	; 0xbdc <__addsf3+0x28>
     bd4:	0c 94 5a 07 	jmp	0xeb4	; 0xeb4 <__fp_nan>
     bd8:	0e f4       	brtc	.+2      	; 0xbdc <__addsf3+0x28>
     bda:	e0 95       	com	r30
     bdc:	e7 fb       	bst	r30, 7
     bde:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__fp_inf>

00000be2 <__addsf3x>:
     be2:	e9 2f       	mov	r30, r25
     be4:	0e 94 7c 07 	call	0xef8	; 0xef8 <__fp_split3>
     be8:	58 f3       	brcs	.-42     	; 0xbc0 <__addsf3+0xc>
     bea:	ba 17       	cp	r27, r26
     bec:	62 07       	cpc	r22, r18
     bee:	73 07       	cpc	r23, r19
     bf0:	84 07       	cpc	r24, r20
     bf2:	95 07       	cpc	r25, r21
     bf4:	20 f0       	brcs	.+8      	; 0xbfe <__addsf3x+0x1c>
     bf6:	79 f4       	brne	.+30     	; 0xc16 <__addsf3x+0x34>
     bf8:	a6 f5       	brtc	.+104    	; 0xc62 <__addsf3x+0x80>
     bfa:	0c 94 9e 07 	jmp	0xf3c	; 0xf3c <__fp_zero>
     bfe:	0e f4       	brtc	.+2      	; 0xc02 <__addsf3x+0x20>
     c00:	e0 95       	com	r30
     c02:	0b 2e       	mov	r0, r27
     c04:	ba 2f       	mov	r27, r26
     c06:	a0 2d       	mov	r26, r0
     c08:	0b 01       	movw	r0, r22
     c0a:	b9 01       	movw	r22, r18
     c0c:	90 01       	movw	r18, r0
     c0e:	0c 01       	movw	r0, r24
     c10:	ca 01       	movw	r24, r20
     c12:	a0 01       	movw	r20, r0
     c14:	11 24       	eor	r1, r1
     c16:	ff 27       	eor	r31, r31
     c18:	59 1b       	sub	r21, r25
     c1a:	99 f0       	breq	.+38     	; 0xc42 <__addsf3x+0x60>
     c1c:	59 3f       	cpi	r21, 0xF9	; 249
     c1e:	50 f4       	brcc	.+20     	; 0xc34 <__addsf3x+0x52>
     c20:	50 3e       	cpi	r21, 0xE0	; 224
     c22:	68 f1       	brcs	.+90     	; 0xc7e <__addsf3x+0x9c>
     c24:	1a 16       	cp	r1, r26
     c26:	f0 40       	sbci	r31, 0x00	; 0
     c28:	a2 2f       	mov	r26, r18
     c2a:	23 2f       	mov	r18, r19
     c2c:	34 2f       	mov	r19, r20
     c2e:	44 27       	eor	r20, r20
     c30:	58 5f       	subi	r21, 0xF8	; 248
     c32:	f3 cf       	rjmp	.-26     	; 0xc1a <__addsf3x+0x38>
     c34:	46 95       	lsr	r20
     c36:	37 95       	ror	r19
     c38:	27 95       	ror	r18
     c3a:	a7 95       	ror	r26
     c3c:	f0 40       	sbci	r31, 0x00	; 0
     c3e:	53 95       	inc	r21
     c40:	c9 f7       	brne	.-14     	; 0xc34 <__addsf3x+0x52>
     c42:	7e f4       	brtc	.+30     	; 0xc62 <__addsf3x+0x80>
     c44:	1f 16       	cp	r1, r31
     c46:	ba 0b       	sbc	r27, r26
     c48:	62 0b       	sbc	r22, r18
     c4a:	73 0b       	sbc	r23, r19
     c4c:	84 0b       	sbc	r24, r20
     c4e:	ba f0       	brmi	.+46     	; 0xc7e <__addsf3x+0x9c>
     c50:	91 50       	subi	r25, 0x01	; 1
     c52:	a1 f0       	breq	.+40     	; 0xc7c <__addsf3x+0x9a>
     c54:	ff 0f       	add	r31, r31
     c56:	bb 1f       	adc	r27, r27
     c58:	66 1f       	adc	r22, r22
     c5a:	77 1f       	adc	r23, r23
     c5c:	88 1f       	adc	r24, r24
     c5e:	c2 f7       	brpl	.-16     	; 0xc50 <__addsf3x+0x6e>
     c60:	0e c0       	rjmp	.+28     	; 0xc7e <__addsf3x+0x9c>
     c62:	ba 0f       	add	r27, r26
     c64:	62 1f       	adc	r22, r18
     c66:	73 1f       	adc	r23, r19
     c68:	84 1f       	adc	r24, r20
     c6a:	48 f4       	brcc	.+18     	; 0xc7e <__addsf3x+0x9c>
     c6c:	87 95       	ror	r24
     c6e:	77 95       	ror	r23
     c70:	67 95       	ror	r22
     c72:	b7 95       	ror	r27
     c74:	f7 95       	ror	r31
     c76:	9e 3f       	cpi	r25, 0xFE	; 254
     c78:	08 f0       	brcs	.+2      	; 0xc7c <__addsf3x+0x9a>
     c7a:	b0 cf       	rjmp	.-160    	; 0xbdc <__addsf3+0x28>
     c7c:	93 95       	inc	r25
     c7e:	88 0f       	add	r24, r24
     c80:	08 f0       	brcs	.+2      	; 0xc84 <__addsf3x+0xa2>
     c82:	99 27       	eor	r25, r25
     c84:	ee 0f       	add	r30, r30
     c86:	97 95       	ror	r25
     c88:	87 95       	ror	r24
     c8a:	08 95       	ret

00000c8c <__cmpsf2>:
     c8c:	0e 94 30 07 	call	0xe60	; 0xe60 <__fp_cmp>
     c90:	08 f4       	brcc	.+2      	; 0xc94 <__cmpsf2+0x8>
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	08 95       	ret

00000c96 <__divsf3>:
     c96:	0e 94 5f 06 	call	0xcbe	; 0xcbe <__divsf3x>
     c9a:	0c 94 6b 07 	jmp	0xed6	; 0xed6 <__fp_round>
     c9e:	0e 94 64 07 	call	0xec8	; 0xec8 <__fp_pscB>
     ca2:	58 f0       	brcs	.+22     	; 0xcba <__divsf3+0x24>
     ca4:	0e 94 5d 07 	call	0xeba	; 0xeba <__fp_pscA>
     ca8:	40 f0       	brcs	.+16     	; 0xcba <__divsf3+0x24>
     caa:	29 f4       	brne	.+10     	; 0xcb6 <__divsf3+0x20>
     cac:	5f 3f       	cpi	r21, 0xFF	; 255
     cae:	29 f0       	breq	.+10     	; 0xcba <__divsf3+0x24>
     cb0:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__fp_inf>
     cb4:	51 11       	cpse	r21, r1
     cb6:	0c 94 9f 07 	jmp	0xf3e	; 0xf3e <__fp_szero>
     cba:	0c 94 5a 07 	jmp	0xeb4	; 0xeb4 <__fp_nan>

00000cbe <__divsf3x>:
     cbe:	0e 94 7c 07 	call	0xef8	; 0xef8 <__fp_split3>
     cc2:	68 f3       	brcs	.-38     	; 0xc9e <__divsf3+0x8>

00000cc4 <__divsf3_pse>:
     cc4:	99 23       	and	r25, r25
     cc6:	b1 f3       	breq	.-20     	; 0xcb4 <__divsf3+0x1e>
     cc8:	55 23       	and	r21, r21
     cca:	91 f3       	breq	.-28     	; 0xcb0 <__divsf3+0x1a>
     ccc:	95 1b       	sub	r25, r21
     cce:	55 0b       	sbc	r21, r21
     cd0:	bb 27       	eor	r27, r27
     cd2:	aa 27       	eor	r26, r26
     cd4:	62 17       	cp	r22, r18
     cd6:	73 07       	cpc	r23, r19
     cd8:	84 07       	cpc	r24, r20
     cda:	38 f0       	brcs	.+14     	; 0xcea <__divsf3_pse+0x26>
     cdc:	9f 5f       	subi	r25, 0xFF	; 255
     cde:	5f 4f       	sbci	r21, 0xFF	; 255
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	aa 1f       	adc	r26, r26
     ce8:	a9 f3       	breq	.-22     	; 0xcd4 <__divsf3_pse+0x10>
     cea:	35 d0       	rcall	.+106    	; 0xd56 <__divsf3_pse+0x92>
     cec:	0e 2e       	mov	r0, r30
     cee:	3a f0       	brmi	.+14     	; 0xcfe <__divsf3_pse+0x3a>
     cf0:	e0 e8       	ldi	r30, 0x80	; 128
     cf2:	32 d0       	rcall	.+100    	; 0xd58 <__divsf3_pse+0x94>
     cf4:	91 50       	subi	r25, 0x01	; 1
     cf6:	50 40       	sbci	r21, 0x00	; 0
     cf8:	e6 95       	lsr	r30
     cfa:	00 1c       	adc	r0, r0
     cfc:	ca f7       	brpl	.-14     	; 0xcf0 <__divsf3_pse+0x2c>
     cfe:	2b d0       	rcall	.+86     	; 0xd56 <__divsf3_pse+0x92>
     d00:	fe 2f       	mov	r31, r30
     d02:	29 d0       	rcall	.+82     	; 0xd56 <__divsf3_pse+0x92>
     d04:	66 0f       	add	r22, r22
     d06:	77 1f       	adc	r23, r23
     d08:	88 1f       	adc	r24, r24
     d0a:	bb 1f       	adc	r27, r27
     d0c:	26 17       	cp	r18, r22
     d0e:	37 07       	cpc	r19, r23
     d10:	48 07       	cpc	r20, r24
     d12:	ab 07       	cpc	r26, r27
     d14:	b0 e8       	ldi	r27, 0x80	; 128
     d16:	09 f0       	breq	.+2      	; 0xd1a <__divsf3_pse+0x56>
     d18:	bb 0b       	sbc	r27, r27
     d1a:	80 2d       	mov	r24, r0
     d1c:	bf 01       	movw	r22, r30
     d1e:	ff 27       	eor	r31, r31
     d20:	93 58       	subi	r25, 0x83	; 131
     d22:	5f 4f       	sbci	r21, 0xFF	; 255
     d24:	3a f0       	brmi	.+14     	; 0xd34 <__divsf3_pse+0x70>
     d26:	9e 3f       	cpi	r25, 0xFE	; 254
     d28:	51 05       	cpc	r21, r1
     d2a:	78 f0       	brcs	.+30     	; 0xd4a <__divsf3_pse+0x86>
     d2c:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__fp_inf>
     d30:	0c 94 9f 07 	jmp	0xf3e	; 0xf3e <__fp_szero>
     d34:	5f 3f       	cpi	r21, 0xFF	; 255
     d36:	e4 f3       	brlt	.-8      	; 0xd30 <__divsf3_pse+0x6c>
     d38:	98 3e       	cpi	r25, 0xE8	; 232
     d3a:	d4 f3       	brlt	.-12     	; 0xd30 <__divsf3_pse+0x6c>
     d3c:	86 95       	lsr	r24
     d3e:	77 95       	ror	r23
     d40:	67 95       	ror	r22
     d42:	b7 95       	ror	r27
     d44:	f7 95       	ror	r31
     d46:	9f 5f       	subi	r25, 0xFF	; 255
     d48:	c9 f7       	brne	.-14     	; 0xd3c <__divsf3_pse+0x78>
     d4a:	88 0f       	add	r24, r24
     d4c:	91 1d       	adc	r25, r1
     d4e:	96 95       	lsr	r25
     d50:	87 95       	ror	r24
     d52:	97 f9       	bld	r25, 7
     d54:	08 95       	ret
     d56:	e1 e0       	ldi	r30, 0x01	; 1
     d58:	66 0f       	add	r22, r22
     d5a:	77 1f       	adc	r23, r23
     d5c:	88 1f       	adc	r24, r24
     d5e:	bb 1f       	adc	r27, r27
     d60:	62 17       	cp	r22, r18
     d62:	73 07       	cpc	r23, r19
     d64:	84 07       	cpc	r24, r20
     d66:	ba 07       	cpc	r27, r26
     d68:	20 f0       	brcs	.+8      	; 0xd72 <__divsf3_pse+0xae>
     d6a:	62 1b       	sub	r22, r18
     d6c:	73 0b       	sbc	r23, r19
     d6e:	84 0b       	sbc	r24, r20
     d70:	ba 0b       	sbc	r27, r26
     d72:	ee 1f       	adc	r30, r30
     d74:	88 f7       	brcc	.-30     	; 0xd58 <__divsf3_pse+0x94>
     d76:	e0 95       	com	r30
     d78:	08 95       	ret

00000d7a <__fixsfsi>:
     d7a:	0e 94 c4 06 	call	0xd88	; 0xd88 <__fixunssfsi>
     d7e:	68 94       	set
     d80:	b1 11       	cpse	r27, r1
     d82:	0c 94 9f 07 	jmp	0xf3e	; 0xf3e <__fp_szero>
     d86:	08 95       	ret

00000d88 <__fixunssfsi>:
     d88:	0e 94 84 07 	call	0xf08	; 0xf08 <__fp_splitA>
     d8c:	88 f0       	brcs	.+34     	; 0xdb0 <__fixunssfsi+0x28>
     d8e:	9f 57       	subi	r25, 0x7F	; 127
     d90:	98 f0       	brcs	.+38     	; 0xdb8 <__fixunssfsi+0x30>
     d92:	b9 2f       	mov	r27, r25
     d94:	99 27       	eor	r25, r25
     d96:	b7 51       	subi	r27, 0x17	; 23
     d98:	b0 f0       	brcs	.+44     	; 0xdc6 <__fixunssfsi+0x3e>
     d9a:	e1 f0       	breq	.+56     	; 0xdd4 <__fixunssfsi+0x4c>
     d9c:	66 0f       	add	r22, r22
     d9e:	77 1f       	adc	r23, r23
     da0:	88 1f       	adc	r24, r24
     da2:	99 1f       	adc	r25, r25
     da4:	1a f0       	brmi	.+6      	; 0xdac <__fixunssfsi+0x24>
     da6:	ba 95       	dec	r27
     da8:	c9 f7       	brne	.-14     	; 0xd9c <__fixunssfsi+0x14>
     daa:	14 c0       	rjmp	.+40     	; 0xdd4 <__fixunssfsi+0x4c>
     dac:	b1 30       	cpi	r27, 0x01	; 1
     dae:	91 f0       	breq	.+36     	; 0xdd4 <__fixunssfsi+0x4c>
     db0:	0e 94 9e 07 	call	0xf3c	; 0xf3c <__fp_zero>
     db4:	b1 e0       	ldi	r27, 0x01	; 1
     db6:	08 95       	ret
     db8:	0c 94 9e 07 	jmp	0xf3c	; 0xf3c <__fp_zero>
     dbc:	67 2f       	mov	r22, r23
     dbe:	78 2f       	mov	r23, r24
     dc0:	88 27       	eor	r24, r24
     dc2:	b8 5f       	subi	r27, 0xF8	; 248
     dc4:	39 f0       	breq	.+14     	; 0xdd4 <__fixunssfsi+0x4c>
     dc6:	b9 3f       	cpi	r27, 0xF9	; 249
     dc8:	cc f3       	brlt	.-14     	; 0xdbc <__fixunssfsi+0x34>
     dca:	86 95       	lsr	r24
     dcc:	77 95       	ror	r23
     dce:	67 95       	ror	r22
     dd0:	b3 95       	inc	r27
     dd2:	d9 f7       	brne	.-10     	; 0xdca <__fixunssfsi+0x42>
     dd4:	3e f4       	brtc	.+14     	; 0xde4 <__fixunssfsi+0x5c>
     dd6:	90 95       	com	r25
     dd8:	80 95       	com	r24
     dda:	70 95       	com	r23
     ddc:	61 95       	neg	r22
     dde:	7f 4f       	sbci	r23, 0xFF	; 255
     de0:	8f 4f       	sbci	r24, 0xFF	; 255
     de2:	9f 4f       	sbci	r25, 0xFF	; 255
     de4:	08 95       	ret

00000de6 <__floatunsisf>:
     de6:	e8 94       	clt
     de8:	09 c0       	rjmp	.+18     	; 0xdfc <__floatsisf+0x12>

00000dea <__floatsisf>:
     dea:	97 fb       	bst	r25, 7
     dec:	3e f4       	brtc	.+14     	; 0xdfc <__floatsisf+0x12>
     dee:	90 95       	com	r25
     df0:	80 95       	com	r24
     df2:	70 95       	com	r23
     df4:	61 95       	neg	r22
     df6:	7f 4f       	sbci	r23, 0xFF	; 255
     df8:	8f 4f       	sbci	r24, 0xFF	; 255
     dfa:	9f 4f       	sbci	r25, 0xFF	; 255
     dfc:	99 23       	and	r25, r25
     dfe:	a9 f0       	breq	.+42     	; 0xe2a <__floatsisf+0x40>
     e00:	f9 2f       	mov	r31, r25
     e02:	96 e9       	ldi	r25, 0x96	; 150
     e04:	bb 27       	eor	r27, r27
     e06:	93 95       	inc	r25
     e08:	f6 95       	lsr	r31
     e0a:	87 95       	ror	r24
     e0c:	77 95       	ror	r23
     e0e:	67 95       	ror	r22
     e10:	b7 95       	ror	r27
     e12:	f1 11       	cpse	r31, r1
     e14:	f8 cf       	rjmp	.-16     	; 0xe06 <__floatsisf+0x1c>
     e16:	fa f4       	brpl	.+62     	; 0xe56 <__floatsisf+0x6c>
     e18:	bb 0f       	add	r27, r27
     e1a:	11 f4       	brne	.+4      	; 0xe20 <__floatsisf+0x36>
     e1c:	60 ff       	sbrs	r22, 0
     e1e:	1b c0       	rjmp	.+54     	; 0xe56 <__floatsisf+0x6c>
     e20:	6f 5f       	subi	r22, 0xFF	; 255
     e22:	7f 4f       	sbci	r23, 0xFF	; 255
     e24:	8f 4f       	sbci	r24, 0xFF	; 255
     e26:	9f 4f       	sbci	r25, 0xFF	; 255
     e28:	16 c0       	rjmp	.+44     	; 0xe56 <__floatsisf+0x6c>
     e2a:	88 23       	and	r24, r24
     e2c:	11 f0       	breq	.+4      	; 0xe32 <__floatsisf+0x48>
     e2e:	96 e9       	ldi	r25, 0x96	; 150
     e30:	11 c0       	rjmp	.+34     	; 0xe54 <__floatsisf+0x6a>
     e32:	77 23       	and	r23, r23
     e34:	21 f0       	breq	.+8      	; 0xe3e <__floatsisf+0x54>
     e36:	9e e8       	ldi	r25, 0x8E	; 142
     e38:	87 2f       	mov	r24, r23
     e3a:	76 2f       	mov	r23, r22
     e3c:	05 c0       	rjmp	.+10     	; 0xe48 <__floatsisf+0x5e>
     e3e:	66 23       	and	r22, r22
     e40:	71 f0       	breq	.+28     	; 0xe5e <__floatsisf+0x74>
     e42:	96 e8       	ldi	r25, 0x86	; 134
     e44:	86 2f       	mov	r24, r22
     e46:	70 e0       	ldi	r23, 0x00	; 0
     e48:	60 e0       	ldi	r22, 0x00	; 0
     e4a:	2a f0       	brmi	.+10     	; 0xe56 <__floatsisf+0x6c>
     e4c:	9a 95       	dec	r25
     e4e:	66 0f       	add	r22, r22
     e50:	77 1f       	adc	r23, r23
     e52:	88 1f       	adc	r24, r24
     e54:	da f7       	brpl	.-10     	; 0xe4c <__floatsisf+0x62>
     e56:	88 0f       	add	r24, r24
     e58:	96 95       	lsr	r25
     e5a:	87 95       	ror	r24
     e5c:	97 f9       	bld	r25, 7
     e5e:	08 95       	ret

00000e60 <__fp_cmp>:
     e60:	99 0f       	add	r25, r25
     e62:	00 08       	sbc	r0, r0
     e64:	55 0f       	add	r21, r21
     e66:	aa 0b       	sbc	r26, r26
     e68:	e0 e8       	ldi	r30, 0x80	; 128
     e6a:	fe ef       	ldi	r31, 0xFE	; 254
     e6c:	16 16       	cp	r1, r22
     e6e:	17 06       	cpc	r1, r23
     e70:	e8 07       	cpc	r30, r24
     e72:	f9 07       	cpc	r31, r25
     e74:	c0 f0       	brcs	.+48     	; 0xea6 <__fp_cmp+0x46>
     e76:	12 16       	cp	r1, r18
     e78:	13 06       	cpc	r1, r19
     e7a:	e4 07       	cpc	r30, r20
     e7c:	f5 07       	cpc	r31, r21
     e7e:	98 f0       	brcs	.+38     	; 0xea6 <__fp_cmp+0x46>
     e80:	62 1b       	sub	r22, r18
     e82:	73 0b       	sbc	r23, r19
     e84:	84 0b       	sbc	r24, r20
     e86:	95 0b       	sbc	r25, r21
     e88:	39 f4       	brne	.+14     	; 0xe98 <__fp_cmp+0x38>
     e8a:	0a 26       	eor	r0, r26
     e8c:	61 f0       	breq	.+24     	; 0xea6 <__fp_cmp+0x46>
     e8e:	23 2b       	or	r18, r19
     e90:	24 2b       	or	r18, r20
     e92:	25 2b       	or	r18, r21
     e94:	21 f4       	brne	.+8      	; 0xe9e <__fp_cmp+0x3e>
     e96:	08 95       	ret
     e98:	0a 26       	eor	r0, r26
     e9a:	09 f4       	brne	.+2      	; 0xe9e <__fp_cmp+0x3e>
     e9c:	a1 40       	sbci	r26, 0x01	; 1
     e9e:	a6 95       	lsr	r26
     ea0:	8f ef       	ldi	r24, 0xFF	; 255
     ea2:	81 1d       	adc	r24, r1
     ea4:	81 1d       	adc	r24, r1
     ea6:	08 95       	ret

00000ea8 <__fp_inf>:
     ea8:	97 f9       	bld	r25, 7
     eaa:	9f 67       	ori	r25, 0x7F	; 127
     eac:	80 e8       	ldi	r24, 0x80	; 128
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	60 e0       	ldi	r22, 0x00	; 0
     eb2:	08 95       	ret

00000eb4 <__fp_nan>:
     eb4:	9f ef       	ldi	r25, 0xFF	; 255
     eb6:	80 ec       	ldi	r24, 0xC0	; 192
     eb8:	08 95       	ret

00000eba <__fp_pscA>:
     eba:	00 24       	eor	r0, r0
     ebc:	0a 94       	dec	r0
     ebe:	16 16       	cp	r1, r22
     ec0:	17 06       	cpc	r1, r23
     ec2:	18 06       	cpc	r1, r24
     ec4:	09 06       	cpc	r0, r25
     ec6:	08 95       	ret

00000ec8 <__fp_pscB>:
     ec8:	00 24       	eor	r0, r0
     eca:	0a 94       	dec	r0
     ecc:	12 16       	cp	r1, r18
     ece:	13 06       	cpc	r1, r19
     ed0:	14 06       	cpc	r1, r20
     ed2:	05 06       	cpc	r0, r21
     ed4:	08 95       	ret

00000ed6 <__fp_round>:
     ed6:	09 2e       	mov	r0, r25
     ed8:	03 94       	inc	r0
     eda:	00 0c       	add	r0, r0
     edc:	11 f4       	brne	.+4      	; 0xee2 <__fp_round+0xc>
     ede:	88 23       	and	r24, r24
     ee0:	52 f0       	brmi	.+20     	; 0xef6 <__fp_round+0x20>
     ee2:	bb 0f       	add	r27, r27
     ee4:	40 f4       	brcc	.+16     	; 0xef6 <__fp_round+0x20>
     ee6:	bf 2b       	or	r27, r31
     ee8:	11 f4       	brne	.+4      	; 0xeee <__fp_round+0x18>
     eea:	60 ff       	sbrs	r22, 0
     eec:	04 c0       	rjmp	.+8      	; 0xef6 <__fp_round+0x20>
     eee:	6f 5f       	subi	r22, 0xFF	; 255
     ef0:	7f 4f       	sbci	r23, 0xFF	; 255
     ef2:	8f 4f       	sbci	r24, 0xFF	; 255
     ef4:	9f 4f       	sbci	r25, 0xFF	; 255
     ef6:	08 95       	ret

00000ef8 <__fp_split3>:
     ef8:	57 fd       	sbrc	r21, 7
     efa:	90 58       	subi	r25, 0x80	; 128
     efc:	44 0f       	add	r20, r20
     efe:	55 1f       	adc	r21, r21
     f00:	59 f0       	breq	.+22     	; 0xf18 <__fp_splitA+0x10>
     f02:	5f 3f       	cpi	r21, 0xFF	; 255
     f04:	71 f0       	breq	.+28     	; 0xf22 <__fp_splitA+0x1a>
     f06:	47 95       	ror	r20

00000f08 <__fp_splitA>:
     f08:	88 0f       	add	r24, r24
     f0a:	97 fb       	bst	r25, 7
     f0c:	99 1f       	adc	r25, r25
     f0e:	61 f0       	breq	.+24     	; 0xf28 <__fp_splitA+0x20>
     f10:	9f 3f       	cpi	r25, 0xFF	; 255
     f12:	79 f0       	breq	.+30     	; 0xf32 <__fp_splitA+0x2a>
     f14:	87 95       	ror	r24
     f16:	08 95       	ret
     f18:	12 16       	cp	r1, r18
     f1a:	13 06       	cpc	r1, r19
     f1c:	14 06       	cpc	r1, r20
     f1e:	55 1f       	adc	r21, r21
     f20:	f2 cf       	rjmp	.-28     	; 0xf06 <__fp_split3+0xe>
     f22:	46 95       	lsr	r20
     f24:	f1 df       	rcall	.-30     	; 0xf08 <__fp_splitA>
     f26:	08 c0       	rjmp	.+16     	; 0xf38 <__fp_splitA+0x30>
     f28:	16 16       	cp	r1, r22
     f2a:	17 06       	cpc	r1, r23
     f2c:	18 06       	cpc	r1, r24
     f2e:	99 1f       	adc	r25, r25
     f30:	f1 cf       	rjmp	.-30     	; 0xf14 <__fp_splitA+0xc>
     f32:	86 95       	lsr	r24
     f34:	71 05       	cpc	r23, r1
     f36:	61 05       	cpc	r22, r1
     f38:	08 94       	sec
     f3a:	08 95       	ret

00000f3c <__fp_zero>:
     f3c:	e8 94       	clt

00000f3e <__fp_szero>:
     f3e:	bb 27       	eor	r27, r27
     f40:	66 27       	eor	r22, r22
     f42:	77 27       	eor	r23, r23
     f44:	cb 01       	movw	r24, r22
     f46:	97 f9       	bld	r25, 7
     f48:	08 95       	ret

00000f4a <__gesf2>:
     f4a:	0e 94 30 07 	call	0xe60	; 0xe60 <__fp_cmp>
     f4e:	08 f4       	brcc	.+2      	; 0xf52 <__gesf2+0x8>
     f50:	8f ef       	ldi	r24, 0xFF	; 255
     f52:	08 95       	ret

00000f54 <__mulsf3>:
     f54:	0e 94 bd 07 	call	0xf7a	; 0xf7a <__mulsf3x>
     f58:	0c 94 6b 07 	jmp	0xed6	; 0xed6 <__fp_round>
     f5c:	0e 94 5d 07 	call	0xeba	; 0xeba <__fp_pscA>
     f60:	38 f0       	brcs	.+14     	; 0xf70 <__mulsf3+0x1c>
     f62:	0e 94 64 07 	call	0xec8	; 0xec8 <__fp_pscB>
     f66:	20 f0       	brcs	.+8      	; 0xf70 <__mulsf3+0x1c>
     f68:	95 23       	and	r25, r21
     f6a:	11 f0       	breq	.+4      	; 0xf70 <__mulsf3+0x1c>
     f6c:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__fp_inf>
     f70:	0c 94 5a 07 	jmp	0xeb4	; 0xeb4 <__fp_nan>
     f74:	11 24       	eor	r1, r1
     f76:	0c 94 9f 07 	jmp	0xf3e	; 0xf3e <__fp_szero>

00000f7a <__mulsf3x>:
     f7a:	0e 94 7c 07 	call	0xef8	; 0xef8 <__fp_split3>
     f7e:	70 f3       	brcs	.-36     	; 0xf5c <__mulsf3+0x8>

00000f80 <__mulsf3_pse>:
     f80:	95 9f       	mul	r25, r21
     f82:	c1 f3       	breq	.-16     	; 0xf74 <__mulsf3+0x20>
     f84:	95 0f       	add	r25, r21
     f86:	50 e0       	ldi	r21, 0x00	; 0
     f88:	55 1f       	adc	r21, r21
     f8a:	62 9f       	mul	r22, r18
     f8c:	f0 01       	movw	r30, r0
     f8e:	72 9f       	mul	r23, r18
     f90:	bb 27       	eor	r27, r27
     f92:	f0 0d       	add	r31, r0
     f94:	b1 1d       	adc	r27, r1
     f96:	63 9f       	mul	r22, r19
     f98:	aa 27       	eor	r26, r26
     f9a:	f0 0d       	add	r31, r0
     f9c:	b1 1d       	adc	r27, r1
     f9e:	aa 1f       	adc	r26, r26
     fa0:	64 9f       	mul	r22, r20
     fa2:	66 27       	eor	r22, r22
     fa4:	b0 0d       	add	r27, r0
     fa6:	a1 1d       	adc	r26, r1
     fa8:	66 1f       	adc	r22, r22
     faa:	82 9f       	mul	r24, r18
     fac:	22 27       	eor	r18, r18
     fae:	b0 0d       	add	r27, r0
     fb0:	a1 1d       	adc	r26, r1
     fb2:	62 1f       	adc	r22, r18
     fb4:	73 9f       	mul	r23, r19
     fb6:	b0 0d       	add	r27, r0
     fb8:	a1 1d       	adc	r26, r1
     fba:	62 1f       	adc	r22, r18
     fbc:	83 9f       	mul	r24, r19
     fbe:	a0 0d       	add	r26, r0
     fc0:	61 1d       	adc	r22, r1
     fc2:	22 1f       	adc	r18, r18
     fc4:	74 9f       	mul	r23, r20
     fc6:	33 27       	eor	r19, r19
     fc8:	a0 0d       	add	r26, r0
     fca:	61 1d       	adc	r22, r1
     fcc:	23 1f       	adc	r18, r19
     fce:	84 9f       	mul	r24, r20
     fd0:	60 0d       	add	r22, r0
     fd2:	21 1d       	adc	r18, r1
     fd4:	82 2f       	mov	r24, r18
     fd6:	76 2f       	mov	r23, r22
     fd8:	6a 2f       	mov	r22, r26
     fda:	11 24       	eor	r1, r1
     fdc:	9f 57       	subi	r25, 0x7F	; 127
     fde:	50 40       	sbci	r21, 0x00	; 0
     fe0:	9a f0       	brmi	.+38     	; 0x1008 <__mulsf3_pse+0x88>
     fe2:	f1 f0       	breq	.+60     	; 0x1020 <__mulsf3_pse+0xa0>
     fe4:	88 23       	and	r24, r24
     fe6:	4a f0       	brmi	.+18     	; 0xffa <__mulsf3_pse+0x7a>
     fe8:	ee 0f       	add	r30, r30
     fea:	ff 1f       	adc	r31, r31
     fec:	bb 1f       	adc	r27, r27
     fee:	66 1f       	adc	r22, r22
     ff0:	77 1f       	adc	r23, r23
     ff2:	88 1f       	adc	r24, r24
     ff4:	91 50       	subi	r25, 0x01	; 1
     ff6:	50 40       	sbci	r21, 0x00	; 0
     ff8:	a9 f7       	brne	.-22     	; 0xfe4 <__mulsf3_pse+0x64>
     ffa:	9e 3f       	cpi	r25, 0xFE	; 254
     ffc:	51 05       	cpc	r21, r1
     ffe:	80 f0       	brcs	.+32     	; 0x1020 <__mulsf3_pse+0xa0>
    1000:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__fp_inf>
    1004:	0c 94 9f 07 	jmp	0xf3e	; 0xf3e <__fp_szero>
    1008:	5f 3f       	cpi	r21, 0xFF	; 255
    100a:	e4 f3       	brlt	.-8      	; 0x1004 <__mulsf3_pse+0x84>
    100c:	98 3e       	cpi	r25, 0xE8	; 232
    100e:	d4 f3       	brlt	.-12     	; 0x1004 <__mulsf3_pse+0x84>
    1010:	86 95       	lsr	r24
    1012:	77 95       	ror	r23
    1014:	67 95       	ror	r22
    1016:	b7 95       	ror	r27
    1018:	f7 95       	ror	r31
    101a:	e7 95       	ror	r30
    101c:	9f 5f       	subi	r25, 0xFF	; 255
    101e:	c1 f7       	brne	.-16     	; 0x1010 <__mulsf3_pse+0x90>
    1020:	fe 2b       	or	r31, r30
    1022:	88 0f       	add	r24, r24
    1024:	91 1d       	adc	r25, r1
    1026:	96 95       	lsr	r25
    1028:	87 95       	ror	r24
    102a:	97 f9       	bld	r25, 7
    102c:	08 95       	ret

0000102e <_exit>:
    102e:	f8 94       	cli

00001030 <__stop_program>:
    1030:	ff cf       	rjmp	.-2      	; 0x1030 <__stop_program>
