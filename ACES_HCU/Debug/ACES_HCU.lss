
ACES_HCU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e48  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000ebc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002a  00800060  00800060  00000ebc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ebc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000eec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000f28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001251  00000000  00000000  00000fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000764  00000000  00000000  00002201  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000086b  00000000  00000000  00002965  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001a4  00000000  00000000  000031d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000498  00000000  00000000  00003374  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000451  00000000  00000000  0000380c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  00003c5d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 59 04 	jmp	0x8b2	; 0x8b2 <__vector_3>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__vector_5>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__vector_9>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	aa 38       	cpi	r26, 0x8A	; 138
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <main>
  74:	0c 94 22 07 	jmp	0xe44	; 0xe44 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <__vector_9>:
 *
 *  @param TIMER1_OVF_vect    The interrupt vector for the overflow of timer 1 
 *  @return Void
 */
ISR(TIMER1_OVF_vect)
{
  7c:	1f 92       	push	r1
  7e:	0f 92       	push	r0
  80:	0f b6       	in	r0, 0x3f	; 63
  82:	0f 92       	push	r0
  84:	11 24       	eor	r1, r1
  86:	8f 93       	push	r24
  88:	9f 93       	push	r25
	// The LED is on PD5
	alive_counter++;
  8a:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
  8e:	8f 5f       	subi	r24, 0xFF	; 255
  90:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
	if (alive_counter % 2 == 1)
  94:	80 ff       	sbrs	r24, 0
  96:	04 c0       	rjmp	.+8      	; 0xa0 <__vector_9+0x24>
	PORTD ^= (1 << Alive_LED);
  98:	92 b3       	in	r25, 0x12	; 18
  9a:	80 e2       	ldi	r24, 0x20	; 32
  9c:	89 27       	eor	r24, r25
  9e:	82 bb       	out	0x12, r24	; 18
		
	PORTB ^= (1 << Warm_LED);   // This will have the warming LED blink 0.5 sec on 0.5 sec off and the alive LED blinking twice as slow
  a0:	98 b3       	in	r25, 0x18	; 24
  a2:	82 e0       	ldi	r24, 0x02	; 2
  a4:	89 27       	eor	r24, r25
  a6:	88 bb       	out	0x18, r24	; 24
		
	// Now reset the register
	TCNT1 = 3036;  // The interrupt will clear automatically when this function is called
  a8:	8c ed       	ldi	r24, 0xDC	; 220
  aa:	9b e0       	ldi	r25, 0x0B	; 11
  ac:	9d bd       	out	0x2d, r25	; 45
  ae:	8c bd       	out	0x2c, r24	; 44
}
  b0:	9f 91       	pop	r25
  b2:	8f 91       	pop	r24
  b4:	0f 90       	pop	r0
  b6:	0f be       	out	0x3f, r0	; 63
  b8:	0f 90       	pop	r0
  ba:	1f 90       	pop	r1
  bc:	18 95       	reti

000000be <assign_bit>:
 *  @param[in] val The value, either 1 or 0, that the user would like the bit to be after the function call.
 *  @return void
 */
void assign_bit(volatile uint8_t *sfr,uint8_t bit, uint8_t val)
{
	if (val)      // This is for if I want the value to be a 1
  be:	44 23       	and	r20, r20
  c0:	59 f0       	breq	.+22     	; 0xd8 <assign_bit+0x1a>
	{
		val = (val << bit);
  c2:	50 e0       	ldi	r21, 0x00	; 0
  c4:	02 c0       	rjmp	.+4      	; 0xca <assign_bit+0xc>
  c6:	44 0f       	add	r20, r20
  c8:	55 1f       	adc	r21, r21
  ca:	6a 95       	dec	r22
  cc:	e2 f7       	brpl	.-8      	; 0xc6 <assign_bit+0x8>
		*sfr |= val;
  ce:	fc 01       	movw	r30, r24
  d0:	20 81       	ld	r18, Z
  d2:	42 2b       	or	r20, r18
  d4:	40 83       	st	Z, r20
  d6:	08 95       	ret
	}
	else             // This is for if I want the value to be a 0
	{
		val = ~(1 << bit);
  d8:	21 e0       	ldi	r18, 0x01	; 1
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	02 c0       	rjmp	.+4      	; 0xe2 <assign_bit+0x24>
  de:	22 0f       	add	r18, r18
  e0:	33 1f       	adc	r19, r19
  e2:	6a 95       	dec	r22
  e4:	e2 f7       	brpl	.-8      	; 0xde <assign_bit+0x20>
  e6:	20 95       	com	r18
		*sfr &= val;
  e8:	fc 01       	movw	r30, r24
  ea:	30 81       	ld	r19, Z
  ec:	23 23       	and	r18, r19
  ee:	20 83       	st	Z, r18
  f0:	08 95       	ret

000000f2 <Initial>:
 */
void Initial(void)
{
	// First setup the port directions for the PWM lines and the
	// 0 are inputs 1 are outputs
	DDRA = 0b10000000;          // Only PA7 is an output
  f2:	80 e8       	ldi	r24, 0x80	; 128
  f4:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0b11011010;         
  f6:	8a ed       	ldi	r24, 0xDA	; 218
  f8:	87 bb       	out	0x17, r24	; 23
	DDRC = 0xFF;                // Make all outputs
  fa:	8f ef       	ldi	r24, 0xFF	; 255
  fc:	84 bb       	out	0x14, r24	; 20
	DDRD = 0xFF;                // Make all outputs
  fe:	81 bb       	out	0x11, r24	; 17
	
	opMode = 0;     // This sets the function mode to heating mode
 100:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <opMode>
	desired_temp = 0;
 104:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <desired_temp>
	duty_cycle = (pump_m*fuelFlow + pump_b) / pump_tot_V;    // This is the initial guess for the fuel pump
 108:	89 e1       	ldi	r24, 0x19	; 25
 10a:	9a e6       	ldi	r25, 0x6A	; 106
 10c:	ad ea       	ldi	r26, 0xAD	; 173
 10e:	be e3       	ldi	r27, 0x3E	; 62
 110:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <duty_cycle>
 114:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <duty_cycle+0x1>
 118:	a0 93 70 00 	sts	0x0070, r26	; 0x800070 <duty_cycle+0x2>
 11c:	b0 93 71 00 	sts	0x0071, r27	; 0x800071 <duty_cycle+0x3>
	
	// Now calculate the number of pulses I expect per 0.262144 seconds (max time for an 8 bit timer with prescalar of 1024)
	float pulse_flow = (fuelFlow / density) * K_factor * max_time / 1000;
	V_per_pulse = pump_m * (fuelFlow / pulse_flow);
 120:	80 e6       	ldi	r24, 0x60	; 96
 122:	90 ef       	ldi	r25, 0xF0	; 240
 124:	a3 e5       	ldi	r26, 0x53	; 83
 126:	bc e3       	ldi	r27, 0x3C	; 60
 128:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <V_per_pulse>
 12c:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <V_per_pulse+0x1>
 130:	a0 93 6c 00 	sts	0x006C, r26	; 0x80006c <V_per_pulse+0x2>
 134:	b0 93 6d 00 	sts	0x006D, r27	; 0x80006d <V_per_pulse+0x3>
	desired_pulses = (uint8_t) pulse_flow;                                    // round down and convert to an 8 bit number.  I expect it to be 170 so it will fit.
 138:	8d e8       	ldi	r24, 0x8D	; 141
 13a:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <desired_pulses>
	pulse_error_allow = (uint8_t)(desired_pulses * (fuelError / fuelFlow));   // This is the amount of pulses I can be off for it to still be considered a successes
 13e:	83 e0       	ldi	r24, 0x03	; 3
 140:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	assign_bit(&MCUCSR,ISC2,1);                                               // This will cause interrupts for INT2 to be caused on the rising edge
 144:	41 e0       	ldi	r20, 0x01	; 1
 146:	66 e0       	ldi	r22, 0x06	; 6
 148:	84 e5       	ldi	r24, 0x54	; 84
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&GIFR, INTF2, 1);                                              // Make sure the interrupt flag is cleared
 150:	41 e0       	ldi	r20, 0x01	; 1
 152:	65 e0       	ldi	r22, 0x05	; 5
 154:	8a e5       	ldi	r24, 0x5A	; 90
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	
	// Configure the ADC
	ADCSRA |= 1 << ADPS2;   // This is so there is a prescalar of 16.  ADC needs frequency between 50-200kHz so 1,000,000/16 puts it in this range.
 15c:	86 b1       	in	r24, 0x06	; 6
 15e:	84 60       	ori	r24, 0x04	; 4
 160:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= 1 << ADEN;    // Enable the ADC
 162:	86 b1       	in	r24, 0x06	; 6
 164:	80 68       	ori	r24, 0x80	; 128
 166:	86 b9       	out	0x06, r24	; 6
	ADMUX |= 1 << REFS0;    // Make AVCC (5V) the reference voltage
 168:	87 b1       	in	r24, 0x07	; 7
 16a:	80 64       	ori	r24, 0x40	; 64
 16c:	87 b9       	out	0x07, r24	; 7

	sei();       // This sets the global interrupt flag to allow for hardware interrupts
 16e:	78 94       	sei
	
	// Now enable the timer1 for 0.5 sec
	TIMSK |= 1 << TOIE1;                 // turn on overflow interrupts
 170:	89 b7       	in	r24, 0x39	; 57
 172:	84 60       	ori	r24, 0x04	; 4
 174:	89 bf       	out	0x39, r24	; 57
	TCCR1B |= (1<<CS11);                 // This has a prescalar of 8
 176:	8e b5       	in	r24, 0x2e	; 46
 178:	82 60       	ori	r24, 0x02	; 2
 17a:	8e bd       	out	0x2e, r24	; 46
	TCNT1 = 3036;                        // This will load the value so that when using a prescalar of 8, it will overflow after 500ms
 17c:	8c ed       	ldi	r24, 0xDC	; 220
 17e:	9b e0       	ldi	r25, 0x0B	; 11
 180:	9d bd       	out	0x2d, r25	; 45
 182:	8c bd       	out	0x2c, r24	; 44
	
	saveTemps[0] = -100.0;        // Assign initial temperature values that for sure will be colder than the specified temps 
 184:	e2 e7       	ldi	r30, 0x72	; 114
 186:	f0 e0       	ldi	r31, 0x00	; 0
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	a8 ec       	ldi	r26, 0xC8	; 200
 18e:	b2 ec       	ldi	r27, 0xC2	; 194
 190:	80 83       	st	Z, r24
 192:	91 83       	std	Z+1, r25	; 0x01
 194:	a2 83       	std	Z+2, r26	; 0x02
 196:	b3 83       	std	Z+3, r27	; 0x03
	saveTemps[1] = -100.0;
 198:	84 83       	std	Z+4, r24	; 0x04
 19a:	95 83       	std	Z+5, r25	; 0x05
 19c:	a6 83       	std	Z+6, r26	; 0x06
 19e:	b7 83       	std	Z+7, r27	; 0x07
	saveTemps[2] = -100.0;
 1a0:	80 87       	std	Z+8, r24	; 0x08
 1a2:	91 87       	std	Z+9, r25	; 0x09
 1a4:	a2 87       	std	Z+10, r26	; 0x0a
 1a6:	b3 87       	std	Z+11, r27	; 0x0b
	saveTemps[3] = -100.0;
 1a8:	84 87       	std	Z+12, r24	; 0x0c
 1aa:	95 87       	std	Z+13, r25	; 0x0d
 1ac:	a6 87       	std	Z+14, r26	; 0x0e
 1ae:	b7 87       	std	Z+15, r27	; 0x0f
	saveTemps[4] = -100.0;
 1b0:	80 8b       	std	Z+16, r24	; 0x10
 1b2:	91 8b       	std	Z+17, r25	; 0x11
 1b4:	a2 8b       	std	Z+18, r26	; 0x12
 1b6:	b3 8b       	std	Z+19, r27	; 0x13
	saveTemps[5] = -100.0;
 1b8:	84 8b       	std	Z+20, r24	; 0x14
 1ba:	95 8b       	std	Z+21, r25	; 0x15
 1bc:	a6 8b       	std	Z+22, r26	; 0x16
 1be:	b7 8b       	std	Z+23, r27	; 0x17
	saveTemps[6] = -100.0; 
 1c0:	80 8f       	std	Z+24, r24	; 0x18
 1c2:	91 8f       	std	Z+25, r25	; 0x19
 1c4:	a2 8f       	std	Z+26, r26	; 0x1a
 1c6:	b3 8f       	std	Z+27, r27	; 0x1b
	
	// Now I need to turn on all of the heaters as well as set the duty cycles for the PWMs which will be on timers 0 and 2
	// Start with the PWM for the ECU, this will be on timer0
	TCNT0 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
 1c8:	12 be       	out	0x32, r1	; 50
	assign_bit(&TCCR0, WGM01, 1);
 1ca:	41 e0       	ldi	r20, 0x01	; 1
 1cc:	63 e0       	ldi	r22, 0x03	; 3
 1ce:	83 e5       	ldi	r24, 0x53	; 83
 1d0:	90 e0       	ldi	r25, 0x00	; 0
 1d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, WGM00, 1);      // These two set the PWM Mode to "Fast PWM"
 1d6:	41 e0       	ldi	r20, 0x01	; 1
 1d8:	66 e0       	ldi	r22, 0x06	; 6
 1da:	83 e5       	ldi	r24, 0x53	; 83
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM01, 1); 
 1e2:	41 e0       	ldi	r20, 0x01	; 1
 1e4:	65 e0       	ldi	r22, 0x05	; 5
 1e6:	83 e5       	ldi	r24, 0x53	; 83
 1e8:	90 e0       	ldi	r25, 0x00	; 0
 1ea:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0, COM00, 1);      // These two set the PWM type to inverting PWM
 1ee:	41 e0       	ldi	r20, 0x01	; 1
 1f0:	64 e0       	ldi	r22, 0x04	; 4
 1f2:	83 e5       	ldi	r24, 0x53	; 83
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	OCR0 = 255 - (255*ECU_duty);       // This will set it to the specified duty by the #define
 1fa:	8f e7       	ldi	r24, 0x7F	; 127
 1fc:	8c bf       	out	0x3c, r24	; 60
	
	TCCR0 |= (1 << CS02);              // This will start the PWM with a duty cycle of 65.536 ms
 1fe:	83 b7       	in	r24, 0x33	; 51
 200:	84 60       	ori	r24, 0x04	; 4
 202:	83 bf       	out	0x33, r24	; 51
	
	// Now do the PWM for the second fuel line which will use Timer 2,  this will look very similar to the last few lines of code
	TCNT2 = 0;      // Clear the timer register to make sure I have the full range on the first cycle
 204:	14 bc       	out	0x24, r1	; 36
	assign_bit(&TCCR2, WGM21, 1);
 206:	41 e0       	ldi	r20, 0x01	; 1
 208:	63 e0       	ldi	r22, 0x03	; 3
 20a:	85 e4       	ldi	r24, 0x45	; 69
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, WGM20, 1);      // These two set the PWM Mode to "Fast PWM"
 212:	41 e0       	ldi	r20, 0x01	; 1
 214:	66 e0       	ldi	r22, 0x06	; 6
 216:	85 e4       	ldi	r24, 0x45	; 69
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM21, 1);
 21e:	41 e0       	ldi	r20, 0x01	; 1
 220:	65 e0       	ldi	r22, 0x05	; 5
 222:	85 e4       	ldi	r24, 0x45	; 69
 224:	90 e0       	ldi	r25, 0x00	; 0
 226:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR2, COM20, 1);      // These two set the PWM type to inverting PWM
 22a:	41 e0       	ldi	r20, 0x01	; 1
 22c:	64 e0       	ldi	r22, 0x04	; 4
 22e:	85 e4       	ldi	r24, 0x45	; 69
 230:	90 e0       	ldi	r25, 0x00	; 0
 232:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
	OCR2 = 255 - (255*F_line_duty);    // This will set it to the specified duty by the #define
 236:	89 ec       	ldi	r24, 0xC9	; 201
 238:	83 bd       	out	0x23, r24	; 35
		
	TCCR2 |= (1 << CS22);              // This will start the PWM with a duty cycle of 65.536 ms, just like before
 23a:	85 b5       	in	r24, 0x25	; 37
 23c:	84 60       	ori	r24, 0x04	; 4
 23e:	85 bd       	out	0x25, r24	; 37
	
	// Now turn on all the other heaters
	assign_bit(&PORTD, BatPin, 1);
 240:	41 e0       	ldi	r20, 0x01	; 1
 242:	60 e0       	ldi	r22, 0x00	; 0
 244:	82 e3       	ldi	r24, 0x32	; 50
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, HopperPin, 1);
 24c:	41 e0       	ldi	r20, 0x01	; 1
 24e:	61 e0       	ldi	r22, 0x01	; 1
 250:	82 e3       	ldi	r24, 0x32	; 50
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, FLine1Pin, 1);
 258:	41 e0       	ldi	r20, 0x01	; 1
 25a:	62 e0       	ldi	r22, 0x02	; 2
 25c:	82 e3       	ldi	r24, 0x32	; 50
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&PORTD, ESB_Pin, 1);     // I can omit doing this for the ECU and FuelLine1
 264:	41 e0       	ldi	r20, 0x01	; 1
 266:	63 e0       	ldi	r22, 0x03	; 3
 268:	82 e3       	ldi	r24, 0x32	; 50
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 270:	08 95       	ret

00000272 <flowMeter>:
 *  @param void
 *  @return void
 *  @note Need to do a pump test to ensure that the voltage to flow rate function is actually correct.
 */
void flowMeter(void)
{
 272:	cf 92       	push	r12
 274:	df 92       	push	r13
 276:	ef 92       	push	r14
 278:	ff 92       	push	r15
 27a:	0f 93       	push	r16
 27c:	1f 93       	push	r17
 27e:	cf 93       	push	r28
 280:	df 93       	push	r29
	for (unsigned i = 0; i < 14; i++){
		_delay_ms(250);                 // this should delay for 3.5 seconds
	}*/
	
	// First I need to enable interrupt on INT2
	pulse_count = 0;
 282:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <pulse_count>
	GICR |= (1 << INT2);     // enable INT2 external interrupts
 286:	8b b7       	in	r24, 0x3b	; 59
 288:	80 62       	ori	r24, 0x20	; 32
 28a:	8b bf       	out	0x3b, r24	; 59
	
	
	// Second I need to begin timer0
	TCNT0 = 0;                                 // Make sure the timer/counter register is cleared so the full range can be used
 28c:	12 be       	out	0x32, r1	; 50
	assign_bit(&TIFR,TOV1,1);                  // Make sure the overflow flag is set
 28e:	41 e0       	ldi	r20, 0x01	; 1
 290:	62 e0       	ldi	r22, 0x02	; 2
 292:	88 e5       	ldi	r24, 0x58	; 88
 294:	90 e0       	ldi	r25, 0x00	; 0
 296:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS02,1);
 29a:	41 e0       	ldi	r20, 0x01	; 1
 29c:	62 e0       	ldi	r22, 0x02	; 2
 29e:	83 e5       	ldi	r24, 0x53	; 83
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS01,0);
 2a6:	40 e0       	ldi	r20, 0x00	; 0
 2a8:	61 e0       	ldi	r22, 0x01	; 1
 2aa:	83 e5       	ldi	r24, 0x53	; 83
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&TCCR0,CS00,1);                 // TThis will start the timer with a prescalar of 1024
 2b2:	41 e0       	ldi	r20, 0x01	; 1
 2b4:	60 e0       	ldi	r22, 0x00	; 0
 2b6:	83 e5       	ldi	r24, 0x53	; 83
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	while (!(TIFR & 0x01));                    // Hog the execution until the overflow flag is set
 2be:	08 b6       	in	r0, 0x38	; 56
 2c0:	00 fe       	sbrs	r0, 0
 2c2:	fd cf       	rjmp	.-6      	; 0x2be <flowMeter+0x4c>
	
	assign_bit(&GICR, INT2, 0);                // disable external interrupts for INT2
 2c4:	40 e0       	ldi	r20, 0x00	; 0
 2c6:	65 e0       	ldi	r22, 0x05	; 5
 2c8:	8b e5       	ldi	r24, 0x5B	; 91
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	/*for (unsigned i = 0; i < 14; i++){      // delay for another 3.5 sec for a total of 7 seconds.  we should have enough fuel for this
		_delay_ms(250);	
	}
	assign_bit(&PORTB, PB4, 0);            // turn off the pump   NEED TO DELETE THIS LINE LATER
	*/	
	if (!pulse_count)                          // There is either no more fuel or there is a stoppage.  This if statement might be the end of me...
 2d0:	60 91 68 00 	lds	r22, 0x0068	; 0x800068 <pulse_count>
 2d4:	61 11       	cpse	r22, r1
 2d6:	1b c0       	rjmp	.+54     	; 0x30e <flowMeter+0x9c>
	{
		opMode = 2;                            //  This means that the pumping has concluded
 2d8:	82 e0       	ldi	r24, 0x02	; 2
 2da:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
		assign_bit(&TCCR1B, CS10, 0);          // This should stop the PWM for the pump
 2de:	40 e0       	ldi	r20, 0x00	; 0
 2e0:	8e e4       	ldi	r24, 0x4E	; 78
 2e2:	90 e0       	ldi	r25, 0x00	; 0
 2e4:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&PORTD, Fuel_LED, 1);
 2e8:	41 e0       	ldi	r20, 0x01	; 1
 2ea:	66 e0       	ldi	r22, 0x06	; 6
 2ec:	82 e3       	ldi	r24, 0x32	; 50
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCNT2 = 60;                               // Value needed for the timer to run for 0.05 second
 2f4:	8c e3       	ldi	r24, 0x3C	; 60
 2f6:	84 bd       	out	0x24, r24	; 36
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
 2f8:	41 e0       	ldi	r20, 0x01	; 1
 2fa:	65 e0       	ldi	r22, 0x05	; 5
 2fc:	82 e3       	ldi	r24, 0x32	; 50
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		alive_counter = 0;                        // reset the hand made prescalar
 304:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
		TCCR2 = 0x06;                             // This will start the Timer with a prescalar of 256 and stop the PWM stuff
 308:	86 e0       	ldi	r24, 0x06	; 6
 30a:	85 bd       	out	0x25, r24	; 37
 30c:	67 c0       	rjmp	.+206    	; 0x3dc <flowMeter+0x16a>
		
	}
	else
	{
		// Now I need to compare the number of pulses I got with what I should have received
		int8_t pulse_error = desired_pulses - pulse_count;   // This will be able to handle negative numbers
 30e:	c0 91 69 00 	lds	r28, 0x0069	; 0x800069 <desired_pulses>
 312:	c6 1b       	sub	r28, r22
 314:	dc 2f       	mov	r29, r28
		measured_flow = V_per_pulse * (float) pulse_count;
 316:	70 e0       	ldi	r23, 0x00	; 0
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	90 e0       	ldi	r25, 0x00	; 0
 31c:	0e 94 fe 05 	call	0xbfc	; 0xbfc <__floatunsisf>
 320:	c0 90 6a 00 	lds	r12, 0x006A	; 0x80006a <V_per_pulse>
 324:	d0 90 6b 00 	lds	r13, 0x006B	; 0x80006b <V_per_pulse+0x1>
 328:	e0 90 6c 00 	lds	r14, 0x006C	; 0x80006c <V_per_pulse+0x2>
 32c:	f0 90 6d 00 	lds	r15, 0x006D	; 0x80006d <V_per_pulse+0x3>
 330:	a7 01       	movw	r20, r14
 332:	96 01       	movw	r18, r12
 334:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__mulsf3>
		measured_flow = (measured_flow - pump_b) / pump_m;
 338:	27 e5       	ldi	r18, 0x57	; 87
 33a:	3b e7       	ldi	r19, 0x7B	; 123
 33c:	48 e4       	ldi	r20, 0x48	; 72
 33e:	5e e3       	ldi	r21, 0x3E	; 62
 340:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <__subsf3>
 344:	21 e7       	ldi	r18, 0x71	; 113
 346:	32 ee       	ldi	r19, 0xE2	; 226
 348:	43 ec       	ldi	r20, 0xC3	; 195
 34a:	5e e3       	ldi	r21, 0x3E	; 62
 34c:	0e 94 56 05 	call	0xaac	; 0xaac <__divsf3>
 350:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <measured_flow>
 354:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <measured_flow+0x1>
 358:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <measured_flow+0x2>
 35c:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <measured_flow+0x3>
		float change = (float) pulse_error * V_per_pulse * ((float) ICR1) / pump_tot_V;   // Check page 94 in notebook for correct derivation.
 360:	6c 2f       	mov	r22, r28
 362:	0c 2e       	mov	r0, r28
 364:	00 0c       	add	r0, r0
 366:	77 0b       	sbc	r23, r23
 368:	88 0b       	sbc	r24, r24
 36a:	99 0b       	sbc	r25, r25
 36c:	0e 94 00 06 	call	0xc00	; 0xc00 <__floatsisf>
 370:	9b 01       	movw	r18, r22
 372:	ac 01       	movw	r20, r24
 374:	c7 01       	movw	r24, r14
 376:	b6 01       	movw	r22, r12
 378:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__mulsf3>
 37c:	6b 01       	movw	r12, r22
 37e:	7c 01       	movw	r14, r24
 380:	66 b5       	in	r22, 0x26	; 38
 382:	77 b5       	in	r23, 0x27	; 39
 384:	80 e0       	ldi	r24, 0x00	; 0
 386:	90 e0       	ldi	r25, 0x00	; 0
 388:	0e 94 fe 05 	call	0xbfc	; 0xbfc <__floatunsisf>
 38c:	9b 01       	movw	r18, r22
 38e:	ac 01       	movw	r20, r24
 390:	c7 01       	movw	r24, r14
 392:	b6 01       	movw	r22, r12
 394:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__mulsf3>
 398:	20 e0       	ldi	r18, 0x00	; 0
 39a:	30 e0       	ldi	r19, 0x00	; 0
 39c:	40 ec       	ldi	r20, 0xC0	; 192
 39e:	50 e4       	ldi	r21, 0x40	; 64
 3a0:	0e 94 56 05 	call	0xaac	; 0xaac <__divsf3>
		OCR1B -= (uint16_t) change;   
 3a4:	08 b5       	in	r16, 0x28	; 40
 3a6:	19 b5       	in	r17, 0x29	; 41
 3a8:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__fixunssfsi>
 3ac:	06 1b       	sub	r16, r22
 3ae:	17 0b       	sbc	r17, r23
 3b0:	19 bd       	out	0x29, r17	; 41
 3b2:	08 bd       	out	0x28, r16	; 40
		// The above line should immediately change the PWM as well
		
		if (pulse_error < 0)
 3b4:	cc 23       	and	r28, r28
 3b6:	0c f4       	brge	.+2      	; 0x3ba <flowMeter+0x148>
			pulse_error = -pulse_error;          // Make it the absolute value 
 3b8:	d1 95       	neg	r29
		if (pulse_error <= pulse_error_allow)    // mission is a success
 3ba:	8d 2f       	mov	r24, r29
 3bc:	dd 0f       	add	r29, r29
 3be:	99 0b       	sbc	r25, r25
 3c0:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <_edata>
 3c4:	30 e0       	ldi	r19, 0x00	; 0
 3c6:	28 17       	cp	r18, r24
 3c8:	39 07       	cpc	r19, r25
 3ca:	24 f0       	brlt	.+8      	; 0x3d4 <flowMeter+0x162>
			PORTD |= (1 << Fuel_LED);            // Make the fuel LED just stay on
 3cc:	82 b3       	in	r24, 0x12	; 18
 3ce:	80 64       	ori	r24, 0x40	; 64
 3d0:	82 bb       	out	0x12, r24	; 18
 3d2:	04 c0       	rjmp	.+8      	; 0x3dc <flowMeter+0x16a>
		else
			PORTD ^= (1 << Fuel_LED);            // Make the fuel LED blink saying that it is not done yet.
 3d4:	92 b3       	in	r25, 0x12	; 18
 3d6:	80 e4       	ldi	r24, 0x40	; 64
 3d8:	89 27       	eor	r24, r25
 3da:	82 bb       	out	0x12, r24	; 18
	
	}
}
 3dc:	df 91       	pop	r29
 3de:	cf 91       	pop	r28
 3e0:	1f 91       	pop	r17
 3e2:	0f 91       	pop	r16
 3e4:	ff 90       	pop	r15
 3e6:	ef 90       	pop	r14
 3e8:	df 90       	pop	r13
 3ea:	cf 90       	pop	r12
 3ec:	08 95       	ret

000003ee <ECU_toggle>:
 *  @param[in] ECU_mode This variable denote which mode the system is configured in. 0 for dummy ECU, 1 for operational ECU
 *  @return void
 */
void ECU_toggle(uint8_t ECU_mode)
{
	assign_bit(&PORTA, ECUon_Pin, ECU_mode);   // make sure the ECU has its power circuit closed if it is an operational ECU
 3ee:	48 2f       	mov	r20, r24
 3f0:	67 e0       	ldi	r22, 0x07	; 7
 3f2:	8b e3       	ldi	r24, 0x3B	; 59
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 3fa:	08 95       	ret

000003fc <change_timers>:
 *  @param void
 *  @return void
 *  @see flowMeter
 */
void change_timers(void)
{
 3fc:	cf 93       	push	r28
 3fe:	df 93       	push	r29
	opMode = 1;                          // Change the operational mode
 400:	81 e0       	ldi	r24, 0x01	; 1
 402:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <opMode>
	assign_bit(&PORTB,Warm_LED,1);    // Turn on the LED to signal the heating sequence is complete
 406:	41 e0       	ldi	r20, 0x01	; 1
 408:	61 e0       	ldi	r22, 0x01	; 1
 40a:	88 e3       	ldi	r24, 0x38	; 56
 40c:	90 e0       	ldi	r25, 0x00	; 0
 40e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	ECU_toggle(ECU_present);
 412:	80 e0       	ldi	r24, 0x00	; 0
 414:	0e 94 f7 01 	call	0x3ee	; 0x3ee <ECU_toggle>
	// Now need to assign timer 2 to the alive LED
	
	if (!ECU_present)
	{
		// First change Timer 1 to serve as the PWM output port for the pump
		assign_bit(&TIMSK,TOIE1,0);    // remove overflow interrupts for timer 1
 418:	40 e0       	ldi	r20, 0x00	; 0
 41a:	62 e0       	ldi	r22, 0x02	; 2
 41c:	89 e5       	ldi	r24, 0x59	; 89
 41e:	90 e0       	ldi	r25, 0x00	; 0
 420:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TCCR1A |= (1 << WGM11);     // The sets one of the bits for the mode 14 waveform
 424:	8f b5       	in	r24, 0x2f	; 47
 426:	82 60       	ori	r24, 0x02	; 2
 428:	8f bd       	out	0x2f, r24	; 47
		TCCR1B |= (1 << WGM12) | (1 << WGM13);   // This sets the other two bits for the waveform generation
 42a:	8e b5       	in	r24, 0x2e	; 46
 42c:	88 61       	ori	r24, 0x18	; 24
 42e:	8e bd       	out	0x2e, r24	; 46
		TCCR1A |= (1 << COM1B1) | (1 << COM1B0);   // These set the output mode
 430:	8f b5       	in	r24, 0x2f	; 47
 432:	80 63       	ori	r24, 0x30	; 48
 434:	8f bd       	out	0x2f, r24	; 47
		ICR1 = 20000;     // this will set the period of oscillation to 20ms
 436:	80 e2       	ldi	r24, 0x20	; 32
 438:	9e e4       	ldi	r25, 0x4E	; 78
 43a:	97 bd       	out	0x27, r25	; 39
 43c:	86 bd       	out	0x26, r24	; 38
			
		OCR1B = ICR1 - (int)(ICR1*duty_cycle);     // This will set the count at which the PWM will change to on. Also make sure to round down to int
 43e:	c6 b5       	in	r28, 0x26	; 38
 440:	d7 b5       	in	r29, 0x27	; 39
 442:	66 b5       	in	r22, 0x26	; 38
 444:	77 b5       	in	r23, 0x27	; 39
 446:	80 e0       	ldi	r24, 0x00	; 0
 448:	90 e0       	ldi	r25, 0x00	; 0
 44a:	0e 94 fe 05 	call	0xbfc	; 0xbfc <__floatunsisf>
 44e:	20 91 6e 00 	lds	r18, 0x006E	; 0x80006e <duty_cycle>
 452:	30 91 6f 00 	lds	r19, 0x006F	; 0x80006f <duty_cycle+0x1>
 456:	40 91 70 00 	lds	r20, 0x0070	; 0x800070 <duty_cycle+0x2>
 45a:	50 91 71 00 	lds	r21, 0x0071	; 0x800071 <duty_cycle+0x3>
 45e:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__mulsf3>
 462:	0e 94 c8 05 	call	0xb90	; 0xb90 <__fixsfsi>
 466:	c6 1b       	sub	r28, r22
 468:	d7 0b       	sbc	r29, r23
 46a:	d9 bd       	out	0x29, r29	; 41
 46c:	c8 bd       	out	0x28, r28	; 40
		assign_bit(&TCCR1B, CS10, 1);              // This should start the PWM with a prescalar of 1
 46e:	41 e0       	ldi	r20, 0x01	; 1
 470:	60 e0       	ldi	r22, 0x00	; 0
 472:	8e e4       	ldi	r24, 0x4E	; 78
 474:	90 e0       	ldi	r25, 0x00	; 0
 476:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		// Now the PWM should be running
			
		// Second change Timer0 to serve as the counter for the pulse train from the flow meter
		TCCR0 = 0;                                 // Turn off the PWM so the ECU stops being warmed
 47a:	13 be       	out	0x33, r1	; 51
		assign_bit(&TCCR0,CS02,0);
 47c:	40 e0       	ldi	r20, 0x00	; 0
 47e:	62 e0       	ldi	r22, 0x02	; 2
 480:	83 e5       	ldi	r24, 0x53	; 83
 482:	90 e0       	ldi	r25, 0x00	; 0
 484:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS01,0);
 488:	40 e0       	ldi	r20, 0x00	; 0
 48a:	61 e0       	ldi	r22, 0x01	; 1
 48c:	83 e5       	ldi	r24, 0x53	; 83
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&TCCR0,CS00,0);                 // TThis will make sure that the timer is stopped for now	
 494:	40 e0       	ldi	r20, 0x00	; 0
 496:	60 e0       	ldi	r22, 0x00	; 0
 498:	83 e5       	ldi	r24, 0x53	; 83
 49a:	90 e0       	ldi	r25, 0x00	; 0
 49c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		// Third set the MCU Control and Status Register for the Interrupt Sense Control 2
		MCUCSR |= (1 << ISC2);                    // This will make interrupts occur on the rising edge, so the beginning of the pulse
 4a0:	84 b7       	in	r24, 0x34	; 52
 4a2:	80 64       	ori	r24, 0x40	; 64
 4a4:	84 bf       	out	0x34, r24	; 52
		
		// Fourth set Timer2 for the 0.75/0.25 second blink of the Alive LED
		assign_bit(&PORTD, Alive_LED, 1);         // Start with turning on the LED
 4a6:	41 e0       	ldi	r20, 0x01	; 1
 4a8:	65 e0       	ldi	r22, 0x05	; 5
 4aa:	82 e3       	ldi	r24, 0x32	; 50
 4ac:	90 e0       	ldi	r25, 0x00	; 0
 4ae:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		TIMSK |= (1 << TOIE2);                    // Enable overflow interrupts on the timer
 4b2:	89 b7       	in	r24, 0x39	; 57
 4b4:	80 64       	ori	r24, 0x40	; 64
 4b6:	89 bf       	out	0x39, r24	; 57
		TCNT2 = 11;                               // This is the value needed for the timer to run for 0.25 seconds
 4b8:	8b e0       	ldi	r24, 0x0B	; 11
 4ba:	84 bd       	out	0x24, r24	; 36
		alive_counter = 0;                        // Reset the hand made prescalar
 4bc:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
		TCCR2 = 0x07;                             // Start the timer with a prescalar of 1024
 4c0:	87 e0       	ldi	r24, 0x07	; 7
 4c2:	85 bd       	out	0x25, r24	; 37
		TCCR1B = 0;         // This set is to prevent any unexpected triggering of the heating circuits
		TCCR1A = 0;
		
		
	}
}
 4c4:	df 91       	pop	r29
 4c6:	cf 91       	pop	r28
 4c8:	08 95       	ret

000004ca <tempHeaterHelper>:
 *  @return void
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
 4ca:	cf 92       	push	r12
 4cc:	df 92       	push	r13
 4ce:	ef 92       	push	r14
 4d0:	ff 92       	push	r15
 4d2:	cf 93       	push	r28
	for (uint8_t i = 0; i < 6; i++)
 4d4:	c0 e0       	ldi	r28, 0x00	; 0
 4d6:	5d c1       	rjmp	.+698    	; 0x792 <tempHeaterHelper+0x2c8>
	{
		switch(i){
 4d8:	c2 30       	cpi	r28, 0x02	; 2
 4da:	09 f4       	brne	.+2      	; 0x4de <tempHeaterHelper+0x14>
 4dc:	6f c0       	rjmp	.+222    	; 0x5bc <tempHeaterHelper+0xf2>
 4de:	28 f4       	brcc	.+10     	; 0x4ea <tempHeaterHelper+0x20>
 4e0:	cc 23       	and	r28, r28
 4e2:	61 f0       	breq	.+24     	; 0x4fc <tempHeaterHelper+0x32>
 4e4:	c1 30       	cpi	r28, 0x01	; 1
 4e6:	d1 f1       	breq	.+116    	; 0x55c <tempHeaterHelper+0x92>
 4e8:	53 c1       	rjmp	.+678    	; 0x790 <tempHeaterHelper+0x2c6>
 4ea:	c4 30       	cpi	r28, 0x04	; 4
 4ec:	09 f4       	brne	.+2      	; 0x4f0 <tempHeaterHelper+0x26>
 4ee:	dc c0       	rjmp	.+440    	; 0x6a8 <tempHeaterHelper+0x1de>
 4f0:	08 f4       	brcc	.+2      	; 0x4f4 <tempHeaterHelper+0x2a>
 4f2:	aa c0       	rjmp	.+340    	; 0x648 <tempHeaterHelper+0x17e>
 4f4:	c5 30       	cpi	r28, 0x05	; 5
 4f6:	09 f4       	brne	.+2      	; 0x4fa <tempHeaterHelper+0x30>
 4f8:	1d c1       	rjmp	.+570    	; 0x734 <tempHeaterHelper+0x26a>
 4fa:	4a c1       	rjmp	.+660    	; 0x790 <tempHeaterHelper+0x2c6>
			case 0:                             // This is the case for the Lipo batteries   //////////////////////////////////////////////
				if (saveTemps[0] > TempBat )    // safety first so make sure that the temperature always turns off if one of the batteries is getting too hot
 4fc:	c0 90 72 00 	lds	r12, 0x0072	; 0x800072 <saveTemps>
 500:	d0 90 73 00 	lds	r13, 0x0073	; 0x800073 <saveTemps+0x1>
 504:	e0 90 74 00 	lds	r14, 0x0074	; 0x800074 <saveTemps+0x2>
 508:	f0 90 75 00 	lds	r15, 0x0075	; 0x800075 <saveTemps+0x3>
 50c:	20 e0       	ldi	r18, 0x00	; 0
 50e:	30 e0       	ldi	r19, 0x00	; 0
 510:	40 e2       	ldi	r20, 0x20	; 32
 512:	51 e4       	ldi	r21, 0x41	; 65
 514:	c7 01       	movw	r24, r14
 516:	b6 01       	movw	r22, r12
 518:	0e 94 b0 06 	call	0xd60	; 0xd60 <__gesf2>
 51c:	18 16       	cp	r1, r24
 51e:	64 f4       	brge	.+24     	; 0x538 <tempHeaterHelper+0x6e>
				{
					desired_temp |= 0x01;
 520:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 524:	81 60       	ori	r24, 0x01	; 1
 526:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
					assign_bit(&PORTD, BatPin, 0);       // Turn the heater off if either of these get too high
 52a:	40 e0       	ldi	r20, 0x00	; 0
 52c:	60 e0       	ldi	r22, 0x00	; 0
 52e:	82 e3       	ldi	r24, 0x32	; 50
 530:	90 e0       	ldi	r25, 0x00	; 0
 532:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 536:	2c c1       	rjmp	.+600    	; 0x790 <tempHeaterHelper+0x2c6>
				}
				else if(saveTemps[0] < TempBat)
 538:	20 e0       	ldi	r18, 0x00	; 0
 53a:	30 e0       	ldi	r19, 0x00	; 0
 53c:	40 e2       	ldi	r20, 0x20	; 32
 53e:	51 e4       	ldi	r21, 0x41	; 65
 540:	c7 01       	movw	r24, r14
 542:	b6 01       	movw	r22, r12
 544:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__cmpsf2>
 548:	88 23       	and	r24, r24
 54a:	0c f0       	brlt	.+2      	; 0x54e <tempHeaterHelper+0x84>
 54c:	21 c1       	rjmp	.+578    	; 0x790 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, BatPin, 1);    // Turn the heater back on to warm them up
 54e:	41 e0       	ldi	r20, 0x01	; 1
 550:	60 e0       	ldi	r22, 0x00	; 0
 552:	82 e3       	ldi	r24, 0x32	; 50
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 55a:	1a c1       	rjmp	.+564    	; 0x790 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 1:       // This is the case for the Hopper    /////////////////////////////////////////////////
				if (saveTemps[2] < TempHopper)           // Temp is too low so turn on the heater
 55c:	c0 90 7a 00 	lds	r12, 0x007A	; 0x80007a <saveTemps+0x8>
 560:	d0 90 7b 00 	lds	r13, 0x007B	; 0x80007b <saveTemps+0x9>
 564:	e0 90 7c 00 	lds	r14, 0x007C	; 0x80007c <saveTemps+0xa>
 568:	f0 90 7d 00 	lds	r15, 0x007D	; 0x80007d <saveTemps+0xb>
 56c:	20 e0       	ldi	r18, 0x00	; 0
 56e:	30 e0       	ldi	r19, 0x00	; 0
 570:	40 e2       	ldi	r20, 0x20	; 32
 572:	51 e4       	ldi	r21, 0x41	; 65
 574:	c7 01       	movw	r24, r14
 576:	b6 01       	movw	r22, r12
 578:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__cmpsf2>
 57c:	88 23       	and	r24, r24
 57e:	3c f4       	brge	.+14     	; 0x58e <tempHeaterHelper+0xc4>
					assign_bit(&PORTD, HopperPin, 1);
 580:	41 e0       	ldi	r20, 0x01	; 1
 582:	61 e0       	ldi	r22, 0x01	; 1
 584:	82 e3       	ldi	r24, 0x32	; 50
 586:	90 e0       	ldi	r25, 0x00	; 0
 588:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 58c:	01 c1       	rjmp	.+514    	; 0x790 <tempHeaterHelper+0x2c6>
				else if(saveTemps[2] > TempHopper)
 58e:	20 e0       	ldi	r18, 0x00	; 0
 590:	30 e0       	ldi	r19, 0x00	; 0
 592:	40 e2       	ldi	r20, 0x20	; 32
 594:	51 e4       	ldi	r21, 0x41	; 65
 596:	c7 01       	movw	r24, r14
 598:	b6 01       	movw	r22, r12
 59a:	0e 94 b0 06 	call	0xd60	; 0xd60 <__gesf2>
 59e:	18 16       	cp	r1, r24
 5a0:	0c f0       	brlt	.+2      	; 0x5a4 <tempHeaterHelper+0xda>
 5a2:	f6 c0       	rjmp	.+492    	; 0x790 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, HopperPin, 0);    // Too hot so turn off
 5a4:	40 e0       	ldi	r20, 0x00	; 0
 5a6:	61 e0       	ldi	r22, 0x01	; 1
 5a8:	82 e3       	ldi	r24, 0x32	; 50
 5aa:	90 e0       	ldi	r25, 0x00	; 0
 5ac:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x02;				
 5b0:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 5b4:	82 60       	ori	r24, 0x02	; 2
 5b6:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 5ba:	ea c0       	rjmp	.+468    	; 0x790 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 2:       // This is the case for the ECU  /////////////////////////////////////////////////
				if (saveTemps[3] < TempECU)
 5bc:	c0 90 7e 00 	lds	r12, 0x007E	; 0x80007e <saveTemps+0xc>
 5c0:	d0 90 7f 00 	lds	r13, 0x007F	; 0x80007f <saveTemps+0xd>
 5c4:	e0 90 80 00 	lds	r14, 0x0080	; 0x800080 <saveTemps+0xe>
 5c8:	f0 90 81 00 	lds	r15, 0x0081	; 0x800081 <saveTemps+0xf>
 5cc:	20 e0       	ldi	r18, 0x00	; 0
 5ce:	30 e0       	ldi	r19, 0x00	; 0
 5d0:	40 e2       	ldi	r20, 0x20	; 32
 5d2:	51 e4       	ldi	r21, 0x41	; 65
 5d4:	c7 01       	movw	r24, r14
 5d6:	b6 01       	movw	r22, r12
 5d8:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__cmpsf2>
 5dc:	88 23       	and	r24, r24
 5de:	94 f4       	brge	.+36     	; 0x604 <tempHeaterHelper+0x13a>
					if (!opMode)
 5e0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 5e4:	81 11       	cpse	r24, r1
 5e6:	07 c0       	rjmp	.+14     	; 0x5f6 <tempHeaterHelper+0x12c>
						assign_bit(&TCCR0, CS02, 1);      // This will turn the PWM back on
 5e8:	41 e0       	ldi	r20, 0x01	; 1
 5ea:	62 e0       	ldi	r22, 0x02	; 2
 5ec:	83 e5       	ldi	r24, 0x53	; 83
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 5f4:	cd c0       	rjmp	.+410    	; 0x790 <tempHeaterHelper+0x2c6>
					else
						assign_bit(&PORTB, ECU_pin, 1);   // Turn the heater on manually
 5f6:	41 e0       	ldi	r20, 0x01	; 1
 5f8:	63 e0       	ldi	r22, 0x03	; 3
 5fa:	88 e3       	ldi	r24, 0x38	; 56
 5fc:	90 e0       	ldi	r25, 0x00	; 0
 5fe:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 602:	c6 c0       	rjmp	.+396    	; 0x790 <tempHeaterHelper+0x2c6>
				else if (saveTemps[3] > TempECU)
 604:	20 e0       	ldi	r18, 0x00	; 0
 606:	30 e0       	ldi	r19, 0x00	; 0
 608:	40 e2       	ldi	r20, 0x20	; 32
 60a:	51 e4       	ldi	r21, 0x41	; 65
 60c:	c7 01       	movw	r24, r14
 60e:	b6 01       	movw	r22, r12
 610:	0e 94 b0 06 	call	0xd60	; 0xd60 <__gesf2>
 614:	18 16       	cp	r1, r24
 616:	0c f0       	brlt	.+2      	; 0x61a <tempHeaterHelper+0x150>
 618:	bb c0       	rjmp	.+374    	; 0x790 <tempHeaterHelper+0x2c6>
				{
					if (!opMode)
 61a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 61e:	81 11       	cpse	r24, r1
 620:	0c c0       	rjmp	.+24     	; 0x63a <tempHeaterHelper+0x170>
					{
						assign_bit(&TCCR0, CS02, 0);      // This will turn the PWM off
 622:	40 e0       	ldi	r20, 0x00	; 0
 624:	62 e0       	ldi	r22, 0x02	; 2
 626:	83 e5       	ldi	r24, 0x53	; 83
 628:	90 e0       	ldi	r25, 0x00	; 0
 62a:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x04;
 62e:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 632:	84 60       	ori	r24, 0x04	; 4
 634:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 638:	ab c0       	rjmp	.+342    	; 0x790 <tempHeaterHelper+0x2c6>
					}
					else
						assign_bit(&PORTB, ECU_pin, 0);   // Turn the heater off manually.  Don't do the same thing with desired_temp for the manual mode
 63a:	40 e0       	ldi	r20, 0x00	; 0
 63c:	63 e0       	ldi	r22, 0x03	; 3
 63e:	88 e3       	ldi	r24, 0x38	; 56
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 646:	a4 c0       	rjmp	.+328    	; 0x790 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 3:       // This is the case for Fuel Line 1  /////////////////////////////////////////////////
				if (saveTemps[4] < TempFLine1)
 648:	c0 90 82 00 	lds	r12, 0x0082	; 0x800082 <saveTemps+0x10>
 64c:	d0 90 83 00 	lds	r13, 0x0083	; 0x800083 <saveTemps+0x11>
 650:	e0 90 84 00 	lds	r14, 0x0084	; 0x800084 <saveTemps+0x12>
 654:	f0 90 85 00 	lds	r15, 0x0085	; 0x800085 <saveTemps+0x13>
 658:	20 e0       	ldi	r18, 0x00	; 0
 65a:	30 e0       	ldi	r19, 0x00	; 0
 65c:	40 e2       	ldi	r20, 0x20	; 32
 65e:	51 e4       	ldi	r21, 0x41	; 65
 660:	c7 01       	movw	r24, r14
 662:	b6 01       	movw	r22, r12
 664:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__cmpsf2>
 668:	88 23       	and	r24, r24
 66a:	3c f4       	brge	.+14     	; 0x67a <tempHeaterHelper+0x1b0>
					assign_bit(&PORTD, FLine1Pin, 1);
 66c:	41 e0       	ldi	r20, 0x01	; 1
 66e:	62 e0       	ldi	r22, 0x02	; 2
 670:	82 e3       	ldi	r24, 0x32	; 50
 672:	90 e0       	ldi	r25, 0x00	; 0
 674:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 678:	8b c0       	rjmp	.+278    	; 0x790 <tempHeaterHelper+0x2c6>
				else if(saveTemps[4] > TempFLine1)
 67a:	20 e0       	ldi	r18, 0x00	; 0
 67c:	30 e0       	ldi	r19, 0x00	; 0
 67e:	40 e2       	ldi	r20, 0x20	; 32
 680:	51 e4       	ldi	r21, 0x41	; 65
 682:	c7 01       	movw	r24, r14
 684:	b6 01       	movw	r22, r12
 686:	0e 94 b0 06 	call	0xd60	; 0xd60 <__gesf2>
 68a:	18 16       	cp	r1, r24
 68c:	0c f0       	brlt	.+2      	; 0x690 <tempHeaterHelper+0x1c6>
 68e:	80 c0       	rjmp	.+256    	; 0x790 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, FLine1Pin, 0);
 690:	40 e0       	ldi	r20, 0x00	; 0
 692:	62 e0       	ldi	r22, 0x02	; 2
 694:	82 e3       	ldi	r24, 0x32	; 50
 696:	90 e0       	ldi	r25, 0x00	; 0
 698:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x08;
 69c:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 6a0:	88 60       	ori	r24, 0x08	; 8
 6a2:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 6a6:	74 c0       	rjmp	.+232    	; 0x790 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 4:       // This is the case for Fuel Line 2 /////////////////////////////////////////////////
				if (saveTemps[5] < TempFLine2){
 6a8:	c0 90 86 00 	lds	r12, 0x0086	; 0x800086 <saveTemps+0x14>
 6ac:	d0 90 87 00 	lds	r13, 0x0087	; 0x800087 <saveTemps+0x15>
 6b0:	e0 90 88 00 	lds	r14, 0x0088	; 0x800088 <saveTemps+0x16>
 6b4:	f0 90 89 00 	lds	r15, 0x0089	; 0x800089 <saveTemps+0x17>
 6b8:	20 e0       	ldi	r18, 0x00	; 0
 6ba:	30 e0       	ldi	r19, 0x00	; 0
 6bc:	40 e2       	ldi	r20, 0x20	; 32
 6be:	51 e4       	ldi	r21, 0x41	; 65
 6c0:	c7 01       	movw	r24, r14
 6c2:	b6 01       	movw	r22, r12
 6c4:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__cmpsf2>
 6c8:	88 23       	and	r24, r24
 6ca:	94 f4       	brge	.+36     	; 0x6f0 <tempHeaterHelper+0x226>
					if (!opMode)      // We are in the warming mode so this can use the PWM
 6cc:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 6d0:	81 11       	cpse	r24, r1
 6d2:	07 c0       	rjmp	.+14     	; 0x6e2 <tempHeaterHelper+0x218>
						assign_bit(&TCCR2, CS22, 1);          // Turn the PWM back on 
 6d4:	41 e0       	ldi	r20, 0x01	; 1
 6d6:	62 e0       	ldi	r22, 0x02	; 2
 6d8:	85 e4       	ldi	r24, 0x45	; 69
 6da:	90 e0       	ldi	r25, 0x00	; 0
 6dc:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 6e0:	57 c0       	rjmp	.+174    	; 0x790 <tempHeaterHelper+0x2c6>
					else
						assign_bit(&PORTD,Fline2Pin,1);       // Turn the heater on manually
 6e2:	41 e0       	ldi	r20, 0x01	; 1
 6e4:	67 e0       	ldi	r22, 0x07	; 7
 6e6:	82 e3       	ldi	r24, 0x32	; 50
 6e8:	90 e0       	ldi	r25, 0x00	; 0
 6ea:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 6ee:	50 c0       	rjmp	.+160    	; 0x790 <tempHeaterHelper+0x2c6>
				}
				else if (saveTemps[5] > TempFLine2)
 6f0:	20 e0       	ldi	r18, 0x00	; 0
 6f2:	30 e0       	ldi	r19, 0x00	; 0
 6f4:	40 e2       	ldi	r20, 0x20	; 32
 6f6:	51 e4       	ldi	r21, 0x41	; 65
 6f8:	c7 01       	movw	r24, r14
 6fa:	b6 01       	movw	r22, r12
 6fc:	0e 94 b0 06 	call	0xd60	; 0xd60 <__gesf2>
 700:	18 16       	cp	r1, r24
 702:	0c f0       	brlt	.+2      	; 0x706 <tempHeaterHelper+0x23c>
 704:	45 c0       	rjmp	.+138    	; 0x790 <tempHeaterHelper+0x2c6>
				{
					if (!opMode)           // We are in warming mode so this can use the PWM
 706:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 70a:	81 11       	cpse	r24, r1
 70c:	0c c0       	rjmp	.+24     	; 0x726 <tempHeaterHelper+0x25c>
					{
						assign_bit(&TCCR2, CS22, 0);       // Turn the PWM off
 70e:	40 e0       	ldi	r20, 0x00	; 0
 710:	62 e0       	ldi	r22, 0x02	; 2
 712:	85 e4       	ldi	r24, 0x45	; 69
 714:	90 e0       	ldi	r25, 0x00	; 0
 716:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
						desired_temp |= 0x10;
 71a:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 71e:	80 61       	ori	r24, 0x10	; 16
 720:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 724:	35 c0       	rjmp	.+106    	; 0x790 <tempHeaterHelper+0x2c6>
					}
					else
						assign_bit(&PORTD, Fline2Pin, 0);    // Turn the heater off manually
 726:	40 e0       	ldi	r20, 0x00	; 0
 728:	67 e0       	ldi	r22, 0x07	; 7
 72a:	82 e3       	ldi	r24, 0x32	; 50
 72c:	90 e0       	ldi	r25, 0x00	; 0
 72e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 732:	2e c0       	rjmp	.+92     	; 0x790 <tempHeaterHelper+0x2c6>
				}
				break;
				
			case 5:       // This is the case for the ESB    /////////////////////////////////////////////////
				if (saveTemps[5] < TempESB)
 734:	c0 90 86 00 	lds	r12, 0x0086	; 0x800086 <saveTemps+0x14>
 738:	d0 90 87 00 	lds	r13, 0x0087	; 0x800087 <saveTemps+0x15>
 73c:	e0 90 88 00 	lds	r14, 0x0088	; 0x800088 <saveTemps+0x16>
 740:	f0 90 89 00 	lds	r15, 0x0089	; 0x800089 <saveTemps+0x17>
 744:	20 e0       	ldi	r18, 0x00	; 0
 746:	30 e0       	ldi	r19, 0x00	; 0
 748:	40 e2       	ldi	r20, 0x20	; 32
 74a:	51 e4       	ldi	r21, 0x41	; 65
 74c:	c7 01       	movw	r24, r14
 74e:	b6 01       	movw	r22, r12
 750:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__cmpsf2>
 754:	88 23       	and	r24, r24
 756:	3c f4       	brge	.+14     	; 0x766 <tempHeaterHelper+0x29c>
					assign_bit(&PORTD, ESB_Pin, 1);
 758:	41 e0       	ldi	r20, 0x01	; 1
 75a:	63 e0       	ldi	r22, 0x03	; 3
 75c:	82 e3       	ldi	r24, 0x32	; 50
 75e:	90 e0       	ldi	r25, 0x00	; 0
 760:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
 764:	15 c0       	rjmp	.+42     	; 0x790 <tempHeaterHelper+0x2c6>
				else if(saveTemps[5] > TempESB)
 766:	20 e0       	ldi	r18, 0x00	; 0
 768:	30 e0       	ldi	r19, 0x00	; 0
 76a:	40 e2       	ldi	r20, 0x20	; 32
 76c:	51 e4       	ldi	r21, 0x41	; 65
 76e:	c7 01       	movw	r24, r14
 770:	b6 01       	movw	r22, r12
 772:	0e 94 b0 06 	call	0xd60	; 0xd60 <__gesf2>
 776:	18 16       	cp	r1, r24
 778:	5c f4       	brge	.+22     	; 0x790 <tempHeaterHelper+0x2c6>
				{
					assign_bit(&PORTD, ESB_Pin, 0);
 77a:	40 e0       	ldi	r20, 0x00	; 0
 77c:	63 e0       	ldi	r22, 0x03	; 3
 77e:	82 e3       	ldi	r24, 0x32	; 50
 780:	90 e0       	ldi	r25, 0x00	; 0
 782:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
					desired_temp |= 0x20;
 786:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 78a:	80 62       	ori	r24, 0x20	; 32
 78c:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <desired_temp>
 *  @note Need to confirm that heater operation is still sufficient for phase 1 and 2.
 *  @see tempConversion
 */
void tempHeaterHelper(void)
{
	for (uint8_t i = 0; i < 6; i++)
 790:	cf 5f       	subi	r28, 0xFF	; 255
 792:	c6 30       	cpi	r28, 0x06	; 6
 794:	08 f4       	brcc	.+2      	; 0x798 <tempHeaterHelper+0x2ce>
 796:	a0 ce       	rjmp	.-704    	; 0x4d8 <tempHeaterHelper+0xe>
				break;
		}
		
	}
	
	if (desired_temp == 0x3F)      // Will go in here every time after it stops being mode 0
 798:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <desired_temp>
 79c:	8f 33       	cpi	r24, 0x3F	; 63
 79e:	31 f4       	brne	.+12     	; 0x7ac <tempHeaterHelper+0x2e2>
		/* If desired_temp was 0111 1111, it would go to 1111 1111 with the or.
		*   Then the bitwise not (~) would make it 0000 0000.  And finally,
		*   the logical not (!) would make it 0000 0001 and it would go into the if statement.
		*   If desired_temp is anything but this, it will not go in here 
		*/
		if (!opMode)    // only do this if it has never gone in here before
 7a0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 7a4:	81 11       	cpse	r24, r1
 7a6:	02 c0       	rjmp	.+4      	; 0x7ac <tempHeaterHelper+0x2e2>
			change_timers();                     // New initialization routine which will change the prescalars and such for the timers which will be serving different purposes
 7a8:	0e 94 fe 01 	call	0x3fc	; 0x3fc <change_timers>
	}
}
 7ac:	cf 91       	pop	r28
 7ae:	ff 90       	pop	r15
 7b0:	ef 90       	pop	r14
 7b2:	df 90       	pop	r13
 7b4:	cf 90       	pop	r12
 7b6:	08 95       	ret

000007b8 <tempConversion>:
 *  @param void
 *  @return void
 *  @see tempHeaterHelper
 */
void tempConversion(void)
{
 7b8:	1f 93       	push	r17
 7ba:	cf 93       	push	r28
 7bc:	df 93       	push	r29
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
 7be:	40 e0       	ldi	r20, 0x00	; 0
 7c0:	60 e0       	ldi	r22, 0x00	; 0
 7c2:	87 e2       	ldi	r24, 0x27	; 39
 7c4:	90 e0       	ldi	r25, 0x00	; 0
 7c6:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX1,0);
 7ca:	40 e0       	ldi	r20, 0x00	; 0
 7cc:	61 e0       	ldi	r22, 0x01	; 1
 7ce:	87 e2       	ldi	r24, 0x27	; 39
 7d0:	90 e0       	ldi	r25, 0x00	; 0
 7d2:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	assign_bit(&ADMUX,MUX2,0);
 7d6:	40 e0       	ldi	r20, 0x00	; 0
 7d8:	62 e0       	ldi	r22, 0x02	; 2
 7da:	87 e2       	ldi	r24, 0x27	; 39
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	
	for (unsigned char i = 0; i < 6; i++)
 7e2:	10 e0       	ldi	r17, 0x00	; 0
 7e4:	53 c0       	rjmp	.+166    	; 0x88c <__stack+0x2d>
	{
		ADCSRA |= 1 << ADSC;                             // Start the conversion
 7e6:	86 b1       	in	r24, 0x06	; 6
 7e8:	80 64       	ori	r24, 0x40	; 64
 7ea:	86 b9       	out	0x06, r24	; 6
		while (!((1 << ADIF) & ADCSRA));
 7ec:	34 9b       	sbis	0x06, 4	; 6
 7ee:	fe cf       	rjmp	.-4      	; 0x7ec <tempConversion+0x34>
		
		while (bit_is_clear(ADCSRA, ADIF));				 // Hog execution until the ADC is done converting
 7f0:	34 9b       	sbis	0x06, 4	; 6
 7f2:	fe cf       	rjmp	.-4      	; 0x7f0 <tempConversion+0x38>

		// Save this as a float for the respective variable
		uint8_t low_bits = ADCL;
 7f4:	84 b1       	in	r24, 0x04	; 4
		uint8_t high_bits = ADCH;						 // Do the shifting so that there is room made inside of the 16 bit register
 7f6:	65 b1       	in	r22, 0x05	; 5
		uint16_t result = (high_bits << 8) | low_bits;
 7f8:	70 e0       	ldi	r23, 0x00	; 0
 7fa:	76 2f       	mov	r23, r22
 7fc:	66 27       	eor	r22, r22
 7fe:	68 2b       	or	r22, r24
		
		// Now I need to convert this 16 bit number into an actual temperature
		
		float act_temp = (float)(0.0048828125*result);   // This dumb thing converts it to a voltage
 800:	80 e0       	ldi	r24, 0x00	; 0
 802:	90 e0       	ldi	r25, 0x00	; 0
 804:	0e 94 fe 05 	call	0xbfc	; 0xbfc <__floatunsisf>
 808:	20 e0       	ldi	r18, 0x00	; 0
 80a:	30 e0       	ldi	r19, 0x00	; 0
 80c:	40 ea       	ldi	r20, 0xA0	; 160
 80e:	5b e3       	ldi	r21, 0x3B	; 59
 810:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__mulsf3>
		act_temp = act_temp*208.8 - 79.6;
 814:	2d ec       	ldi	r18, 0xCD	; 205
 816:	3c ec       	ldi	r19, 0xCC	; 204
 818:	40 e5       	ldi	r20, 0x50	; 80
 81a:	53 e4       	ldi	r21, 0x43	; 67
 81c:	0e 94 b5 06 	call	0xd6a	; 0xd6a <__mulsf3>
 820:	23 e3       	ldi	r18, 0x33	; 51
 822:	33 e3       	ldi	r19, 0x33	; 51
 824:	4f e9       	ldi	r20, 0x9F	; 159
 826:	52 e4       	ldi	r21, 0x42	; 66
 828:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <__subsf3>
		saveTemps[i] = act_temp;
 82c:	c1 2f       	mov	r28, r17
 82e:	d0 e0       	ldi	r29, 0x00	; 0
 830:	fe 01       	movw	r30, r28
 832:	ee 0f       	add	r30, r30
 834:	ff 1f       	adc	r31, r31
 836:	ee 0f       	add	r30, r30
 838:	ff 1f       	adc	r31, r31
 83a:	ee 58       	subi	r30, 0x8E	; 142
 83c:	ff 4f       	sbci	r31, 0xFF	; 255
 83e:	60 83       	st	Z, r22
 840:	71 83       	std	Z+1, r23	; 0x01
 842:	82 83       	std	Z+2, r24	; 0x02
 844:	93 83       	std	Z+3, r25	; 0x03
		
		// Now update the channel the ADC is using
		assign_bit(&ADMUX,MUX0,(i + 1) & 0x01);           // Assign bit 0
 846:	1f 5f       	subi	r17, 0xFF	; 255
 848:	41 2f       	mov	r20, r17
 84a:	41 70       	andi	r20, 0x01	; 1
 84c:	60 e0       	ldi	r22, 0x00	; 0
 84e:	87 e2       	ldi	r24, 0x27	; 39
 850:	90 e0       	ldi	r25, 0x00	; 0
 852:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX1,((i + 1) >> 1) & 0x01);    // Assign bit 1
 856:	21 96       	adiw	r28, 0x01	; 1
 858:	ae 01       	movw	r20, r28
 85a:	55 95       	asr	r21
 85c:	47 95       	ror	r20
 85e:	41 70       	andi	r20, 0x01	; 1
 860:	61 e0       	ldi	r22, 0x01	; 1
 862:	87 e2       	ldi	r24, 0x27	; 39
 864:	90 e0       	ldi	r25, 0x00	; 0
 866:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
 86a:	d5 95       	asr	r29
 86c:	c7 95       	ror	r28
 86e:	d5 95       	asr	r29
 870:	c7 95       	ror	r28
 872:	4c 2f       	mov	r20, r28
 874:	41 70       	andi	r20, 0x01	; 1
 876:	62 e0       	ldi	r22, 0x02	; 2
 878:	87 e2       	ldi	r24, 0x27	; 39
 87a:	90 e0       	ldi	r25, 0x00	; 0
 87c:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet
 880:	41 e0       	ldi	r20, 0x01	; 1
 882:	64 e0       	ldi	r22, 0x04	; 4
 884:	86 e2       	ldi	r24, 0x26	; 38
 886:	90 e0       	ldi	r25, 0x00	; 0
 888:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
	// First check if the ADC is done converting
	assign_bit(&ADMUX,MUX0,0);    // Assign channel to 0
	assign_bit(&ADMUX,MUX1,0);
	assign_bit(&ADMUX,MUX2,0);
	
	for (unsigned char i = 0; i < 6; i++)
 88c:	16 30       	cpi	r17, 0x06	; 6
 88e:	08 f4       	brcc	.+2      	; 0x892 <__stack+0x33>
 890:	aa cf       	rjmp	.-172    	; 0x7e6 <tempConversion+0x2e>
		assign_bit(&ADMUX,MUX2,((i + 1) >> 2) & 0x01);    // Assign bit 2
		
		assign_bit(&ADCSRA, ADIF, 1);     // write a logical 1 to clear the flag, page 216 in the data sheet

	}
	tempHeaterHelper();             // Call the helper function.  This will serve the added bonus of killing some time so that if capacitors need to charge for the next conversion, it has the time here.  Data sheet didn't say that it needed this though.
 892:	0e 94 65 02 	call	0x4ca	; 0x4ca <tempHeaterHelper>
	if (opMode != 1)
 896:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 89a:	81 30       	cpi	r24, 0x01	; 1
 89c:	31 f0       	breq	.+12     	; 0x8aa <__stack+0x4b>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 89e:	83 e2       	ldi	r24, 0x23	; 35
 8a0:	94 ef       	ldi	r25, 0xF4	; 244
 8a2:	01 97       	sbiw	r24, 0x01	; 1
 8a4:	f1 f7       	brne	.-4      	; 0x8a2 <__stack+0x43>
 8a6:	00 c0       	rjmp	.+0      	; 0x8a8 <__stack+0x49>
 8a8:	00 00       	nop
		_delay_ms(250);                 // Delay for 1/4 of a second.   This will only impact modes 0 and 2
	
}
 8aa:	df 91       	pop	r29
 8ac:	cf 91       	pop	r28
 8ae:	1f 91       	pop	r17
 8b0:	08 95       	ret

000008b2 <__vector_3>:
 *  @param[in] pulse_count This is the number which describes how many pulses have been received for the sampling period.  It is an implicit argument as it is a global variable which is not explicitly passed in.
 *  @return void
 *  @see flowMeter
 */
ISR(INT2_vect)
{
 8b2:	1f 92       	push	r1
 8b4:	0f 92       	push	r0
 8b6:	0f b6       	in	r0, 0x3f	; 63
 8b8:	0f 92       	push	r0
 8ba:	11 24       	eor	r1, r1
 8bc:	8f 93       	push	r24
	pulse_count++;  // The interrupt flag will automatically be cleared by hardware
 8be:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <pulse_count>
 8c2:	8f 5f       	subi	r24, 0xFF	; 255
 8c4:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <pulse_count>
}
 8c8:	8f 91       	pop	r24
 8ca:	0f 90       	pop	r0
 8cc:	0f be       	out	0x3f, r0	; 63
 8ce:	0f 90       	pop	r0
 8d0:	1f 90       	pop	r1
 8d2:	18 95       	reti

000008d4 <__vector_5>:
 *
 *  @param[in] alive_counter Variable to act as a custom prescalar for the timer
 *  @return void
 */
ISR(TIMER2_OVF_vect)
{
 8d4:	1f 92       	push	r1
 8d6:	0f 92       	push	r0
 8d8:	0f b6       	in	r0, 0x3f	; 63
 8da:	0f 92       	push	r0
 8dc:	11 24       	eor	r1, r1
 8de:	2f 93       	push	r18
 8e0:	3f 93       	push	r19
 8e2:	4f 93       	push	r20
 8e4:	5f 93       	push	r21
 8e6:	6f 93       	push	r22
 8e8:	7f 93       	push	r23
 8ea:	8f 93       	push	r24
 8ec:	9f 93       	push	r25
 8ee:	af 93       	push	r26
 8f0:	bf 93       	push	r27
 8f2:	ef 93       	push	r30
 8f4:	ff 93       	push	r31
	if (opMode == 1)     // Operation mode 1 so do 0.75 sec on and 0.25 sec off
 8f6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 8fa:	81 30       	cpi	r24, 0x01	; 1
 8fc:	29 f5       	brne	.+74     	; 0x948 <__vector_5+0x74>
	{
		if (alive_counter == 2)
 8fe:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 902:	82 30       	cpi	r24, 0x02	; 2
 904:	71 f4       	brne	.+28     	; 0x922 <__vector_5+0x4e>
		{
			assign_bit(&PORTD, Alive_LED, 0);        // Turn the LED off since it is at the end of the 0.75 sec portion
 906:	40 e0       	ldi	r20, 0x00	; 0
 908:	65 e0       	ldi	r22, 0x05	; 5
 90a:	82 e3       	ldi	r24, 0x32	; 50
 90c:	90 e0       	ldi	r25, 0x00	; 0
 90e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
 912:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 916:	8f 5f       	subi	r24, 0xFF	; 255
 918:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 11;
 91c:	8b e0       	ldi	r24, 0x0B	; 11
 91e:	84 bd       	out	0x24, r24	; 36
 920:	37 c0       	rjmp	.+110    	; 0x990 <__vector_5+0xbc>
		}
		else if (alive_counter == 3)
 922:	83 30       	cpi	r24, 0x03	; 3
 924:	59 f4       	brne	.+22     	; 0x93c <__vector_5+0x68>
		{
			assign_bit(&PORTD, Alive_LED, 1);        // Turn the LED back on since it is about to begin the 0.75 second portion
 926:	41 e0       	ldi	r20, 0x01	; 1
 928:	65 e0       	ldi	r22, 0x05	; 5
 92a:	82 e3       	ldi	r24, 0x32	; 50
 92c:	90 e0       	ldi	r25, 0x00	; 0
 92e:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
 932:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
			TCNT2 = 11;                              // Assign the correct value into the Timer register so that it goes for 0.25 sec
 936:	8b e0       	ldi	r24, 0x0B	; 11
 938:	84 bd       	out	0x24, r24	; 36
 93a:	2a c0       	rjmp	.+84     	; 0x990 <__vector_5+0xbc>
		}
		else                                         // This section is for if it is in the middle of the 0.75 sec portion
		{
			alive_counter++;
 93c:	8f 5f       	subi	r24, 0xFF	; 255
 93e:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 11;
 942:	8b e0       	ldi	r24, 0x0B	; 11
 944:	84 bd       	out	0x24, r24	; 36
 946:	24 c0       	rjmp	.+72     	; 0x990 <__vector_5+0xbc>
		}
	}
	else   // I am in operation mode 2 so I need to do 0.1 sec on 0.9 sec off
	{
		if (alive_counter == 1)
 948:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 94c:	81 30       	cpi	r24, 0x01	; 1
 94e:	71 f4       	brne	.+28     	; 0x96c <__vector_5+0x98>
		{
			assign_bit(&PORTD, Alive_LED, 0);            // Turn off the LED since we are at the end of the 0.1 sec period
 950:	40 e0       	ldi	r20, 0x00	; 0
 952:	65 e0       	ldi	r22, 0x05	; 5
 954:	82 e3       	ldi	r24, 0x32	; 50
 956:	90 e0       	ldi	r25, 0x00	; 0
 958:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter++;
 95c:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <alive_counter>
 960:	8f 5f       	subi	r24, 0xFF	; 255
 962:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 60;
 966:	8c e3       	ldi	r24, 0x3C	; 60
 968:	84 bd       	out	0x24, r24	; 36
 96a:	12 c0       	rjmp	.+36     	; 0x990 <__vector_5+0xbc>
		}
		else if (alive_counter == 19)
 96c:	83 31       	cpi	r24, 0x13	; 19
 96e:	59 f4       	brne	.+22     	; 0x986 <__vector_5+0xb2>
		{
			assign_bit(&PORTD, Alive_LED, 1);            // Turn on the LED since we are at the end of the 0.9 sec period
 970:	41 e0       	ldi	r20, 0x01	; 1
 972:	65 e0       	ldi	r22, 0x05	; 5
 974:	82 e3       	ldi	r24, 0x32	; 50
 976:	90 e0       	ldi	r25, 0x00	; 0
 978:	0e 94 5f 00 	call	0xbe	; 0xbe <assign_bit>
			alive_counter = 0;
 97c:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <alive_counter>
			TCNT2 = 60;
 980:	8c e3       	ldi	r24, 0x3C	; 60
 982:	84 bd       	out	0x24, r24	; 36
 984:	05 c0       	rjmp	.+10     	; 0x990 <__vector_5+0xbc>

		}
		else
		{
			alive_counter++;                             // At one of the intermediate points so just keep the LED how it is
 986:	8f 5f       	subi	r24, 0xFF	; 255
 988:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <alive_counter>
			TCNT2 = 60; 
 98c:	8c e3       	ldi	r24, 0x3C	; 60
 98e:	84 bd       	out	0x24, r24	; 36
		}
	}
}
 990:	ff 91       	pop	r31
 992:	ef 91       	pop	r30
 994:	bf 91       	pop	r27
 996:	af 91       	pop	r26
 998:	9f 91       	pop	r25
 99a:	8f 91       	pop	r24
 99c:	7f 91       	pop	r23
 99e:	6f 91       	pop	r22
 9a0:	5f 91       	pop	r21
 9a2:	4f 91       	pop	r20
 9a4:	3f 91       	pop	r19
 9a6:	2f 91       	pop	r18
 9a8:	0f 90       	pop	r0
 9aa:	0f be       	out	0x3f, r0	; 63
 9ac:	0f 90       	pop	r0
 9ae:	1f 90       	pop	r1
 9b0:	18 95       	reti

000009b2 <main>:
 */ 
#include "HCU_Funcs.h"

int main(void)
{
    Initial();
 9b2:	0e 94 79 00 	call	0xf2	; 0xf2 <Initial>
    while (1) 
    {
		tempConversion();
 9b6:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <tempConversion>
		if (!ECU_present && (opMode == 1))    // Will only go in here if the ECU is not present and in pumping mode
 9ba:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <opMode>
 9be:	81 30       	cpi	r24, 0x01	; 1
 9c0:	d1 f7       	brne	.-12     	; 0x9b6 <main+0x4>
			flowMeter();
 9c2:	0e 94 39 01 	call	0x272	; 0x272 <flowMeter>
 9c6:	f7 cf       	rjmp	.-18     	; 0x9b6 <main+0x4>

000009c8 <__subsf3>:
 9c8:	50 58       	subi	r21, 0x80	; 128

000009ca <__addsf3>:
 9ca:	bb 27       	eor	r27, r27
 9cc:	aa 27       	eor	r26, r26
 9ce:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <__addsf3x>
 9d2:	0c 94 76 06 	jmp	0xcec	; 0xcec <__fp_round>
 9d6:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__fp_pscA>
 9da:	38 f0       	brcs	.+14     	; 0x9ea <__addsf3+0x20>
 9dc:	0e 94 6f 06 	call	0xcde	; 0xcde <__fp_pscB>
 9e0:	20 f0       	brcs	.+8      	; 0x9ea <__addsf3+0x20>
 9e2:	39 f4       	brne	.+14     	; 0x9f2 <__addsf3+0x28>
 9e4:	9f 3f       	cpi	r25, 0xFF	; 255
 9e6:	19 f4       	brne	.+6      	; 0x9ee <__addsf3+0x24>
 9e8:	26 f4       	brtc	.+8      	; 0x9f2 <__addsf3+0x28>
 9ea:	0c 94 65 06 	jmp	0xcca	; 0xcca <__fp_nan>
 9ee:	0e f4       	brtc	.+2      	; 0x9f2 <__addsf3+0x28>
 9f0:	e0 95       	com	r30
 9f2:	e7 fb       	bst	r30, 7
 9f4:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__fp_inf>

000009f8 <__addsf3x>:
 9f8:	e9 2f       	mov	r30, r25
 9fa:	0e 94 87 06 	call	0xd0e	; 0xd0e <__fp_split3>
 9fe:	58 f3       	brcs	.-42     	; 0x9d6 <__addsf3+0xc>
 a00:	ba 17       	cp	r27, r26
 a02:	62 07       	cpc	r22, r18
 a04:	73 07       	cpc	r23, r19
 a06:	84 07       	cpc	r24, r20
 a08:	95 07       	cpc	r25, r21
 a0a:	20 f0       	brcs	.+8      	; 0xa14 <__addsf3x+0x1c>
 a0c:	79 f4       	brne	.+30     	; 0xa2c <__addsf3x+0x34>
 a0e:	a6 f5       	brtc	.+104    	; 0xa78 <__addsf3x+0x80>
 a10:	0c 94 a9 06 	jmp	0xd52	; 0xd52 <__fp_zero>
 a14:	0e f4       	brtc	.+2      	; 0xa18 <__addsf3x+0x20>
 a16:	e0 95       	com	r30
 a18:	0b 2e       	mov	r0, r27
 a1a:	ba 2f       	mov	r27, r26
 a1c:	a0 2d       	mov	r26, r0
 a1e:	0b 01       	movw	r0, r22
 a20:	b9 01       	movw	r22, r18
 a22:	90 01       	movw	r18, r0
 a24:	0c 01       	movw	r0, r24
 a26:	ca 01       	movw	r24, r20
 a28:	a0 01       	movw	r20, r0
 a2a:	11 24       	eor	r1, r1
 a2c:	ff 27       	eor	r31, r31
 a2e:	59 1b       	sub	r21, r25
 a30:	99 f0       	breq	.+38     	; 0xa58 <__addsf3x+0x60>
 a32:	59 3f       	cpi	r21, 0xF9	; 249
 a34:	50 f4       	brcc	.+20     	; 0xa4a <__addsf3x+0x52>
 a36:	50 3e       	cpi	r21, 0xE0	; 224
 a38:	68 f1       	brcs	.+90     	; 0xa94 <__addsf3x+0x9c>
 a3a:	1a 16       	cp	r1, r26
 a3c:	f0 40       	sbci	r31, 0x00	; 0
 a3e:	a2 2f       	mov	r26, r18
 a40:	23 2f       	mov	r18, r19
 a42:	34 2f       	mov	r19, r20
 a44:	44 27       	eor	r20, r20
 a46:	58 5f       	subi	r21, 0xF8	; 248
 a48:	f3 cf       	rjmp	.-26     	; 0xa30 <__addsf3x+0x38>
 a4a:	46 95       	lsr	r20
 a4c:	37 95       	ror	r19
 a4e:	27 95       	ror	r18
 a50:	a7 95       	ror	r26
 a52:	f0 40       	sbci	r31, 0x00	; 0
 a54:	53 95       	inc	r21
 a56:	c9 f7       	brne	.-14     	; 0xa4a <__addsf3x+0x52>
 a58:	7e f4       	brtc	.+30     	; 0xa78 <__addsf3x+0x80>
 a5a:	1f 16       	cp	r1, r31
 a5c:	ba 0b       	sbc	r27, r26
 a5e:	62 0b       	sbc	r22, r18
 a60:	73 0b       	sbc	r23, r19
 a62:	84 0b       	sbc	r24, r20
 a64:	ba f0       	brmi	.+46     	; 0xa94 <__addsf3x+0x9c>
 a66:	91 50       	subi	r25, 0x01	; 1
 a68:	a1 f0       	breq	.+40     	; 0xa92 <__addsf3x+0x9a>
 a6a:	ff 0f       	add	r31, r31
 a6c:	bb 1f       	adc	r27, r27
 a6e:	66 1f       	adc	r22, r22
 a70:	77 1f       	adc	r23, r23
 a72:	88 1f       	adc	r24, r24
 a74:	c2 f7       	brpl	.-16     	; 0xa66 <__addsf3x+0x6e>
 a76:	0e c0       	rjmp	.+28     	; 0xa94 <__addsf3x+0x9c>
 a78:	ba 0f       	add	r27, r26
 a7a:	62 1f       	adc	r22, r18
 a7c:	73 1f       	adc	r23, r19
 a7e:	84 1f       	adc	r24, r20
 a80:	48 f4       	brcc	.+18     	; 0xa94 <__addsf3x+0x9c>
 a82:	87 95       	ror	r24
 a84:	77 95       	ror	r23
 a86:	67 95       	ror	r22
 a88:	b7 95       	ror	r27
 a8a:	f7 95       	ror	r31
 a8c:	9e 3f       	cpi	r25, 0xFE	; 254
 a8e:	08 f0       	brcs	.+2      	; 0xa92 <__addsf3x+0x9a>
 a90:	b0 cf       	rjmp	.-160    	; 0x9f2 <__addsf3+0x28>
 a92:	93 95       	inc	r25
 a94:	88 0f       	add	r24, r24
 a96:	08 f0       	brcs	.+2      	; 0xa9a <__addsf3x+0xa2>
 a98:	99 27       	eor	r25, r25
 a9a:	ee 0f       	add	r30, r30
 a9c:	97 95       	ror	r25
 a9e:	87 95       	ror	r24
 aa0:	08 95       	ret

00000aa2 <__cmpsf2>:
 aa2:	0e 94 3b 06 	call	0xc76	; 0xc76 <__fp_cmp>
 aa6:	08 f4       	brcc	.+2      	; 0xaaa <__cmpsf2+0x8>
 aa8:	81 e0       	ldi	r24, 0x01	; 1
 aaa:	08 95       	ret

00000aac <__divsf3>:
 aac:	0e 94 6a 05 	call	0xad4	; 0xad4 <__divsf3x>
 ab0:	0c 94 76 06 	jmp	0xcec	; 0xcec <__fp_round>
 ab4:	0e 94 6f 06 	call	0xcde	; 0xcde <__fp_pscB>
 ab8:	58 f0       	brcs	.+22     	; 0xad0 <__divsf3+0x24>
 aba:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__fp_pscA>
 abe:	40 f0       	brcs	.+16     	; 0xad0 <__divsf3+0x24>
 ac0:	29 f4       	brne	.+10     	; 0xacc <__divsf3+0x20>
 ac2:	5f 3f       	cpi	r21, 0xFF	; 255
 ac4:	29 f0       	breq	.+10     	; 0xad0 <__divsf3+0x24>
 ac6:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__fp_inf>
 aca:	51 11       	cpse	r21, r1
 acc:	0c 94 aa 06 	jmp	0xd54	; 0xd54 <__fp_szero>
 ad0:	0c 94 65 06 	jmp	0xcca	; 0xcca <__fp_nan>

00000ad4 <__divsf3x>:
 ad4:	0e 94 87 06 	call	0xd0e	; 0xd0e <__fp_split3>
 ad8:	68 f3       	brcs	.-38     	; 0xab4 <__divsf3+0x8>

00000ada <__divsf3_pse>:
 ada:	99 23       	and	r25, r25
 adc:	b1 f3       	breq	.-20     	; 0xaca <__divsf3+0x1e>
 ade:	55 23       	and	r21, r21
 ae0:	91 f3       	breq	.-28     	; 0xac6 <__divsf3+0x1a>
 ae2:	95 1b       	sub	r25, r21
 ae4:	55 0b       	sbc	r21, r21
 ae6:	bb 27       	eor	r27, r27
 ae8:	aa 27       	eor	r26, r26
 aea:	62 17       	cp	r22, r18
 aec:	73 07       	cpc	r23, r19
 aee:	84 07       	cpc	r24, r20
 af0:	38 f0       	brcs	.+14     	; 0xb00 <__divsf3_pse+0x26>
 af2:	9f 5f       	subi	r25, 0xFF	; 255
 af4:	5f 4f       	sbci	r21, 0xFF	; 255
 af6:	22 0f       	add	r18, r18
 af8:	33 1f       	adc	r19, r19
 afa:	44 1f       	adc	r20, r20
 afc:	aa 1f       	adc	r26, r26
 afe:	a9 f3       	breq	.-22     	; 0xaea <__divsf3_pse+0x10>
 b00:	35 d0       	rcall	.+106    	; 0xb6c <__divsf3_pse+0x92>
 b02:	0e 2e       	mov	r0, r30
 b04:	3a f0       	brmi	.+14     	; 0xb14 <__divsf3_pse+0x3a>
 b06:	e0 e8       	ldi	r30, 0x80	; 128
 b08:	32 d0       	rcall	.+100    	; 0xb6e <__divsf3_pse+0x94>
 b0a:	91 50       	subi	r25, 0x01	; 1
 b0c:	50 40       	sbci	r21, 0x00	; 0
 b0e:	e6 95       	lsr	r30
 b10:	00 1c       	adc	r0, r0
 b12:	ca f7       	brpl	.-14     	; 0xb06 <__divsf3_pse+0x2c>
 b14:	2b d0       	rcall	.+86     	; 0xb6c <__divsf3_pse+0x92>
 b16:	fe 2f       	mov	r31, r30
 b18:	29 d0       	rcall	.+82     	; 0xb6c <__divsf3_pse+0x92>
 b1a:	66 0f       	add	r22, r22
 b1c:	77 1f       	adc	r23, r23
 b1e:	88 1f       	adc	r24, r24
 b20:	bb 1f       	adc	r27, r27
 b22:	26 17       	cp	r18, r22
 b24:	37 07       	cpc	r19, r23
 b26:	48 07       	cpc	r20, r24
 b28:	ab 07       	cpc	r26, r27
 b2a:	b0 e8       	ldi	r27, 0x80	; 128
 b2c:	09 f0       	breq	.+2      	; 0xb30 <__divsf3_pse+0x56>
 b2e:	bb 0b       	sbc	r27, r27
 b30:	80 2d       	mov	r24, r0
 b32:	bf 01       	movw	r22, r30
 b34:	ff 27       	eor	r31, r31
 b36:	93 58       	subi	r25, 0x83	; 131
 b38:	5f 4f       	sbci	r21, 0xFF	; 255
 b3a:	3a f0       	brmi	.+14     	; 0xb4a <__divsf3_pse+0x70>
 b3c:	9e 3f       	cpi	r25, 0xFE	; 254
 b3e:	51 05       	cpc	r21, r1
 b40:	78 f0       	brcs	.+30     	; 0xb60 <__divsf3_pse+0x86>
 b42:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__fp_inf>
 b46:	0c 94 aa 06 	jmp	0xd54	; 0xd54 <__fp_szero>
 b4a:	5f 3f       	cpi	r21, 0xFF	; 255
 b4c:	e4 f3       	brlt	.-8      	; 0xb46 <__divsf3_pse+0x6c>
 b4e:	98 3e       	cpi	r25, 0xE8	; 232
 b50:	d4 f3       	brlt	.-12     	; 0xb46 <__divsf3_pse+0x6c>
 b52:	86 95       	lsr	r24
 b54:	77 95       	ror	r23
 b56:	67 95       	ror	r22
 b58:	b7 95       	ror	r27
 b5a:	f7 95       	ror	r31
 b5c:	9f 5f       	subi	r25, 0xFF	; 255
 b5e:	c9 f7       	brne	.-14     	; 0xb52 <__divsf3_pse+0x78>
 b60:	88 0f       	add	r24, r24
 b62:	91 1d       	adc	r25, r1
 b64:	96 95       	lsr	r25
 b66:	87 95       	ror	r24
 b68:	97 f9       	bld	r25, 7
 b6a:	08 95       	ret
 b6c:	e1 e0       	ldi	r30, 0x01	; 1
 b6e:	66 0f       	add	r22, r22
 b70:	77 1f       	adc	r23, r23
 b72:	88 1f       	adc	r24, r24
 b74:	bb 1f       	adc	r27, r27
 b76:	62 17       	cp	r22, r18
 b78:	73 07       	cpc	r23, r19
 b7a:	84 07       	cpc	r24, r20
 b7c:	ba 07       	cpc	r27, r26
 b7e:	20 f0       	brcs	.+8      	; 0xb88 <__divsf3_pse+0xae>
 b80:	62 1b       	sub	r22, r18
 b82:	73 0b       	sbc	r23, r19
 b84:	84 0b       	sbc	r24, r20
 b86:	ba 0b       	sbc	r27, r26
 b88:	ee 1f       	adc	r30, r30
 b8a:	88 f7       	brcc	.-30     	; 0xb6e <__divsf3_pse+0x94>
 b8c:	e0 95       	com	r30
 b8e:	08 95       	ret

00000b90 <__fixsfsi>:
 b90:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__fixunssfsi>
 b94:	68 94       	set
 b96:	b1 11       	cpse	r27, r1
 b98:	0c 94 aa 06 	jmp	0xd54	; 0xd54 <__fp_szero>
 b9c:	08 95       	ret

00000b9e <__fixunssfsi>:
 b9e:	0e 94 8f 06 	call	0xd1e	; 0xd1e <__fp_splitA>
 ba2:	88 f0       	brcs	.+34     	; 0xbc6 <__fixunssfsi+0x28>
 ba4:	9f 57       	subi	r25, 0x7F	; 127
 ba6:	98 f0       	brcs	.+38     	; 0xbce <__fixunssfsi+0x30>
 ba8:	b9 2f       	mov	r27, r25
 baa:	99 27       	eor	r25, r25
 bac:	b7 51       	subi	r27, 0x17	; 23
 bae:	b0 f0       	brcs	.+44     	; 0xbdc <__fixunssfsi+0x3e>
 bb0:	e1 f0       	breq	.+56     	; 0xbea <__fixunssfsi+0x4c>
 bb2:	66 0f       	add	r22, r22
 bb4:	77 1f       	adc	r23, r23
 bb6:	88 1f       	adc	r24, r24
 bb8:	99 1f       	adc	r25, r25
 bba:	1a f0       	brmi	.+6      	; 0xbc2 <__fixunssfsi+0x24>
 bbc:	ba 95       	dec	r27
 bbe:	c9 f7       	brne	.-14     	; 0xbb2 <__fixunssfsi+0x14>
 bc0:	14 c0       	rjmp	.+40     	; 0xbea <__fixunssfsi+0x4c>
 bc2:	b1 30       	cpi	r27, 0x01	; 1
 bc4:	91 f0       	breq	.+36     	; 0xbea <__fixunssfsi+0x4c>
 bc6:	0e 94 a9 06 	call	0xd52	; 0xd52 <__fp_zero>
 bca:	b1 e0       	ldi	r27, 0x01	; 1
 bcc:	08 95       	ret
 bce:	0c 94 a9 06 	jmp	0xd52	; 0xd52 <__fp_zero>
 bd2:	67 2f       	mov	r22, r23
 bd4:	78 2f       	mov	r23, r24
 bd6:	88 27       	eor	r24, r24
 bd8:	b8 5f       	subi	r27, 0xF8	; 248
 bda:	39 f0       	breq	.+14     	; 0xbea <__fixunssfsi+0x4c>
 bdc:	b9 3f       	cpi	r27, 0xF9	; 249
 bde:	cc f3       	brlt	.-14     	; 0xbd2 <__fixunssfsi+0x34>
 be0:	86 95       	lsr	r24
 be2:	77 95       	ror	r23
 be4:	67 95       	ror	r22
 be6:	b3 95       	inc	r27
 be8:	d9 f7       	brne	.-10     	; 0xbe0 <__fixunssfsi+0x42>
 bea:	3e f4       	brtc	.+14     	; 0xbfa <__fixunssfsi+0x5c>
 bec:	90 95       	com	r25
 bee:	80 95       	com	r24
 bf0:	70 95       	com	r23
 bf2:	61 95       	neg	r22
 bf4:	7f 4f       	sbci	r23, 0xFF	; 255
 bf6:	8f 4f       	sbci	r24, 0xFF	; 255
 bf8:	9f 4f       	sbci	r25, 0xFF	; 255
 bfa:	08 95       	ret

00000bfc <__floatunsisf>:
 bfc:	e8 94       	clt
 bfe:	09 c0       	rjmp	.+18     	; 0xc12 <__floatsisf+0x12>

00000c00 <__floatsisf>:
 c00:	97 fb       	bst	r25, 7
 c02:	3e f4       	brtc	.+14     	; 0xc12 <__floatsisf+0x12>
 c04:	90 95       	com	r25
 c06:	80 95       	com	r24
 c08:	70 95       	com	r23
 c0a:	61 95       	neg	r22
 c0c:	7f 4f       	sbci	r23, 0xFF	; 255
 c0e:	8f 4f       	sbci	r24, 0xFF	; 255
 c10:	9f 4f       	sbci	r25, 0xFF	; 255
 c12:	99 23       	and	r25, r25
 c14:	a9 f0       	breq	.+42     	; 0xc40 <__floatsisf+0x40>
 c16:	f9 2f       	mov	r31, r25
 c18:	96 e9       	ldi	r25, 0x96	; 150
 c1a:	bb 27       	eor	r27, r27
 c1c:	93 95       	inc	r25
 c1e:	f6 95       	lsr	r31
 c20:	87 95       	ror	r24
 c22:	77 95       	ror	r23
 c24:	67 95       	ror	r22
 c26:	b7 95       	ror	r27
 c28:	f1 11       	cpse	r31, r1
 c2a:	f8 cf       	rjmp	.-16     	; 0xc1c <__floatsisf+0x1c>
 c2c:	fa f4       	brpl	.+62     	; 0xc6c <__floatsisf+0x6c>
 c2e:	bb 0f       	add	r27, r27
 c30:	11 f4       	brne	.+4      	; 0xc36 <__floatsisf+0x36>
 c32:	60 ff       	sbrs	r22, 0
 c34:	1b c0       	rjmp	.+54     	; 0xc6c <__floatsisf+0x6c>
 c36:	6f 5f       	subi	r22, 0xFF	; 255
 c38:	7f 4f       	sbci	r23, 0xFF	; 255
 c3a:	8f 4f       	sbci	r24, 0xFF	; 255
 c3c:	9f 4f       	sbci	r25, 0xFF	; 255
 c3e:	16 c0       	rjmp	.+44     	; 0xc6c <__floatsisf+0x6c>
 c40:	88 23       	and	r24, r24
 c42:	11 f0       	breq	.+4      	; 0xc48 <__floatsisf+0x48>
 c44:	96 e9       	ldi	r25, 0x96	; 150
 c46:	11 c0       	rjmp	.+34     	; 0xc6a <__floatsisf+0x6a>
 c48:	77 23       	and	r23, r23
 c4a:	21 f0       	breq	.+8      	; 0xc54 <__floatsisf+0x54>
 c4c:	9e e8       	ldi	r25, 0x8E	; 142
 c4e:	87 2f       	mov	r24, r23
 c50:	76 2f       	mov	r23, r22
 c52:	05 c0       	rjmp	.+10     	; 0xc5e <__floatsisf+0x5e>
 c54:	66 23       	and	r22, r22
 c56:	71 f0       	breq	.+28     	; 0xc74 <__floatsisf+0x74>
 c58:	96 e8       	ldi	r25, 0x86	; 134
 c5a:	86 2f       	mov	r24, r22
 c5c:	70 e0       	ldi	r23, 0x00	; 0
 c5e:	60 e0       	ldi	r22, 0x00	; 0
 c60:	2a f0       	brmi	.+10     	; 0xc6c <__floatsisf+0x6c>
 c62:	9a 95       	dec	r25
 c64:	66 0f       	add	r22, r22
 c66:	77 1f       	adc	r23, r23
 c68:	88 1f       	adc	r24, r24
 c6a:	da f7       	brpl	.-10     	; 0xc62 <__floatsisf+0x62>
 c6c:	88 0f       	add	r24, r24
 c6e:	96 95       	lsr	r25
 c70:	87 95       	ror	r24
 c72:	97 f9       	bld	r25, 7
 c74:	08 95       	ret

00000c76 <__fp_cmp>:
 c76:	99 0f       	add	r25, r25
 c78:	00 08       	sbc	r0, r0
 c7a:	55 0f       	add	r21, r21
 c7c:	aa 0b       	sbc	r26, r26
 c7e:	e0 e8       	ldi	r30, 0x80	; 128
 c80:	fe ef       	ldi	r31, 0xFE	; 254
 c82:	16 16       	cp	r1, r22
 c84:	17 06       	cpc	r1, r23
 c86:	e8 07       	cpc	r30, r24
 c88:	f9 07       	cpc	r31, r25
 c8a:	c0 f0       	brcs	.+48     	; 0xcbc <__fp_cmp+0x46>
 c8c:	12 16       	cp	r1, r18
 c8e:	13 06       	cpc	r1, r19
 c90:	e4 07       	cpc	r30, r20
 c92:	f5 07       	cpc	r31, r21
 c94:	98 f0       	brcs	.+38     	; 0xcbc <__fp_cmp+0x46>
 c96:	62 1b       	sub	r22, r18
 c98:	73 0b       	sbc	r23, r19
 c9a:	84 0b       	sbc	r24, r20
 c9c:	95 0b       	sbc	r25, r21
 c9e:	39 f4       	brne	.+14     	; 0xcae <__fp_cmp+0x38>
 ca0:	0a 26       	eor	r0, r26
 ca2:	61 f0       	breq	.+24     	; 0xcbc <__fp_cmp+0x46>
 ca4:	23 2b       	or	r18, r19
 ca6:	24 2b       	or	r18, r20
 ca8:	25 2b       	or	r18, r21
 caa:	21 f4       	brne	.+8      	; 0xcb4 <__fp_cmp+0x3e>
 cac:	08 95       	ret
 cae:	0a 26       	eor	r0, r26
 cb0:	09 f4       	brne	.+2      	; 0xcb4 <__fp_cmp+0x3e>
 cb2:	a1 40       	sbci	r26, 0x01	; 1
 cb4:	a6 95       	lsr	r26
 cb6:	8f ef       	ldi	r24, 0xFF	; 255
 cb8:	81 1d       	adc	r24, r1
 cba:	81 1d       	adc	r24, r1
 cbc:	08 95       	ret

00000cbe <__fp_inf>:
 cbe:	97 f9       	bld	r25, 7
 cc0:	9f 67       	ori	r25, 0x7F	; 127
 cc2:	80 e8       	ldi	r24, 0x80	; 128
 cc4:	70 e0       	ldi	r23, 0x00	; 0
 cc6:	60 e0       	ldi	r22, 0x00	; 0
 cc8:	08 95       	ret

00000cca <__fp_nan>:
 cca:	9f ef       	ldi	r25, 0xFF	; 255
 ccc:	80 ec       	ldi	r24, 0xC0	; 192
 cce:	08 95       	ret

00000cd0 <__fp_pscA>:
 cd0:	00 24       	eor	r0, r0
 cd2:	0a 94       	dec	r0
 cd4:	16 16       	cp	r1, r22
 cd6:	17 06       	cpc	r1, r23
 cd8:	18 06       	cpc	r1, r24
 cda:	09 06       	cpc	r0, r25
 cdc:	08 95       	ret

00000cde <__fp_pscB>:
 cde:	00 24       	eor	r0, r0
 ce0:	0a 94       	dec	r0
 ce2:	12 16       	cp	r1, r18
 ce4:	13 06       	cpc	r1, r19
 ce6:	14 06       	cpc	r1, r20
 ce8:	05 06       	cpc	r0, r21
 cea:	08 95       	ret

00000cec <__fp_round>:
 cec:	09 2e       	mov	r0, r25
 cee:	03 94       	inc	r0
 cf0:	00 0c       	add	r0, r0
 cf2:	11 f4       	brne	.+4      	; 0xcf8 <__fp_round+0xc>
 cf4:	88 23       	and	r24, r24
 cf6:	52 f0       	brmi	.+20     	; 0xd0c <__fp_round+0x20>
 cf8:	bb 0f       	add	r27, r27
 cfa:	40 f4       	brcc	.+16     	; 0xd0c <__fp_round+0x20>
 cfc:	bf 2b       	or	r27, r31
 cfe:	11 f4       	brne	.+4      	; 0xd04 <__fp_round+0x18>
 d00:	60 ff       	sbrs	r22, 0
 d02:	04 c0       	rjmp	.+8      	; 0xd0c <__fp_round+0x20>
 d04:	6f 5f       	subi	r22, 0xFF	; 255
 d06:	7f 4f       	sbci	r23, 0xFF	; 255
 d08:	8f 4f       	sbci	r24, 0xFF	; 255
 d0a:	9f 4f       	sbci	r25, 0xFF	; 255
 d0c:	08 95       	ret

00000d0e <__fp_split3>:
 d0e:	57 fd       	sbrc	r21, 7
 d10:	90 58       	subi	r25, 0x80	; 128
 d12:	44 0f       	add	r20, r20
 d14:	55 1f       	adc	r21, r21
 d16:	59 f0       	breq	.+22     	; 0xd2e <__fp_splitA+0x10>
 d18:	5f 3f       	cpi	r21, 0xFF	; 255
 d1a:	71 f0       	breq	.+28     	; 0xd38 <__fp_splitA+0x1a>
 d1c:	47 95       	ror	r20

00000d1e <__fp_splitA>:
 d1e:	88 0f       	add	r24, r24
 d20:	97 fb       	bst	r25, 7
 d22:	99 1f       	adc	r25, r25
 d24:	61 f0       	breq	.+24     	; 0xd3e <__fp_splitA+0x20>
 d26:	9f 3f       	cpi	r25, 0xFF	; 255
 d28:	79 f0       	breq	.+30     	; 0xd48 <__fp_splitA+0x2a>
 d2a:	87 95       	ror	r24
 d2c:	08 95       	ret
 d2e:	12 16       	cp	r1, r18
 d30:	13 06       	cpc	r1, r19
 d32:	14 06       	cpc	r1, r20
 d34:	55 1f       	adc	r21, r21
 d36:	f2 cf       	rjmp	.-28     	; 0xd1c <__fp_split3+0xe>
 d38:	46 95       	lsr	r20
 d3a:	f1 df       	rcall	.-30     	; 0xd1e <__fp_splitA>
 d3c:	08 c0       	rjmp	.+16     	; 0xd4e <__fp_splitA+0x30>
 d3e:	16 16       	cp	r1, r22
 d40:	17 06       	cpc	r1, r23
 d42:	18 06       	cpc	r1, r24
 d44:	99 1f       	adc	r25, r25
 d46:	f1 cf       	rjmp	.-30     	; 0xd2a <__fp_splitA+0xc>
 d48:	86 95       	lsr	r24
 d4a:	71 05       	cpc	r23, r1
 d4c:	61 05       	cpc	r22, r1
 d4e:	08 94       	sec
 d50:	08 95       	ret

00000d52 <__fp_zero>:
 d52:	e8 94       	clt

00000d54 <__fp_szero>:
 d54:	bb 27       	eor	r27, r27
 d56:	66 27       	eor	r22, r22
 d58:	77 27       	eor	r23, r23
 d5a:	cb 01       	movw	r24, r22
 d5c:	97 f9       	bld	r25, 7
 d5e:	08 95       	ret

00000d60 <__gesf2>:
 d60:	0e 94 3b 06 	call	0xc76	; 0xc76 <__fp_cmp>
 d64:	08 f4       	brcc	.+2      	; 0xd68 <__gesf2+0x8>
 d66:	8f ef       	ldi	r24, 0xFF	; 255
 d68:	08 95       	ret

00000d6a <__mulsf3>:
 d6a:	0e 94 c8 06 	call	0xd90	; 0xd90 <__mulsf3x>
 d6e:	0c 94 76 06 	jmp	0xcec	; 0xcec <__fp_round>
 d72:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__fp_pscA>
 d76:	38 f0       	brcs	.+14     	; 0xd86 <__mulsf3+0x1c>
 d78:	0e 94 6f 06 	call	0xcde	; 0xcde <__fp_pscB>
 d7c:	20 f0       	brcs	.+8      	; 0xd86 <__mulsf3+0x1c>
 d7e:	95 23       	and	r25, r21
 d80:	11 f0       	breq	.+4      	; 0xd86 <__mulsf3+0x1c>
 d82:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__fp_inf>
 d86:	0c 94 65 06 	jmp	0xcca	; 0xcca <__fp_nan>
 d8a:	11 24       	eor	r1, r1
 d8c:	0c 94 aa 06 	jmp	0xd54	; 0xd54 <__fp_szero>

00000d90 <__mulsf3x>:
 d90:	0e 94 87 06 	call	0xd0e	; 0xd0e <__fp_split3>
 d94:	70 f3       	brcs	.-36     	; 0xd72 <__mulsf3+0x8>

00000d96 <__mulsf3_pse>:
 d96:	95 9f       	mul	r25, r21
 d98:	c1 f3       	breq	.-16     	; 0xd8a <__mulsf3+0x20>
 d9a:	95 0f       	add	r25, r21
 d9c:	50 e0       	ldi	r21, 0x00	; 0
 d9e:	55 1f       	adc	r21, r21
 da0:	62 9f       	mul	r22, r18
 da2:	f0 01       	movw	r30, r0
 da4:	72 9f       	mul	r23, r18
 da6:	bb 27       	eor	r27, r27
 da8:	f0 0d       	add	r31, r0
 daa:	b1 1d       	adc	r27, r1
 dac:	63 9f       	mul	r22, r19
 dae:	aa 27       	eor	r26, r26
 db0:	f0 0d       	add	r31, r0
 db2:	b1 1d       	adc	r27, r1
 db4:	aa 1f       	adc	r26, r26
 db6:	64 9f       	mul	r22, r20
 db8:	66 27       	eor	r22, r22
 dba:	b0 0d       	add	r27, r0
 dbc:	a1 1d       	adc	r26, r1
 dbe:	66 1f       	adc	r22, r22
 dc0:	82 9f       	mul	r24, r18
 dc2:	22 27       	eor	r18, r18
 dc4:	b0 0d       	add	r27, r0
 dc6:	a1 1d       	adc	r26, r1
 dc8:	62 1f       	adc	r22, r18
 dca:	73 9f       	mul	r23, r19
 dcc:	b0 0d       	add	r27, r0
 dce:	a1 1d       	adc	r26, r1
 dd0:	62 1f       	adc	r22, r18
 dd2:	83 9f       	mul	r24, r19
 dd4:	a0 0d       	add	r26, r0
 dd6:	61 1d       	adc	r22, r1
 dd8:	22 1f       	adc	r18, r18
 dda:	74 9f       	mul	r23, r20
 ddc:	33 27       	eor	r19, r19
 dde:	a0 0d       	add	r26, r0
 de0:	61 1d       	adc	r22, r1
 de2:	23 1f       	adc	r18, r19
 de4:	84 9f       	mul	r24, r20
 de6:	60 0d       	add	r22, r0
 de8:	21 1d       	adc	r18, r1
 dea:	82 2f       	mov	r24, r18
 dec:	76 2f       	mov	r23, r22
 dee:	6a 2f       	mov	r22, r26
 df0:	11 24       	eor	r1, r1
 df2:	9f 57       	subi	r25, 0x7F	; 127
 df4:	50 40       	sbci	r21, 0x00	; 0
 df6:	9a f0       	brmi	.+38     	; 0xe1e <__mulsf3_pse+0x88>
 df8:	f1 f0       	breq	.+60     	; 0xe36 <__mulsf3_pse+0xa0>
 dfa:	88 23       	and	r24, r24
 dfc:	4a f0       	brmi	.+18     	; 0xe10 <__mulsf3_pse+0x7a>
 dfe:	ee 0f       	add	r30, r30
 e00:	ff 1f       	adc	r31, r31
 e02:	bb 1f       	adc	r27, r27
 e04:	66 1f       	adc	r22, r22
 e06:	77 1f       	adc	r23, r23
 e08:	88 1f       	adc	r24, r24
 e0a:	91 50       	subi	r25, 0x01	; 1
 e0c:	50 40       	sbci	r21, 0x00	; 0
 e0e:	a9 f7       	brne	.-22     	; 0xdfa <__mulsf3_pse+0x64>
 e10:	9e 3f       	cpi	r25, 0xFE	; 254
 e12:	51 05       	cpc	r21, r1
 e14:	80 f0       	brcs	.+32     	; 0xe36 <__mulsf3_pse+0xa0>
 e16:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__fp_inf>
 e1a:	0c 94 aa 06 	jmp	0xd54	; 0xd54 <__fp_szero>
 e1e:	5f 3f       	cpi	r21, 0xFF	; 255
 e20:	e4 f3       	brlt	.-8      	; 0xe1a <__mulsf3_pse+0x84>
 e22:	98 3e       	cpi	r25, 0xE8	; 232
 e24:	d4 f3       	brlt	.-12     	; 0xe1a <__mulsf3_pse+0x84>
 e26:	86 95       	lsr	r24
 e28:	77 95       	ror	r23
 e2a:	67 95       	ror	r22
 e2c:	b7 95       	ror	r27
 e2e:	f7 95       	ror	r31
 e30:	e7 95       	ror	r30
 e32:	9f 5f       	subi	r25, 0xFF	; 255
 e34:	c1 f7       	brne	.-16     	; 0xe26 <__mulsf3_pse+0x90>
 e36:	fe 2b       	or	r31, r30
 e38:	88 0f       	add	r24, r24
 e3a:	91 1d       	adc	r25, r1
 e3c:	96 95       	lsr	r25
 e3e:	87 95       	ror	r24
 e40:	97 f9       	bld	r25, 7
 e42:	08 95       	ret

00000e44 <_exit>:
 e44:	f8 94       	cli

00000e46 <__stop_program>:
 e46:	ff cf       	rjmp	.-2      	; 0xe46 <__stop_program>
